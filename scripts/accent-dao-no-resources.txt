File: __init__.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import (
    default_config,
    init_db,
    init_db_from_config,
)

__all__ = [
    'init_db',
    'init_db_from_config',
    'default_config',
]

----------------------------------------

File: agent_dao.py
Please review for update

# Copyright 2023 Accent Communications
from __future__ import annotations

from typing import NamedTuple

from sqlalchemy.sql import and_, select

from accent_dao.alchemy.agentfeatures import AgentFeatures
from accent_dao.alchemy.queuefeatures import QueueFeatures
from accent_dao.alchemy.queuemember import QueueMember
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.helpers.db_manager import daosession


class _Agent(NamedTuple):
    id: int
    tenant_uuid: str
    number: str
    queues: list[QueueFeatures]
    user_ids: list[int]


class _Queue(NamedTuple):
    id: int
    tenant_uuid: str
    name: str
    penalty: int


@daosession
def agent_with_id(session, agent_id, tenant_uuids=None):
    agent = _get_agent(session, AgentFeatures.id == int(agent_id), tenant_uuids)
    _add_queues_to_agent(session, agent)
    return agent


@daosession
def agent_with_number(session, agent_number, tenant_uuids=None):
    agent = _get_agent(session, AgentFeatures.number == agent_number, tenant_uuids)
    _add_queues_to_agent(session, agent)
    return agent


@daosession
def agent_with_user_uuid(session, user_uuid, tenant_uuids=None):
    query = (
        session.query(AgentFeatures)
        .join(UserFeatures, AgentFeatures.id == UserFeatures.agentid)
        .filter(UserFeatures.uuid == user_uuid)
    )
    if tenant_uuids is not None:
        query = query.filter(AgentFeatures.tenant_uuid.in_(tenant_uuids))

    agent_row = query.first()
    if agent_row is None:
        raise LookupError(f'no agent found for user {user_uuid}')
    agent = _Agent(
        agent_row.id,
        agent_row.tenant_uuid,
        agent_row.number,
        [],
        [user.id for user in agent_row.users],
    )
    _add_queues_to_agent(session, agent)
    return agent


def _get_agent(session, whereclause, tenant_uuids=None):
    query = session.query(AgentFeatures).filter(whereclause)
    if tenant_uuids is not None:
        query = query.filter(AgentFeatures.tenant_uuid.in_(tenant_uuids))
    agent = query.first()
    if agent is None:
        raise LookupError(f'no agent matching clause {whereclause.compile().params}')
    return _Agent(
        agent.id, agent.tenant_uuid, agent.number, [], [user.id for user in agent.users]
    )


def _add_queues_to_agent(session, agent):
    query = select(
        [
            QueueFeatures.id,
            QueueFeatures.tenant_uuid,
            QueueMember.queue_name,
            QueueMember.penalty,
        ],
        and_(
            QueueMember.usertype == 'agent',
            QueueMember.userid == agent.id,
            QueueMember.queue_name == QueueFeatures.name,
        ),
    )

    for row in session.execute(query):
        queue = _Queue(row['id'], row['tenant_uuid'], row['queue_name'], row['penalty'])
        agent.queues.append(queue)


@daosession
def get(session, agentid, tenant_uuids=None):
    query = session.query(AgentFeatures).filter(AgentFeatures.id == int(agentid))
    if tenant_uuids is not None:
        query = query.filter(AgentFeatures.tenant_uuid.in_(tenant_uuids))
    return query.first()


@daosession
def all(session, tenant_uuids=None):
    query = session.query(AgentFeatures)
    if tenant_uuids is not None:
        query = query.filter(AgentFeatures.tenant_uuid.in_(tenant_uuids))
    return query.all()

----------------------------------------

File: agent_status_dao.py
Please review for update

# Copyright 2023 Accent Communications
from __future__ import annotations

from datetime import datetime
from typing import NamedTuple, Union

from sqlalchemy.sql.expression import case, false, true

from accent_dao.alchemy.agent_login_status import AgentLoginStatus
from accent_dao.alchemy.agent_membership_status import AgentMembershipStatus
from accent_dao.alchemy.agentfeatures import AgentFeatures
from accent_dao.alchemy.queuefeatures import QueueFeatures
from accent_dao.alchemy.queuemember import QueueMember
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.helpers.db_manager import daosession
from accent_dao.helpers.db_utils import flush_session


class _Queue(NamedTuple):
    id: int
    name: str
    penalty: int


class _AgentStatus(NamedTuple):
    agent_id: int
    agent_number: str
    extension: str
    context: str
    interface: str
    state_interface: str
    login_at: datetime
    paused: bool
    paused_reason: Union[str, None]
    queues: list[_Queue]
    user_ids: list[int]


@daosession
def get_status(session, agent_id, tenant_uuids=None):
    login_status = _get_login_status_by_id(session, agent_id, tenant_uuids=tenant_uuids)
    if not login_status:
        return None

    return _to_agent_status(login_status, _get_queues_for_agent(session, agent_id))


@daosession
def get_status_by_number(session, agent_number, tenant_uuids=None):
    login_status = _get_login_status_by_number(
        session, agent_number, tenant_uuids=tenant_uuids
    )
    if not login_status:
        return None

    return _to_agent_status(
        login_status, _get_queues_for_agent(session, login_status.agent_id)
    )


@daosession
def get_status_by_user(session, user_uuid, tenant_uuids=None):
    login_status = _get_login_status_by_user(
        session, user_uuid, tenant_uuids=tenant_uuids
    )
    if not login_status:
        return None

    return _to_agent_status(
        login_status, _get_queues_for_agent(session, login_status.agent_id)
    )


def _get_login_status_by_id(session, agent_id, tenant_uuids=None):
    login_status = (
        session.query(AgentLoginStatus)
        .outerjoin((AgentFeatures, AgentFeatures.id == AgentLoginStatus.agent_id))
        .filter(AgentLoginStatus.agent_id == agent_id)
    )
    if tenant_uuids is not None:
        login_status = login_status.filter(AgentFeatures.tenant_uuid.in_(tenant_uuids))
    return login_status.first()


def _get_login_status_by_number(session, agent_number, tenant_uuids=None):
    login_status = (
        session.query(AgentLoginStatus)
        .outerjoin((AgentFeatures, AgentFeatures.id == AgentLoginStatus.agent_id))
        .filter(AgentLoginStatus.agent_number == agent_number)
    )
    if tenant_uuids is not None:
        login_status = login_status.filter(AgentFeatures.tenant_uuid.in_(tenant_uuids))
    return login_status.first()


def _get_login_status_by_user(session, user_uuid, tenant_uuids=None):
    login_status = (
        session.query(AgentLoginStatus)
        .outerjoin((AgentFeatures, AgentFeatures.id == AgentLoginStatus.agent_id))
        .join((UserFeatures, AgentFeatures.id == UserFeatures.agentid))
        .filter(UserFeatures.uuid == user_uuid)
    )
    if tenant_uuids is not None:
        login_status = login_status.filter(AgentFeatures.tenant_uuid.in_(tenant_uuids))
    return login_status.first()


def _get_queues_for_agent(session, agent_id):
    query = session.query(
        AgentMembershipStatus.queue_id.label('queue_id'),
        AgentMembershipStatus.queue_name.label('queue_name'),
        AgentMembershipStatus.penalty.label('penalty'),
    ).filter(AgentMembershipStatus.agent_id == agent_id)

    return [_Queue(q.queue_id, q.queue_name, q.penalty) for q in query]


@daosession
def get_extension_from_agent_id(session, agent_id):
    login_status_row = (
        session.query(AgentLoginStatus.extension, AgentLoginStatus.context)
        .filter(AgentLoginStatus.agent_id == agent_id)
        .first()
    )

    if not login_status_row:
        raise LookupError(f'agent with id {agent_id} is not logged')

    return login_status_row.extension, login_status_row.context


@daosession
def get_agent_id_from_extension(session, extension, context):
    login_status = (
        session.query(AgentLoginStatus)
        .filter(AgentLoginStatus.extension == extension)
        .filter(AgentLoginStatus.context == context)
        .first()
    )
    if not login_status:
        raise LookupError(f'No agent logged onto extension {extension}@{context}')
    return login_status.agent_id


@daosession
def get_statuses(session, tenant_uuids=None):
    query = session.query(
        AgentFeatures.id.label('agent_id'),
        AgentFeatures.tenant_uuid.label('tenant_uuid'),
        AgentFeatures.number.label('agent_number'),
        AgentLoginStatus.extension.label('extension'),
        AgentLoginStatus.context.label('context'),
        AgentLoginStatus.state_interface.label('state_interface'),
        AgentLoginStatus.paused.label('paused'),
        AgentLoginStatus.paused_reason.label('paused_reason'),
        case([(AgentLoginStatus.agent_id.is_(None), false())], else_=true()).label(
            'logged'
        ),  # noqa
    ).outerjoin((AgentLoginStatus, AgentFeatures.id == AgentLoginStatus.agent_id))

    if tenant_uuids is not None:
        query = query.filter(AgentFeatures.tenant_uuid.in_(tenant_uuids))

    return query.all()


@daosession
def get_statuses_for_queue(session, queue_id):
    session = session

    subquery = (
        session.query(QueueMember.userid)
        .filter(QueueFeatures.name == QueueMember.queue_name)
        .filter(QueueFeatures.id == queue_id)
        .filter(QueueMember.usertype == 'agent')
    )
    query = session.query(AgentLoginStatus).filter(
        AgentLoginStatus.agent_id.in_(subquery)
    )

    return [_to_agent_status(q, None) for q in query]


@daosession
def get_statuses_to_add_to_queue(session, queue_id):
    q1 = (
        session.query(QueueMember.userid)
        .filter(QueueFeatures.name == QueueMember.queue_name)
        .filter(QueueFeatures.id == queue_id)
        .filter(QueueMember.usertype == 'agent')
    )
    q2 = session.query(AgentMembershipStatus.agent_id).filter(
        AgentMembershipStatus.queue_id == queue_id
    )
    agent_ids_to_add = q1.except_(q2)
    query = session.query(AgentLoginStatus).filter(
        AgentLoginStatus.agent_id.in_(agent_ids_to_add)
    )

    return [_to_agent_status(q, None) for q in query]


@daosession
def get_statuses_to_remove_from_queue(session, queue_id):
    q1 = session.query(AgentMembershipStatus.agent_id).filter(
        AgentMembershipStatus.queue_id == queue_id
    )
    q2 = (
        session.query(QueueMember.userid)
        .filter(QueueFeatures.name == QueueMember.queue_name)
        .filter(QueueFeatures.id == queue_id)
        .filter(QueueMember.usertype == 'agent')
    )
    agent_ids_to_remove = q1.except_(q2)
    query = session.query(AgentLoginStatus).filter(
        AgentLoginStatus.agent_id.in_(agent_ids_to_remove)
    )

    return [_to_agent_status(q, None) for q in query]


@daosession
def get_logged_agent_ids(session, tenant_uuids=None):
    query = session.query(
        AgentLoginStatus.agent_id, AgentFeatures.tenant_uuid
    ).outerjoin(AgentFeatures, AgentFeatures.id == AgentLoginStatus.agent_id)

    if tenant_uuids is not None:
        query = query.filter(AgentFeatures.tenant_uuid.in_(tenant_uuids))

    return [q.agent_id for q in query]


def _to_agent_status(agent_login_status, queues):
    agent = agent_login_status.agent
    user_ids = [user.id for user in agent.users] if agent else []
    return _AgentStatus(
        agent_login_status.agent_id,
        agent_login_status.agent_number,
        agent_login_status.extension,
        agent_login_status.context,
        agent_login_status.interface,
        agent_login_status.state_interface,
        agent_login_status.login_at,
        agent_login_status.paused,
        agent_login_status.paused_reason,
        queues,
        user_ids,
    )


@daosession
def is_extension_in_use(session, extension, context):
    count = (
        session.query(AgentLoginStatus)
        .filter(AgentLoginStatus.extension == extension)
        .filter(AgentLoginStatus.context == context)
        .count()
    )
    return count > 0


@daosession
def log_in_agent(
    session, agent_id, agent_number, extension, context, interface, state_interface
):
    agent = AgentLoginStatus()
    agent.agent_id = agent_id
    agent.agent_number = agent_number
    agent.extension = extension
    agent.context = context
    agent.interface = interface
    agent.state_interface = state_interface
    agent.paused = False

    _add_agent(session, agent)


def _add_agent(session, agent):
    with flush_session(session):
        session.add(agent)


@daosession
def log_off_agent(session, agent_id):
    (
        session.query(AgentLoginStatus)
        .filter(AgentLoginStatus.agent_id == agent_id)
        .delete(synchronize_session='fetch')
    )


@daosession
def add_agent_to_queues(session, agent_id, queues):
    for queue in queues:
        agent_membership_status = AgentMembershipStatus(
            agent_id=agent_id,
            queue_id=queue.id,
            queue_name=queue.name,
            penalty=queue.penalty,
        )
        session.add(agent_membership_status)


@daosession
def remove_agent_from_queues(session, agent_id, queue_ids):
    (
        session.query(AgentMembershipStatus)
        .filter(AgentMembershipStatus.agent_id == agent_id)
        .filter(AgentMembershipStatus.queue_id.in_(queue_ids))
        .delete(synchronize_session='fetch')
    )


@daosession
def remove_agent_from_all_queues(session, agent_id):
    (
        session.query(AgentMembershipStatus)
        .filter(AgentMembershipStatus.agent_id == agent_id)
        .delete(synchronize_session='fetch')
    )


@daosession
def remove_all_agents_from_queue(session, queue_id):
    (
        session.query(AgentMembershipStatus)
        .filter(AgentMembershipStatus.queue_id == queue_id)
        .delete(synchronize_session='fetch')
    )


@daosession
def update_penalty(session, agent_id, queue_id, penalty):
    (
        session.query(AgentMembershipStatus)
        .filter(AgentMembershipStatus.queue_id == queue_id)
        .filter(AgentMembershipStatus.agent_id == agent_id)
        .update({'penalty': penalty})
    )


@daosession
def update_pause_status(session, agent_id, is_paused, reason=None):
    (
        session.query(AgentLoginStatus)
        .filter(AgentLoginStatus.agent_id == agent_id)
        .update({'paused': is_paused, 'paused_reason': reason})
    )

----------------------------------------

File: alchemy/__init__.py
Please review for update

# Copyright 2023 Accent Communications

# explicitly import modules that are referenced in relationship to prevent
# "mapper initialization" errors
from accent_dao.alchemy.agentfeatures import AgentFeatures
from accent_dao.alchemy.agentqueueskill import AgentQueueSkill
from accent_dao.alchemy.application import Application
from accent_dao.alchemy.application_dest_node import ApplicationDestNode
from accent_dao.alchemy.asterisk_file_section import AsteriskFileSection
from accent_dao.alchemy.asterisk_file_variable import AsteriskFileVariable
from accent_dao.alchemy.callfilter import Callfilter
from accent_dao.alchemy.callfiltermember import Callfiltermember
from accent_dao.alchemy.conference import Conference
from accent_dao.alchemy.context import Context
from accent_dao.alchemy.contextinclude import ContextInclude
from accent_dao.alchemy.dialaction import Dialaction
from accent_dao.alchemy.endpoint_sip import EndpointSIP, EndpointSIPTemplate
from accent_dao.alchemy.endpoint_sip_options_view import EndpointSIPOptionsView
from accent_dao.alchemy.endpoint_sip_section import EndpointSIPSection
from accent_dao.alchemy.endpoint_sip_section_option import EndpointSIPSectionOption
from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.func_key_dest_agent import FuncKeyDestAgent
from accent_dao.alchemy.func_key_dest_bsfilter import FuncKeyDestBSFilter
from accent_dao.alchemy.func_key_dest_conference import FuncKeyDestConference
from accent_dao.alchemy.func_key_dest_group import FuncKeyDestGroup
from accent_dao.alchemy.func_key_dest_group_member import FuncKeyDestGroupMember
from accent_dao.alchemy.func_key_dest_paging import FuncKeyDestPaging
from accent_dao.alchemy.func_key_dest_park_position import FuncKeyDestParkPosition
from accent_dao.alchemy.func_key_dest_parking import FuncKeyDestParking
from accent_dao.alchemy.func_key_dest_queue import FuncKeyDestQueue
from accent_dao.alchemy.func_key_dest_user import FuncKeyDestUser
from accent_dao.alchemy.func_key_mapping import FuncKeyMapping
from accent_dao.alchemy.groupfeatures import GroupFeatures
from accent_dao.alchemy.incall import Incall
from accent_dao.alchemy.ingress_http import IngressHTTP
from accent_dao.alchemy.ivr import IVR
from accent_dao.alchemy.ivr_choice import IVRChoice
from accent_dao.alchemy.line_extension import LineExtension
from accent_dao.alchemy.linefeatures import LineFeatures
from accent_dao.alchemy.meeting import Meeting, MeetingOwner
from accent_dao.alchemy.meeting_authorization import MeetingAuthorization
from accent_dao.alchemy.moh import MOH
from accent_dao.alchemy.outcall import Outcall, OutcallTrunk
from accent_dao.alchemy.paging import Paging
from accent_dao.alchemy.paginguser import PagingUser
from accent_dao.alchemy.parking_lot import ParkingLot
from accent_dao.alchemy.phone_number import PhoneNumber
from accent_dao.alchemy.pickup import Pickup
from accent_dao.alchemy.pickupmember import PickupMember
from accent_dao.alchemy.pjsip_transport import PJSIPTransport
from accent_dao.alchemy.pjsip_transport_option import PJSIPTransportOption
from accent_dao.alchemy.queuemember import QueueMember
from accent_dao.alchemy.queueskill import QueueSkill
from accent_dao.alchemy.rightcall import RightCall
from accent_dao.alchemy.rightcallmember import RightCallMember
from accent_dao.alchemy.sccpline import SCCPLine
from accent_dao.alchemy.schedule import Schedule
from accent_dao.alchemy.schedule_time import ScheduleTime
from accent_dao.alchemy.schedulepath import SchedulePath
from accent_dao.alchemy.staticiax import StaticIAX
from accent_dao.alchemy.switchboard import Switchboard
from accent_dao.alchemy.switchboard_member_user import SwitchboardMemberUser
from accent_dao.alchemy.tenant import Tenant
from accent_dao.alchemy.trunkfeatures import TrunkFeatures
from accent_dao.alchemy.user_line import UserLine
from accent_dao.alchemy.usercustom import UserCustom
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.alchemy.useriax import UserIAX
from accent_dao.alchemy.voicemail import Voicemail

__all__ = [
    'AgentFeatures',
    'AgentQueueSkill',
    'Application',
    'ApplicationDestNode',
    'AsteriskFileSection',
    'AsteriskFileVariable',
    'Callfilter',
    'Callfiltermember',
    'Conference',
    'Context',
    'ContextInclude',
    'Dialaction',
    'EndpointSIP',
    'EndpointSIPTemplate',
    'EndpointSIPSection',
    'EndpointSIPSectionOption',
    'EndpointSIPOptionsView',
    'Extension',
    'FuncKeyDestAgent',
    'FuncKeyDestBSFilter',
    'FuncKeyDestConference',
    'FuncKeyDestGroup',
    'FuncKeyDestGroupMember',
    'FuncKeyDestPaging',
    'FuncKeyDestParkPosition',
    'FuncKeyDestParking',
    'FuncKeyDestQueue',
    'FuncKeyDestUser',
    'FuncKeyMapping',
    'GroupFeatures',
    'IngressHTTP',
    'IVR',
    'IVRChoice',
    'Incall',
    'LineExtension',
    'LineFeatures',
    'Meeting',
    'MeetingAuthorization',
    'MeetingOwner',
    'MOH',
    'Outcall',
    'OutcallTrunk',
    'Paging',
    'PagingUser',
    'ParkingLot',
    'PhoneNumber',
    'Pickup',
    'PickupMember',
    'PJSIPTransport',
    'PJSIPTransportOption',
    'QueueMember',
    'QueueSkill',
    'RightCall',
    'RightCallMember',
    'SCCPLine',
    'Schedule',
    'SchedulePath',
    'ScheduleTime',
    'StaticIAX',
    'Switchboard',
    'SwitchboardMemberUser',
    'Tenant',
    'TrunkFeatures',
    'UserCustom',
    'UserFeatures',
    'UserIAX',
    'UserLine',
    'Voicemail',
]
----------------------------------------

File: alchemy/accessfeatures.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.schema import CheckConstraint, Column, UniqueConstraint
from sqlalchemy.sql import cast, not_
from sqlalchemy.types import Boolean, Integer, String

from accent_dao.helpers.db_manager import Base


class AccessFeatures(Base):
    __tablename__ = 'accessfeatures'
    __table_args__ = (
        CheckConstraint('feature=\'phonebook\''),
        UniqueConstraint('host', 'feature'),
    )

    id = Column(Integer, primary_key=True)
    host = Column(String(255), nullable=False, server_default='')
    commented = Column(Integer, nullable=False, server_default='0')
    feature = Column(String(64), nullable=False, server_default='phonebook')

    @hybrid_property
    def enabled(self):
        return self.commented == 0

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False)

----------------------------------------

File: alchemy/agent_login_status.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint, UniqueConstraint
from sqlalchemy.types import Boolean, DateTime, Integer, String

from accent_dao.helpers.db_manager import Base


class AgentLoginStatus(Base):
    __tablename__ = 'agent_login_status'
    __table_args__ = (
        PrimaryKeyConstraint('agent_id'),
        UniqueConstraint('extension', 'context'),
        UniqueConstraint('interface'),
        Index('agent_login_status__idx__agent_id', 'agent_id'),
    )

    agent_id = Column(Integer, autoincrement=False)
    agent_number = Column(String(40), nullable=False)
    extension = Column(String(80), nullable=False)
    context = Column(String(79), nullable=False)
    interface = Column(String(128), nullable=False)
    state_interface = Column(String(128), nullable=False)
    paused = Column(Boolean, nullable=False, server_default='false')
    paused_reason = Column(String(80))
    login_at = Column(
        DateTime,
        nullable=False,
        server_default=text("(current_timestamp at time zone 'utc')"),
    )

    agent = relationship(
        'AgentFeatures',
        primaryjoin='AgentLoginStatus.agent_id == AgentFeatures.id',
        foreign_keys='AgentFeatures.id',
        uselist=False,
    )

----------------------------------------

File: alchemy/agent_membership_status.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class AgentMembershipStatus(Base):

    __tablename__ = 'agent_membership_status'
    __table_args__ = (
        PrimaryKeyConstraint('agent_id', 'queue_id'),
        Index('agent_membership_status__idx__agent_id', 'agent_id'),
        Index('agent_membership_status__idx__queue_id', 'queue_id'),
    )

    agent_id = Column(Integer, autoincrement=False)
    queue_id = Column(Integer, autoincrement=False)
    queue_name = Column(String(128), nullable=False)
    penalty = Column(Integer, nullable=False, server_default='0')

----------------------------------------

File: alchemy/agentfeatures.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index, UniqueConstraint
from sqlalchemy.types import Integer, String, Text

from accent_dao.helpers.db_manager import Base


class AgentFeatures(Base):
    __tablename__ = 'agentfeatures'
    __table_args__ = (
        UniqueConstraint('number', 'tenant_uuid'),
        Index('agentfeatures__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer, primary_key=True)
    tenant_uuid = Column(
        String(36), ForeignKey('tenant.uuid', ondelete='CASCADE'), nullable=False
    )
    firstname = Column(String(128))
    lastname = Column(String(128))
    number = Column(String(40), nullable=False)
    passwd = Column(String(128))
    context = Column(String(79))
    language = Column(String(20))
    autologoff = Column(Integer)
    group = Column(String(255))
    description = Column(Text)
    preprocess_subroutine = Column(String(79))

    func_keys = relationship('FuncKeyDestAgent', cascade='all, delete-orphan')

    queue_queue_members = relationship(
        'QueueMember',
        primaryjoin="""and_(QueueMember.category == 'queue',
                            QueueMember.usertype == 'agent',
                            QueueMember.userid == AgentFeatures.id)""",
        foreign_keys='QueueMember.userid',
        cascade='all, delete-orphan',
    )

    agent_queue_skills = relationship(
        'AgentQueueSkill',
        primaryjoin='AgentQueueSkill.agentid == AgentFeatures.id',
        foreign_keys='AgentQueueSkill.agentid',
        cascade='all, delete-orphan',
    )

    users = relationship(
        "UserFeatures",
        primaryjoin="AgentFeatures.id == UserFeatures.agentid",
        foreign_keys='UserFeatures.agentid',
        viewonly=True,
    )

----------------------------------------

File: alchemy/agentglobalparams.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class AgentGlobalParams(Base):

    __tablename__ = 'agentglobalparams'

    id = Column(Integer, primary_key=True)
    category = Column(String(128), nullable=False)
    option_name = Column(String(255), nullable=False)
    option_value = Column(String(255))

----------------------------------------

File: alchemy/agentqueueskill.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, PrimaryKeyConstraint
from sqlalchemy.types import Integer

from accent_dao.helpers.db_manager import Base


class AgentQueueSkill(Base):
    __tablename__ = 'agentqueueskill'
    __table_args__ = (PrimaryKeyConstraint('agentid', 'skillid'),)

    agentid = Column(Integer, nullable=False, autoincrement=False)
    skillid = Column(Integer, nullable=False, autoincrement=False)
    weight = Column(Integer, nullable=False, server_default='0')

    agent = relationship(
        'AgentFeatures',
        primaryjoin='AgentQueueSkill.agentid == AgentFeatures.id',
        foreign_keys='AgentQueueSkill.agentid',
    )

    skill = relationship(
        'QueueSkill',
        primaryjoin='AgentQueueSkill.skillid == QueueSkill.id',
        foreign_keys='AgentQueueSkill.skillid',
    )

----------------------------------------

File: alchemy/all/__init__.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.accessfeatures import AccessFeatures
from accent_dao.alchemy.agent_login_status import AgentLoginStatus
from accent_dao.alchemy.agent_membership_status import AgentMembershipStatus
from accent_dao.alchemy.agentfeatures import AgentFeatures
from accent_dao.alchemy.agentglobalparams import AgentGlobalParams
from accent_dao.alchemy.agentqueueskill import AgentQueueSkill
from accent_dao.alchemy.application import Application
from accent_dao.alchemy.application_dest_node import ApplicationDestNode
from accent_dao.alchemy.asterisk_file import AsteriskFile
from accent_dao.alchemy.asterisk_file_section import AsteriskFileSection
from accent_dao.alchemy.asterisk_file_variable import AsteriskFileVariable
from accent_dao.alchemy.callerid import Callerid
from accent_dao.alchemy.callfilter import Callfilter
from accent_dao.alchemy.callfiltermember import Callfiltermember
from accent_dao.alchemy.cel import CEL
from accent_dao.alchemy.conference import Conference
from accent_dao.alchemy.context import Context
from accent_dao.alchemy.contextinclude import ContextInclude
from accent_dao.alchemy.contextmember import ContextMember
from accent_dao.alchemy.contextnumbers import ContextNumbers
from accent_dao.alchemy.contexttype import ContextType
from accent_dao.alchemy.dhcp import Dhcp
from accent_dao.alchemy.dialaction import Dialaction
from accent_dao.alchemy.dialpattern import DialPattern
from accent_dao.alchemy.endpoint_sip import EndpointSIP, EndpointSIPTemplate
from accent_dao.alchemy.endpoint_sip_options_view import EndpointSIPOptionsView
from accent_dao.alchemy.endpoint_sip_section import EndpointSIPSection
from accent_dao.alchemy.endpoint_sip_section_option import EndpointSIPSectionOption
from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.external_app import ExternalApp
from accent_dao.alchemy.feature_extension import FeatureExtension
from accent_dao.alchemy.features import Features
from accent_dao.alchemy.func_key import FuncKey
from accent_dao.alchemy.func_key_dest_agent import FuncKeyDestAgent
from accent_dao.alchemy.func_key_dest_bsfilter import FuncKeyDestBSFilter
from accent_dao.alchemy.func_key_dest_conference import FuncKeyDestConference
from accent_dao.alchemy.func_key_dest_custom import FuncKeyDestCustom
from accent_dao.alchemy.func_key_dest_features import FuncKeyDestFeatures
from accent_dao.alchemy.func_key_dest_forward import FuncKeyDestForward
from accent_dao.alchemy.func_key_dest_group import FuncKeyDestGroup
from accent_dao.alchemy.func_key_dest_group_member import FuncKeyDestGroupMember
from accent_dao.alchemy.func_key_dest_paging import FuncKeyDestPaging
from accent_dao.alchemy.func_key_dest_park_position import FuncKeyDestParkPosition
from accent_dao.alchemy.func_key_dest_parking import FuncKeyDestParking
from accent_dao.alchemy.func_key_dest_queue import FuncKeyDestQueue
from accent_dao.alchemy.func_key_dest_service import FuncKeyDestService
from accent_dao.alchemy.func_key_dest_user import FuncKeyDestUser
from accent_dao.alchemy.func_key_destination_type import FuncKeyDestinationType
from accent_dao.alchemy.func_key_mapping import FuncKeyMapping
from accent_dao.alchemy.func_key_template import FuncKeyTemplate
from accent_dao.alchemy.func_key_type import FuncKeyType
from accent_dao.alchemy.groupfeatures import GroupFeatures
from accent_dao.alchemy.iaxcallnumberlimits import IAXCallNumberLimits
from accent_dao.alchemy.incall import Incall
from accent_dao.alchemy.infos import Infos
from accent_dao.alchemy.ingress_http import IngressHTTP
from accent_dao.alchemy.ivr import IVR
from accent_dao.alchemy.ivr_choice import IVRChoice
from accent_dao.alchemy.line_extension import LineExtension
from accent_dao.alchemy.linefeatures import LineFeatures
from accent_dao.alchemy.mail import Mail
from accent_dao.alchemy.meeting import Meeting, MeetingOwner
from accent_dao.alchemy.meeting_authorization import MeetingAuthorization
from accent_dao.alchemy.moh import MOH
from accent_dao.alchemy.netiface import Netiface
from accent_dao.alchemy.outcall import Outcall
from accent_dao.alchemy.outcalltrunk import OutcallTrunk
from accent_dao.alchemy.paging import Paging
from accent_dao.alchemy.paginguser import PagingUser
from accent_dao.alchemy.parking_lot import ParkingLot
from accent_dao.alchemy.phone_number import PhoneNumber
from accent_dao.alchemy.pickup import Pickup
from accent_dao.alchemy.pickupmember import PickupMember
from accent_dao.alchemy.pjsip_transport import PJSIPTransport
from accent_dao.alchemy.pjsip_transport_option import PJSIPTransportOption
from accent_dao.alchemy.provisioning import Provisioning
from accent_dao.alchemy.queue import Queue
from accent_dao.alchemy.queue_log import QueueLog
from accent_dao.alchemy.queuefeatures import QueueFeatures
from accent_dao.alchemy.queuemember import QueueMember
from accent_dao.alchemy.queueskill import QueueSkill
from accent_dao.alchemy.queueskillrule import QueueSkillRule
from accent_dao.alchemy.resolvconf import Resolvconf
from accent_dao.alchemy.rightcall import RightCall
from accent_dao.alchemy.rightcallexten import RightCallExten
from accent_dao.alchemy.rightcallmember import RightCallMember
from accent_dao.alchemy.sccpdevice import SCCPDevice
from accent_dao.alchemy.sccpgeneralsettings import SCCPGeneralSettings
from accent_dao.alchemy.sccpline import SCCPLine
from accent_dao.alchemy.schedule import Schedule
from accent_dao.alchemy.schedule_time import ScheduleTime
from accent_dao.alchemy.schedulepath import SchedulePath
from accent_dao.alchemy.session import Session
from accent_dao.alchemy.stat_agent import StatAgent
from accent_dao.alchemy.stat_agent_periodic import StatAgentPeriodic
from accent_dao.alchemy.stat_call_on_queue import StatCallOnQueue
from accent_dao.alchemy.stat_queue import StatQueue
from accent_dao.alchemy.stat_queue_periodic import StatQueuePeriodic
from accent_dao.alchemy.stat_switchboard_queue import StatSwitchboardQueue
from accent_dao.alchemy.staticiax import StaticIAX
from accent_dao.alchemy.staticqueue import StaticQueue
from accent_dao.alchemy.staticvoicemail import StaticVoicemail
from accent_dao.alchemy.stats_conf import StatsConf
from accent_dao.alchemy.stats_conf_accentuser import StatsConfAccentUser
from accent_dao.alchemy.stats_conf_agent import StatsConfAgent
from accent_dao.alchemy.stats_conf_queue import StatsConfQueue
from accent_dao.alchemy.switchboard import Switchboard
from accent_dao.alchemy.switchboard_member_user import SwitchboardMemberUser
from accent_dao.alchemy.tenant import Tenant
from accent_dao.alchemy.trunkfeatures import TrunkFeatures
from accent_dao.alchemy.user_external_app import UserExternalApp
from accent_dao.alchemy.user_line import UserLine
from accent_dao.alchemy.usercustom import UserCustom
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.alchemy.useriax import UserIAX
from accent_dao.alchemy.voicemail import Voicemail

__all__ = [
    "AccessFeatures",
    "AgentLoginStatus",
    "AgentMembershipStatus",
    "AgentFeatures",
    "AgentGlobalParams",
    "AgentQueueSkill",
    "Application",
    "ApplicationDestNode",
    "AsteriskFile",
    "AsteriskFileSection",
    "AsteriskFileVariable",
    "Callerid",
    "Callfilter",
    "Callfiltermember",
    "CEL",
    "Conference",
    "Context",
    "ContextInclude",
    "ContextMember",
    "ContextNumbers",
    "ContextType",
    "Dhcp",
    "Dialaction",
    "DialPattern",
    "EndpointSIP",
    "EndpointSIPSection",
    "EndpointSIPSectionOption",
    "EndpointSIPOptionsView",
    "EndpointSIPTemplate",
    "Extension",
    "ExternalApp",
    "Features",
    "FeatureExtension",
    "FuncKey",
    "FuncKeyDestAgent",
    "FuncKeyDestBSFilter",
    "FuncKeyDestConference",
    "FuncKeyDestCustom",
    "FuncKeyDestFeatures",
    "FuncKeyDestForward",
    "FuncKeyDestGroup",
    "FuncKeyDestGroupMember",
    "FuncKeyDestPaging",
    "FuncKeyDestParkPosition",
    "FuncKeyDestParking",
    "FuncKeyDestQueue",
    "FuncKeyDestService",
    "FuncKeyDestUser",
    "FuncKeyDestinationType",
    "FuncKeyMapping",
    "FuncKeyTemplate",
    "FuncKeyType",
    "GroupFeatures",
    "IAXCallNumberLimits",
    "Incall",
    "Infos",
    "IngressHTTP",
    "IVR",
    "IVRChoice",
    "LineExtension",
    "LineFeatures",
    "Mail",
    "Meeting",
    "MeetingAuthorization",
    "MeetingOwner",
    "MOH",
    "Netiface",
    "Outcall",
    "OutcallTrunk",
    "Paging",
    "PagingUser",
    "ParkingLot",
    "PhoneNumber",
    "Pickup",
    "PickupMember",
    "PJSIPTransport",
    "PJSIPTransportOption",
    "Provisioning",
    "Queue",
    "QueueLog",
    "QueueFeatures",
    "QueueMember",
    "QueueSkill",
    "QueueSkillRule",
    "Resolvconf",
    "RightCall",
    "RightCallExten",
    "RightCallMember",
    "SCCPDevice",
    "SCCPGeneralSettings",
    "SCCPLine",
    "Schedule",
    "ScheduleTime",
    "SchedulePath",
    "Session",
    "StatAgent",
    "StatAgentPeriodic",
    "StatCallOnQueue",
    "StatQueue",
    "StatQueuePeriodic",
    "StatSwitchboardQueue",
    "StaticIAX",
    "StaticQueue",
    "StaticVoicemail",
    "StatsConf",
    "StatsConfAgent",
    "StatsConfQueue",
    "StatsConfAccentUser",
    "Switchboard",
    "SwitchboardMemberUser",
    "Tenant",
    "TrunkFeatures",
    "UserExternalApp",
    "UserLine",
    "UserCustom",
    "UserFeatures",
    "UserIAX",
    "Voicemail",
]

----------------------------------------

File: alchemy/application.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    ForeignKey,
    Index,
)
from sqlalchemy.types import String

from accent_dao.helpers.db_manager import Base, UUIDAsString


class Application(Base):
    __tablename__ = 'application'
    __table_args__ = (Index('application__idx__tenant_uuid', 'tenant_uuid'),)

    uuid = Column(
        UUIDAsString(36), primary_key=True, server_default=text('uuid_generate_v4()')
    )
    tenant_uuid = Column(
        String(36), ForeignKey('tenant.uuid', ondelete='CASCADE'), nullable=False
    )
    name = Column(String(128))

    dest_node = relationship(
        'ApplicationDestNode',
        cascade='all, delete-orphan',
        passive_deletes=True,
        uselist=False,
    )

    lines = relationship('LineFeatures', viewonly=True)

    _dialaction_actions = relationship(
        'Dialaction',
        primaryjoin="""and_(
            Dialaction.action == 'application:custom',
            Dialaction.actionarg1 == Application.uuid
        )""",
        foreign_keys='Dialaction.actionarg1',
        cascade='all, delete-orphan',
    )

----------------------------------------

File: alchemy/application_dest_node.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
)
from sqlalchemy.types import Boolean, String

from accent_dao.helpers.db_manager import Base


class ApplicationDestNode(Base):

    __tablename__ = 'application_dest_node'

    application_uuid = Column(
        String(36),
        ForeignKey('application.uuid', ondelete='CASCADE'),
        primary_key=True,
    )
    type_ = Column(
        'type',
        String(32),
        CheckConstraint("type in ('holding', 'mixing')"),
        nullable=False,
    )
    music_on_hold = Column(String(128))
    answer = Column(Boolean, nullable=False, default=False)

----------------------------------------

File: alchemy/asterisk_file.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.orm.collections import attribute_mapped_collection
from sqlalchemy.schema import Column
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class AsteriskFile(Base):
    __tablename__ = 'asterisk_file'

    id = Column(Integer, primary_key=True)
    name = Column(String(255), unique=True, nullable=False)

    sections_ordered = relationship(
        'AsteriskFileSection', order_by='AsteriskFileSection.priority', viewonly=True
    )

    sections = relationship(
        'AsteriskFileSection',
        collection_class=attribute_mapped_collection('name'),
        cascade='all, delete-orphan',
        passive_deletes=True,
    )

----------------------------------------

File: alchemy/asterisk_file_section.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index, UniqueConstraint
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class AsteriskFileSection(Base):
    __tablename__ = 'asterisk_file_section'
    __table_args__ = (
        UniqueConstraint('name', 'asterisk_file_id'),
        Index('asterisk_file_section__idx__asterisk_file_id', 'asterisk_file_id'),
    )

    id = Column(Integer, primary_key=True)
    name = Column(String(255), nullable=False)
    priority = Column(Integer)
    asterisk_file_id = Column(
        Integer,
        ForeignKey('asterisk_file.id', ondelete='CASCADE'),
        nullable=False,
    )

    variables = relationship(
        'AsteriskFileVariable',
        order_by='AsteriskFileVariable.priority',
        cascade='all, delete-orphan',
        passive_deletes=True,
    )

----------------------------------------

File: alchemy/asterisk_file_variable.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, ForeignKey, Index
from sqlalchemy.types import Integer, String, Text

from accent_dao.helpers.db_manager import Base


class AsteriskFileVariable(Base):
    __tablename__ = 'asterisk_file_variable'
    __table_args__ = (
        Index('asterisk_file_variable__idx__asterisk_file_section_id', 'asterisk_file_section_id'),
    )

    id = Column(Integer, primary_key=True)
    key = Column(String(255), nullable=False)
    value = Column(Text)
    priority = Column(Integer)
    asterisk_file_section_id = Column(
        Integer,
        ForeignKey('asterisk_file_section.id', ondelete='CASCADE'),
        nullable=False,
    )

----------------------------------------

File: alchemy/callerid.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.schema import Column, PrimaryKeyConstraint
from sqlalchemy.types import Enum, Integer, String

from accent_dao.helpers.db_manager import Base


class Callerid(Base):
    __tablename__ = 'callerid'
    __table_args__ = (PrimaryKeyConstraint('type', 'typeval'),)

    mode = Column(
        Enum(
            'prepend',
            'overwrite',
            'append',
            name='callerid_mode',
            metadata=Base.metadata,
        )
    )
    callerdisplay = Column(String(80), nullable=False, server_default='')
    type = Column(
        Enum(
            'callfilter',
            'incall',
            'group',
            'queue',
            name='callerid_type',
            metadata=Base.metadata,
        )
    )
    typeval = Column(Integer, nullable=False, autoincrement=False)

    @hybrid_property
    def name(self):
        if self.callerdisplay == '':
            return None
        return self.callerdisplay

    @name.setter
    def name(self, value):
        if value is None:
            self.callerdisplay = ''
        else:
            self.callerdisplay = value

----------------------------------------

File: alchemy/callfilter.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.ext.orderinglist import ordering_list
from sqlalchemy.orm import column_property, relationship
from sqlalchemy.orm.collections import attribute_mapped_collection
from sqlalchemy.schema import Column, ForeignKey, Index, PrimaryKeyConstraint, UniqueConstraint
from sqlalchemy.sql import and_, cast, not_, select
from sqlalchemy.sql.expression import true
from sqlalchemy.types import Boolean, Integer, String, Text

from accent_dao.alchemy.feature_extension import FeatureExtension
from accent_dao.helpers.db_manager import Base

from . import enum
from .callerid import Callerid


class Callfilter(Base):
    __tablename__ = 'callfilter'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('name'),
        Index('callfilter__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer, nullable=False)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(128), nullable=False, server_default='')
    type = Column(enum.callfilter_type, nullable=False)
    bosssecretary = Column(enum.callfilter_bosssecretary)
    callfrom = Column(enum.callfilter_callfrom)
    ringseconds = Column(Integer, nullable=False, server_default='0')
    commented = Column(Integer, nullable=False, server_default='0')
    description = Column(Text)

    exten = column_property(
        select([FeatureExtension.exten])
        .where(
            and_(
                FeatureExtension.feature == 'bsfilter',
                FeatureExtension.enabled == true(),
            )
        )
        .correlate_except(FeatureExtension)
        .as_scalar()
    )

    callfilter_dialactions = relationship(
        'Dialaction',
        primaryjoin="""and_(
            Dialaction.category == 'callfilter',
            Dialaction.categoryval == cast(Callfilter.id, String
        ))""",
        cascade='all, delete-orphan',
        collection_class=attribute_mapped_collection('event'),
        foreign_keys='Dialaction.categoryval',
    )

    caller_id = relationship(
        'Callerid',
        primaryjoin="""and_(
            Callerid.type == 'callfilter',
            Callerid.typeval == Callfilter.id
        )""",
        foreign_keys='Callerid.typeval',
        cascade='all, delete-orphan',
        uselist=False,
    )

    caller_id_mode = association_proxy(
        'caller_id',
        'mode',
        creator=lambda _mode: Callerid(type='callfilter', mode=_mode),
    )
    caller_id_name = association_proxy(
        'caller_id',
        'name',
        creator=lambda _name: Callerid(type='callfilter', name=_name),
    )

    recipients = relationship(
        'Callfiltermember',
        primaryjoin="""and_(
            Callfiltermember.bstype == 'boss',
            Callfiltermember.callfilterid == Callfilter.id
        )""",
        foreign_keys='Callfiltermember.callfilterid',
        order_by='Callfiltermember.priority',
        collection_class=ordering_list('priority', reorder_on_append=True),
        cascade='all, delete-orphan',
    )

    surrogates = relationship(
        'Callfiltermember',
        primaryjoin="""and_(
            Callfiltermember.bstype == 'secretary',
            Callfiltermember.callfilterid == Callfilter.id
        )""",
        foreign_keys='Callfiltermember.callfilterid',
        order_by='Callfiltermember.priority',
        collection_class=ordering_list('priority', reorder_on_append=True),
        cascade='all, delete-orphan',
    )

    @property
    def fallbacks(self):
        return self.callfilter_dialactions

    @hybrid_property
    def strategy(self):
        if self.bosssecretary == 'bossfirst-serial':
            return 'all-recipients-then-linear-surrogates'
        elif self.bosssecretary == 'bossfirst-simult':
            return 'all-recipients-then-all-surrogates'
        elif self.bosssecretary == 'secretary-serial':
            return 'linear-surrogates-then-all-recipients'
        elif self.bosssecretary == 'secretary-simult':
            return 'all-surrogates-then-all-recipients'
        else:
            return self.bosssecretary

    @strategy.setter
    def strategy(self, value):
        if value == 'all-recipients-then-linear-surrogates':
            self.bosssecretary = 'bossfirst-serial'
        elif value == 'all-recipients-then-all-surrogates':
            self.bosssecretary = 'bossfirst-simult'
        elif value == 'linear-surrogates-then-all-recipients':
            self.bosssecretary = 'secretary-serial'
        elif value == 'all-surrogates-then-all-recipients':
            self.bosssecretary = 'secretary-simult'
        else:
            self.bosssecretary = value

    @hybrid_property
    def surrogates_timeout(self):
        if self.ringseconds == 0:
            return None
        return self.ringseconds

    @surrogates_timeout.setter
    def surrogates_timeout(self, value):
        if value is None:
            self.ringseconds = 0
        else:
            self.ringseconds = value

    @hybrid_property
    def enabled(self):
        if self.commented is None:
            return None
        return self.commented == 0

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False)

----------------------------------------

File: alchemy/callfiltermember.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import column_property, relationship
from sqlalchemy.schema import CheckConstraint, Column, UniqueConstraint
from sqlalchemy.sql.elements import and_
from sqlalchemy.sql.expression import select
from sqlalchemy.types import Enum, Integer, String

from accent_dao.alchemy import enum
from accent_dao.alchemy.callfilter import Callfilter
from accent_dao.helpers.db_manager import Base


class Callfiltermember(Base):
    __tablename__ = 'callfiltermember'
    __table_args__ = (
        UniqueConstraint('callfilterid', 'type', 'typeval'),
        CheckConstraint("bstype in ('boss', 'secretary')"),
    )

    id = Column(Integer, primary_key=True)
    callfilterid = Column(Integer, nullable=False, server_default='0')
    type = Column(
        Enum('user', name='callfiltermember_type', metadata=Base.metadata),
        nullable=False,
    )
    typeval = Column(String(128), nullable=False, server_default='0')
    ringseconds = Column(Integer, nullable=False, server_default='0')
    priority = Column(Integer, nullable=False, server_default='0')
    bstype = Column(enum.generic_bsfilter, nullable=False)
    active = Column(Integer, nullable=False, server_default='0')

    callfilter_exten = column_property(
        select([Callfilter.exten])
        .where(and_(Callfilter.id == callfilterid, bstype == 'secretary'))
        .correlate_except(Callfilter)
        .as_scalar()
    )

    func_keys = relationship('FuncKeyDestBSFilter', cascade='all, delete-orphan')

    user = relationship(
        'UserFeatures',
        primaryjoin="""and_(Callfiltermember.type == 'user',
                            Callfiltermember.typeval == cast(UserFeatures.id, String))""",
        foreign_keys='Callfiltermember.typeval',
    )

    @hybrid_property
    def timeout(self):
        if self.ringseconds == 0:
            return None
        return self.ringseconds

    @timeout.setter
    def timeout(self, value):
        if value is None:
            self.ringseconds = 0
        else:
            self.ringseconds = value

----------------------------------------

File: alchemy/cel.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, Index
from sqlalchemy.types import DateTime, Integer, Text, UnicodeText

from accent_dao.helpers.db_manager import Base


class CEL(Base):
    __tablename__ = 'cel'
    __table_args__ = (
        Index('cel__idx__call_log_id', 'call_log_id'),
        Index('cel__idx__eventtime', 'eventtime'),
        Index('cel__idx__linkedid', 'linkedid'),
        Index('cel__idx__uniqueid', 'uniqueid'),
    )

    id = Column(Integer, primary_key=True, nullable=False)
    eventtype = Column(Text, nullable=False)
    eventtime = Column(DateTime(timezone=True), nullable=False)
    userdeftype = Column(Text, nullable=False)
    cid_name = Column(UnicodeText, nullable=False)
    cid_num = Column(UnicodeText, nullable=False)
    cid_ani = Column(Text, nullable=False)
    cid_rdnis = Column(Text, nullable=False)
    cid_dnid = Column(Text, nullable=False)
    exten = Column(UnicodeText, nullable=False)
    context = Column(Text, nullable=False)
    channame = Column(UnicodeText, nullable=False)
    appname = Column(Text, nullable=False)
    appdata = Column(Text, nullable=False)
    amaflags = Column(Integer, nullable=False)
    accountcode = Column(Text, nullable=False)
    peeraccount = Column(Text, nullable=False)
    uniqueid = Column(Text, nullable=False)
    linkedid = Column(Text, nullable=False)
    userfield = Column(Text, nullable=False)
    peer = Column(Text, nullable=False)
    extra = Column(Text)
    call_log_id = Column(Integer)

----------------------------------------

File: alchemy/conference.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
)
from sqlalchemy.sql import (
    cast,
    select,
)
from sqlalchemy.types import (
    Boolean,
    Integer,
    String,
)

from accent_dao.helpers.db_manager import Base

from .extension import Extension


class Conference(Base):
    __tablename__ = 'conference'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('conference__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(128))
    preprocess_subroutine = Column(String(79))

    max_users = Column(Integer, nullable=False, server_default='50')
    record = Column(Boolean, nullable=False, server_default='False')

    pin = Column(String(80))
    quiet_join_leave = Column(Boolean, nullable=False, server_default='False')
    announce_join_leave = Column(Boolean, nullable=False, server_default='False')
    announce_user_count = Column(Boolean, nullable=False, server_default='False')
    announce_only_user = Column(Boolean, nullable=False, server_default='True')
    music_on_hold = Column(String(128))

    admin_pin = Column(String(80))

    extensions = relationship(
        'Extension',
        primaryjoin="""and_(Extension.type == 'conference',
                            Extension.typeval == cast(Conference.id, String))""",
        foreign_keys='Extension.typeval',
        viewonly=True,
    )

    incall_dialactions = relationship(
        'Dialaction',
        primaryjoin="""and_(Dialaction.category == 'incall',
                            Dialaction.action == 'conference',
                            Dialaction.actionarg1 == cast(Conference.id, String))""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )

    incalls = association_proxy('incall_dialactions', 'incall')

    _dialaction_actions = relationship(
        'Dialaction',
        primaryjoin="""and_(Dialaction.action == 'conference',
                            Dialaction.actionarg1 == cast(Conference.id, String))""",
        foreign_keys='Dialaction.actionarg1',
        cascade='all, delete-orphan',
    )

    func_keys_conference = relationship(
        'FuncKeyDestConference',
        cascade='all, delete-orphan',
    )

    @hybrid_property
    def exten(self):
        for extension in self.extensions:
            return extension.exten
        return None

    @exten.expression
    def exten(cls):
        return (
            select([Extension.exten])
            .where(Extension.type == 'conference')
            .where(Extension.typeval == cast(cls.id, String))
            .as_scalar()
        )

----------------------------------------

File: alchemy/context.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.ext.orderinglist import ordering_list
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    ForeignKeyConstraint,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import cast, not_, text
from sqlalchemy.types import Boolean, Integer, String, Text

from accent_dao.alchemy.contextnumbers import ContextNumbers
from accent_dao.helpers.db_manager import Base

from .contextinclude import ContextInclude


class Context(Base):
    __tablename__ = 'context'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('name'),
        UniqueConstraint('uuid'),
        ForeignKeyConstraint(
            ('tenant_uuid',),
            ('tenant.uuid',),
            ondelete='CASCADE',
        ),
        Index('context__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer)
    uuid = Column(UUID(as_uuid=True), server_default=text('uuid_generate_v4()'))
    tenant_uuid = Column(String(36), nullable=False)
    name = Column(String(79), nullable=False)
    displayname = Column(String(128))
    contexttype = Column(String(40), nullable=False, server_default='internal')
    commented = Column(Integer, nullable=False, server_default='0')
    description = Column(Text)

    context_numbers_user = relationship(
        ContextNumbers,
        primaryjoin="""and_(
            ContextNumbers.type == 'user',
            ContextNumbers.context == Context.name)""",
        foreign_keys='ContextNumbers.context',
        cascade='all, delete-orphan',
    )

    context_numbers_group = relationship(
        ContextNumbers,
        primaryjoin="""and_(
            ContextNumbers.type == 'group',
            ContextNumbers.context == Context.name)""",
        foreign_keys='ContextNumbers.context',
        cascade='all, delete-orphan',
    )

    context_numbers_queue = relationship(
        ContextNumbers,
        primaryjoin="""and_(
            ContextNumbers.type == 'queue',
            ContextNumbers.context == Context.name)""",
        foreign_keys='ContextNumbers.context',
        cascade='all, delete-orphan',
    )

    context_numbers_meetme = relationship(
        ContextNumbers,
        primaryjoin="""and_(
            ContextNumbers.type == 'meetme',
            ContextNumbers.context == Context.name)""",
        foreign_keys='ContextNumbers.context',
        cascade='all, delete-orphan',
    )

    context_numbers_incall = relationship(
        ContextNumbers,
        primaryjoin="""and_(
            ContextNumbers.type == 'incall',
            ContextNumbers.context == Context.name)""",
        foreign_keys='ContextNumbers.context',
        cascade='all, delete-orphan',
    )

    context_includes_children = relationship(
        'ContextInclude',
        primaryjoin='ContextInclude.include == Context.name',
        foreign_keys='ContextInclude.include',
        cascade='all, delete-orphan',
    )

    context_include_parents = relationship(
        'ContextInclude',
        primaryjoin='ContextInclude.context == Context.name',
        foreign_keys='ContextInclude.context',
        order_by='ContextInclude.priority',
        collection_class=ordering_list('priority', reorder_on_append=True),
        cascade='all, delete-orphan',
    )

    contexts = association_proxy(
        'context_include_parents',
        'included_context',
        creator=lambda _context: ContextInclude(included_context=_context),
    )

    tenant = relationship('Tenant', viewonly=True)

    @hybrid_property
    def label(self):
        return self.displayname

    @label.setter
    def label(self, value):
        self.displayname = value

    @hybrid_property
    def type(self):
        return self.contexttype

    @type.setter
    def type(self, value):
        self.contexttype = value

    @hybrid_property
    def enabled(self):
        return self.commented == 0

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False)

    @hybrid_property
    def user_ranges(self):
        return self.context_numbers_user

    @user_ranges.setter
    def user_ranges(self, user_ranges):
        for user_range in user_ranges:
            user_range.type = 'user'
        self.context_numbers_user = user_ranges

    @hybrid_property
    def group_ranges(self):
        return self.context_numbers_group

    @group_ranges.setter
    def group_ranges(self, group_ranges):
        for group_range in group_ranges:
            group_range.type = 'group'
        self.context_numbers_group = group_ranges

    @hybrid_property
    def queue_ranges(self):
        return self.context_numbers_queue

    @queue_ranges.setter
    def queue_ranges(self, queue_ranges):
        for queue_range in queue_ranges:
            queue_range.type = 'queue'
        self.context_numbers_queue = queue_ranges

    @hybrid_property
    def conference_room_ranges(self):
        return self.context_numbers_meetme

    @conference_room_ranges.setter
    def conference_room_ranges(self, conference_room_ranges):
        for conference_room_range in conference_room_ranges:
            conference_room_range.type = 'meetme'
        self.context_numbers_meetme = conference_room_ranges

    @hybrid_property
    def incall_ranges(self):
        return self.context_numbers_incall

    @incall_ranges.setter
    def incall_ranges(self, incall_ranges):
        for incall_range in incall_ranges:
            incall_range.type = 'incall'
        self.context_numbers_incall = incall_ranges

----------------------------------------

File: alchemy/contextinclude.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import ForeignKeyConstraint
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class ContextInclude(Base):

    __tablename__ = 'contextinclude'
    __table_args__ = (
        ForeignKeyConstraint(
            ('context',),
            ('context.name',),
            ondelete='CASCADE',
        ),
    )

    context = Column(String(79), primary_key=True)
    include = Column(String(79), primary_key=True)
    priority = Column(Integer, nullable=False, server_default='0')

    included_context = relationship(
        'Context',
        primaryjoin='Context.name == ContextInclude.include',
        foreign_keys='ContextInclude.include',
        uselist=False,
    )

----------------------------------------

File: alchemy/contextmember.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import ForeignKeyConstraint
from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.types import String

from accent_dao.helpers.db_manager import Base


class ContextMember(Base):

    __tablename__ = 'contextmember'
    __table_args__ = (
        PrimaryKeyConstraint('context', 'type', 'typeval', 'varname'),
        Index('contextmember__idx__context', 'context'),
        Index('contextmember__idx__context_type', 'context', 'type'),
        ForeignKeyConstraint(
            ('context',),
            ('context.name',),
            ondelete='CASCADE',
        ),
    )

    context = Column(String(79))
    type = Column(String(32))
    typeval = Column(String(128), server_default='')
    varname = Column(String(128), server_default='')

----------------------------------------

File: alchemy/contextnumbers.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import ForeignKeyConstraint
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.schema import Column
from sqlalchemy.sql import case
from sqlalchemy.types import Enum, Integer, String

from accent_dao.helpers.db_manager import Base


class ContextNumbers(Base):

    __tablename__ = 'contextnumbers'
    __table_args__ = (
        ForeignKeyConstraint(
            ('context',),
            ('context.name',),
            ondelete='CASCADE',
        ),
    )

    context = Column(String(79), primary_key=True)
    type = Column(Enum('user', 'group', 'queue', 'meetme', 'incall',
                       name='contextnumbers_type',
                       metadata=Base.metadata),
                  primary_key=True)
    numberbeg = Column(String(16), server_default='', primary_key=True)
    numberend = Column(String(16), server_default='', primary_key=True)
    didlength = Column(Integer, nullable=False, server_default='0')

    @hybrid_property
    def start(self):
        return self.numberbeg

    @start.setter
    def start(self, value):
        self.numberbeg = value

    @hybrid_property
    def end(self):
        if self.numberend == '':
            return self.numberbeg
        return self.numberend

    @end.expression
    def end(cls):
        return case([(cls.numberend == '', cls.numberbeg)], else_=cls.numberend)

    @end.setter
    def end(self, value):
        self.numberend = value

    @hybrid_property
    def did_length(self):
        return self.didlength

    @did_length.setter
    def did_length(self, value):
        self.didlength = value

    def in_range(self, exten):
        exten = int(exten)
        start = self._convert_limit(self.start)
        end = self._convert_limit(self.end)

        if start == end and exten == start:
            return True
        elif start <= exten <= end:
            return True
        return False

    def _convert_limit(self, limit):
        return int(limit[-self.did_length:])

----------------------------------------

File: alchemy/contexttype.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, PrimaryKeyConstraint, UniqueConstraint
from sqlalchemy.types import Integer, String, Text

from accent_dao.helpers.db_manager import Base


class ContextType(Base):

    __tablename__ = 'contexttype'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('name'),
    )

    id = Column(Integer)
    name = Column(String(40), nullable=False)
    commented = Column(Integer)
    deletable = Column(Integer)
    description = Column(Text)

----------------------------------------

File: alchemy/dhcp.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class Dhcp(Base):

    __tablename__ = 'dhcp'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
    )

    id = Column(Integer, nullable=False)
    active = Column(Integer, nullable=False, server_default='0')
    pool_start = Column(String(64), nullable=False, server_default='')
    pool_end = Column(String(64), nullable=False, server_default='')
    network_interfaces = Column(String(255), nullable=False, server_default='')

----------------------------------------

File: alchemy/dialaction.py
Please review for update

# Copyright 2023 Accent Communications

from accent import dialaction
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.sql import func
from sqlalchemy.types import String

from accent_dao.alchemy import enum
from accent_dao.helpers.db_manager import Base, IntAsString


class Dialaction(Base):
    USER_EVENTS = ('noanswer', 'busy', 'congestion', 'chanunavail')

    __tablename__ = 'dialaction'
    __table_args__ = (
        PrimaryKeyConstraint('event', 'category', 'categoryval'),
        Index('dialaction__idx__action_actionarg1', 'action', 'actionarg1'),
        Index('dialaction__idx__categoryval', 'categoryval'),
    )

    # Remove the following warning:
    #   SAWarning: DELETE statement on table 'dialaction' expected to delete 2 row(s); 1 were matched.
    #   Please set confirm_deleted_rows=False within the mapper configuration to prevent this warning.
    # When child try to delete parent and the parent try delete child,
    # then the same row expecte to be removed twice.
    # This is the case of ivr_choice
    __mapper_args__ = {'confirm_deleted_rows': False}

    event = Column(String(40))
    category = Column(enum.dialaction_category)
    categoryval = Column(IntAsString(128), server_default='')
    action = Column(enum.dialaction_action, nullable=False)
    actionarg1 = Column(IntAsString(255))
    actionarg2 = Column(String(255))

    conference = relationship(
        'Conference',
        primaryjoin="""and_(
            Dialaction.action == 'conference',
            Dialaction.actionarg1 == cast(Conference.id, String)
        )""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )

    group = relationship(
        'GroupFeatures',
        primaryjoin="""and_(
            Dialaction.action == 'group',
            Dialaction.actionarg1 == cast(GroupFeatures.id, String)
        )""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )

    user = relationship(
        'UserFeatures',
        primaryjoin="""and_(
            Dialaction.action == 'user',
            Dialaction.actionarg1 == cast(UserFeatures.id, String)
        )""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )

    ivr = relationship(
        'IVR',
        primaryjoin="""and_(
            Dialaction.action == 'ivr',
            Dialaction.actionarg1 == cast(IVR.id, String)
        )""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )

    ivr_choice = relationship(
        'IVRChoice',
        primaryjoin="""and_(
            Dialaction.category == 'ivr_choice',
            Dialaction.categoryval == cast(IVRChoice.id, String)
        )""",
        foreign_keys='Dialaction.categoryval',
        cascade='delete',
        back_populates='dialaction',
    )

    switchboard = relationship(
        'Switchboard',
        primaryjoin="""and_(
            Dialaction.action == 'switchboard',
            Dialaction.actionarg1 == Switchboard.uuid
        )""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )

    voicemail = relationship(
        'Voicemail',
        primaryjoin="""and_(
            Dialaction.action == 'voicemail',
            Dialaction.actionarg1 == cast(Voicemail.id, String)
        )""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )

    incall = relationship(
        'Incall',
        primaryjoin="""and_(
            Dialaction.category == 'incall',
            Dialaction.categoryval == cast(Incall.id, String)
        )""",
        foreign_keys='Dialaction.categoryval',
        viewonly=True,
    )

    application = relationship(
        'Application',
        primaryjoin="""and_(
            Dialaction.action == 'application:custom',
            Dialaction.actionarg1 == Application.uuid
        )""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )

    queue = relationship(
        'QueueFeatures',
        primaryjoin="""and_(
            Dialaction.action == 'queue',
            Dialaction.actionarg1 == cast(QueueFeatures.id, String)
        )""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )

    @classmethod
    def new_user_actions(cls, user):
        for event in cls.USER_EVENTS:
            yield cls(
                event=event,
                category='user',
                categoryval=str(user.id),
                action='none',
                actionarg1=None,
                actionarg2=None,
            )

    @hybrid_property
    def type(self):
        return dialaction.action_type(self.action)

    @type.expression
    def type(cls):
        return func.split_part(cls.action, ':', 1)

    @type.setter
    def type(self, value):
        self.action = dialaction.action(type_=value, subtype=self.subtype)

    @hybrid_property
    def subtype(self):
        return dialaction.action_subtype(self.action)

    @subtype.expression
    def subtype(cls):
        return func.split_part(cls.action, ':', 2)

    @subtype.setter
    def subtype(self, value):
        self.action = dialaction.action(type_=self.type, subtype=value)

    @property
    def gosub_args(self):
        return ','.join(
            item or '' for item in (self.action, self.actionarg1, self.actionarg2)
        )

----------------------------------------

File: alchemy/dialpattern.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class DialPattern(Base):
    __tablename__ = 'dialpattern'
    __table_args__ = (PrimaryKeyConstraint('id'),)

    id = Column(Integer)
    type = Column(String(32), nullable=False)
    typeid = Column(Integer, nullable=False)
    externprefix = Column(String(64))
    prefix = Column(String(32))
    exten = Column(String(40), nullable=False)
    stripnum = Column(Integer)
    callerid = Column(String(80))

    extension = relationship(
        'Extension',
        primaryjoin="""and_(Extension.type == 'outcall',
                            Extension.typeval == cast(DialPattern.id, String))""",
        foreign_keys='Extension.typeval',
        uselist=False,
        passive_deletes='all',
    )

    outcall = relationship(
        'Outcall',
        primaryjoin="""and_(DialPattern.type == 'outcall',
                            DialPattern.typeid == Outcall.id)""",
        foreign_keys='DialPattern.typeid',
        uselist=False,
    )

    @hybrid_property
    def external_prefix(self):
        return self.externprefix

    @external_prefix.setter
    def external_prefix(self, value):
        self.externprefix = value

    @hybrid_property
    def strip_digits(self):
        return self.stripnum

    @strip_digits.setter
    def strip_digits(self, value):
        if value is None:
            value = 0  # set default value
        self.stripnum = value

    @hybrid_property
    def caller_id(self):
        return self.callerid

    @caller_id.setter
    def caller_id(self, value):
        self.callerid = value

----------------------------------------

File: alchemy/endpoint_sip.py
Please review for update

# Copyright 2023 Accent Communications

import logging

from sqlalchemy import and_, text, select, column, table
from sqlalchemy.orm import column_property, relationship
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.ext.orderinglist import ordering_list
from sqlalchemy.schema import Column, UniqueConstraint, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.types import (
    Boolean,
    Integer,
    String,
    Text,
)

from accent_dao.helpers.db_manager import Base

from .endpoint_sip_section import (
    AORSection,
    AuthSection,
    EndpointSection,
    IdentifySection,
    OutboundAuthSection,
    RegistrationSection,
    RegistrationOutboundAuthSection,
    EndpointSIPSection,
)
from .endpoint_sip_section_option import EndpointSIPSectionOption


logger = logging.getLogger(__name__)


class EndpointSIPTemplate(Base):

    __tablename__ = 'endpoint_sip_template'

    child_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey('endpoint_sip.uuid', ondelete='CASCADE'),
        primary_key=True,
    )
    parent_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey('endpoint_sip.uuid', ondelete='CASCADE'),
        primary_key=True,
    )
    priority = Column(Integer)

    parent = relationship('EndpointSIP', foreign_keys='EndpointSIPTemplate.parent_uuid')


class EndpointSIP(Base):

    __tablename__ = 'endpoint_sip'
    __table_args__ = (UniqueConstraint('name'),)

    uuid = Column(UUID(as_uuid=True), server_default=text('uuid_generate_v4()'), primary_key=True)
    label = Column(Text)
    name = Column(Text, nullable=False)
    asterisk_id = Column(Text)
    tenant_uuid = Column(String(36), ForeignKey('tenant.uuid', ondelete='CASCADE'), nullable=False)
    transport_uuid = Column(UUID(as_uuid=True), ForeignKey('pjsip_transport.uuid'))
    template = Column(Boolean, server_default=text('false'))

    transport = relationship('PJSIPTransport')
    template_relations = relationship(
        'EndpointSIPTemplate',
        primaryjoin='EndpointSIP.uuid == EndpointSIPTemplate.child_uuid',
        cascade='all, delete-orphan',
        order_by='EndpointSIPTemplate.priority',
        collection_class=ordering_list('priority'),
    )
    templates = association_proxy(
        'template_relations',
        'parent',
        creator=lambda _sip: EndpointSIPTemplate(parent=_sip),
    )
    _options = column_property(
        select([column('options')])
        .where(column('root') == uuid)
        .select_from(table('endpoint_sip_options_view'))
        .as_scalar()
    )
    _aor_section = relationship(
        'AORSection',
        uselist=False, cascade="all, delete-orphan", passive_deletes=True,
    )
    _auth_section = relationship(
        'AuthSection',
        uselist=False, cascade="all, delete-orphan", passive_deletes=True,
    )
    _endpoint_section = relationship(
        'EndpointSection',
        uselist=False, cascade="all, delete-orphan", passive_deletes=True,
    )
    _registration_section = relationship(
        'RegistrationSection',
        uselist=False, cascade="all, delete-orphan", passive_deletes=True
    )
    _registration_outbound_auth_section = relationship(
        'RegistrationOutboundAuthSection',
        uselist=False, cascade="all, delete-orphan", passive_deletes=True,
    )
    _identify_section = relationship(
        'IdentifySection',
        uselist=False, cascade="all, delete-orphan", passive_deletes=True,
    )
    _outbound_auth_section = relationship(
        'OutboundAuthSection',
        uselist=False, cascade="all, delete-orphan", passive_deletes=True,
    )

    def __init__(
        self,
        aor_section_options=None,
        auth_section_options=None,
        endpoint_section_options=None,
        registration_section_options=None,
        registration_outbound_auth_section_options=None,
        identify_section_options=None,
        outbound_auth_section_options=None,
        caller_id=None,
        *args,
        **kwargs
    ):
        if aor_section_options:
            kwargs['_aor_section'] = AORSection(
                options=aor_section_options,
            )
        if auth_section_options:
            kwargs['_auth_section'] = AuthSection(
                options=auth_section_options,
            )
        if endpoint_section_options:
            kwargs['_endpoint_section'] = EndpointSection(
                options=endpoint_section_options,
            )
        if registration_section_options:
            kwargs['_registration_section'] = RegistrationSection(
                options=registration_section_options,
            )
        if registration_outbound_auth_section_options:
            kwargs['_registration_outbound_auth_section'] = RegistrationOutboundAuthSection(
                options=registration_outbound_auth_section_options,
            )
        if identify_section_options:
            kwargs['_identify_section'] = IdentifySection(
                options=identify_section_options,
            )
        if outbound_auth_section_options:
            kwargs['_outbound_auth_section'] = OutboundAuthSection(
                options=outbound_auth_section_options,
            )
        super().__init__(*args, **kwargs)
        if caller_id:
            self.caller_id = caller_id

    def __repr__(self):
        return f'EndpointSIP(label={self.label})'

    @hybrid_property
    def aor_section_options(self):
        if not self._aor_section:
            return []
        return self._aor_section.options

    @aor_section_options.setter
    def aor_section_options(self, options):
        if not self._aor_section:
            self._aor_section = AORSection(options=options)
        elif options:
            self._aor_section.options = options
        else:
            self._aor_section = None

    @hybrid_property
    def auth_section_options(self):
        if not self._auth_section:
            return []
        return self._auth_section.options

    @auth_section_options.setter
    def auth_section_options(self, options):
        if not self._auth_section:
            self._auth_section = AuthSection(options=options)
        elif options:
            self._auth_section.options = options
        else:
            self._auth_section = None

    @hybrid_property
    def endpoint_section_options(self):
        if not self._endpoint_section:
            return []
        return self._endpoint_section.options

    @endpoint_section_options.setter
    def endpoint_section_options(self, options):
        if not self._endpoint_section:
            self._endpoint_section = EndpointSection(options=options)
        elif options:
            self._endpoint_section.options = options
        else:
            self._endpoint_section = None

    def _get_combined_section_options(self, section_name):
        inherited_options = getattr(self, f'inherited_{section_name}_section_options')
        endpoint_options = getattr(self, f'{section_name}_section_options')
        return inherited_options + endpoint_options

    @hybrid_property
    def combined_aor_section_options(self):
        return self._get_combined_section_options('aor')

    @hybrid_property
    def combined_auth_section_options(self):
        return self._get_combined_section_options('auth')

    @hybrid_property
    def combined_endpoint_section_options(self):
        return self._get_combined_section_options('endpoint')

    @hybrid_property
    def combined_registration_section_options(self):
        return self._get_combined_section_options('registration')

    @hybrid_property
    def combined_registration_outbound_auth_section_options(self):
        return self._get_combined_section_options('registration_outbound_auth')

    @hybrid_property
    def combined_identify_section_options(self):
        return self._get_combined_section_options('identify')

    @hybrid_property
    def combined_outbound_auth_section_options(self):
        return self._get_combined_section_options('outbound_auth')

    def _get_inherited_section_options(self, section_name):
        if not self.templates:
            return []

        options = []
        for template in self.templates:
            template_options = getattr(
                template,
                f'combined_{section_name}_section_options',
            )
            for k, v in template_options:
                options.append([k, v])
        return options

    @hybrid_property
    def inherited_aor_section_options(self):
        return self._get_inherited_section_options('aor')

    @hybrid_property
    def inherited_auth_section_options(self):
        return self._get_inherited_section_options('auth')

    @hybrid_property
    def inherited_endpoint_section_options(self):
        return self._get_inherited_section_options('endpoint')

    @hybrid_property
    def inherited_registration_section_options(self):
        return self._get_inherited_section_options('registration')

    @hybrid_property
    def inherited_registration_outbound_auth_section_options(self):
        return self._get_inherited_section_options('registration_outbound_auth')

    @hybrid_property
    def inherited_identify_section_options(self):
        return self._get_inherited_section_options('identify')

    @hybrid_property
    def inherited_outbound_auth_section_options(self):
        return self._get_inherited_section_options('outbound_auth')

    @hybrid_property
    def registration_section_options(self):
        if not self._registration_section:
            return []
        return self._registration_section.options

    @registration_section_options.setter
    def registration_section_options(self, options):
        if not self._registration_section:
            self._registration_section = RegistrationSection(options=options)
        elif options:
            self._registration_section.options = options
        else:
            self._registration_section = None

    @hybrid_property
    def registration_outbound_auth_section_options(self):
        if not self._registration_outbound_auth_section:
            return []
        return self._registration_outbound_auth_section.options

    @registration_outbound_auth_section_options.setter
    def registration_outbound_auth_section_options(self, options):
        if not self._registration_outbound_auth_section:
            self._registration_outbound_auth_section = RegistrationOutboundAuthSection(
                options=options,
            )
        elif options:
            self._registration_outbound_auth_section.options = options
        else:
            self._registration_outbound_auth_section = None

    @hybrid_property
    def identify_section_options(self):
        if not self._identify_section:
            return []
        return self._identify_section.options

    @identify_section_options.setter
    def identify_section_options(self, options):
        if not self._identify_section:
            self._identify_section = IdentifySection(options=options)
        elif options:
            self._identify_section.options = options
        else:
            self._identify_section = None

    @hybrid_property
    def outbound_auth_section_options(self):
        if not self._outbound_auth_section:
            return []
        return self._outbound_auth_section.options

    @outbound_auth_section_options.setter
    def outbound_auth_section_options(self, options):
        if not self._outbound_auth_section:
            self._outbound_auth_section = OutboundAuthSection(options=options)
        elif options:
            self._outbound_auth_section.options = options
        else:
            self._outbound_auth_section = None

    line = relationship('LineFeatures', uselist=False)
    trunk = relationship('TrunkFeatures', uselist=False)

    @hybrid_property
    def caller_id(self):
        if not self._endpoint_section:
            return

        matching_options = self._endpoint_section.find('callerid')
        for key, value in matching_options:
            return value

    @caller_id.expression
    def caller_id(cls):
        return cls._query_option_value('callerid')

    @caller_id.setter
    def caller_id(self, caller_id):
        if not self._endpoint_section:
            self._endpoint_section = EndpointSection()

        self._endpoint_section.add_or_replace('callerid', caller_id)

    def update_caller_id(self, user, extension=None):
        # Copied from old table
        name, num = user.extrapolate_caller_id(extension)
        caller_id = f'"{name}"'
        if num:
            caller_id += f" <{num}>"
        self.caller_id = caller_id

    def endpoint_protocol(self):
        return 'sip'

    @hybrid_property
    def username(self):
        return self._find_first_value(self._auth_section, 'username')

    @username.expression
    def username(cls):
        return select(
            [EndpointSIPSectionOption.value]
        ).where(
            and_(
                cls.uuid == EndpointSIPSection.endpoint_sip_uuid,
                EndpointSIPSection.type == 'auth',
                EndpointSIPSectionOption.endpoint_sip_section_uuid == EndpointSIPSection.uuid,
                EndpointSIPSectionOption.key == 'username',
            )
        ).as_scalar()

    @hybrid_property
    def password(self):
        return self._find_first_value(self._auth_section, 'password')

    @password.expression
    def password(cls):
        return select(
            [EndpointSIPSectionOption.value]
        ).where(
            and_(
                cls.uuid == EndpointSIPSection.endpoint_sip_uuid,
                EndpointSIPSection.type == 'auth',
                EndpointSIPSectionOption.endpoint_sip_section_uuid == EndpointSIPSection.uuid,
                EndpointSIPSectionOption.key == 'password',
            )
        ).as_scalar()

    def _find_first_value(self, section, key):
        if not section:
            return
        matching_options = section.find(key)
        for _, value in matching_options:
            return value

    def get_option_value(self, option):
        if not self._options:
            return None
        return self._options.get(option, None)

    @classmethod
    def _query_option_value(cls, option):
        if option is None:
            return None

        return cls._options.remote_attr[option].astext

----------------------------------------

File: alchemy/endpoint_sip_options_view.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import Index, String, cast, func, join, literal, select, text
from sqlalchemy.dialects.postgresql import JSONB, aggregate_order_by
from sqlalchemy_utils import create_materialized_view

from ..helpers.db_manager import Base
from ..helpers.db_views import MaterializedView
from .endpoint_sip import EndpointSIP, EndpointSIPTemplate
from .endpoint_sip_section import EndpointSIPSection
from .endpoint_sip_section_option import EndpointSIPSectionOption


def _generate_selectable():
    cte = select(
        [
            EndpointSIP.uuid.label('uuid'),
            literal(0).label('level'),
            literal('0', String).label('path'),
            EndpointSIP.uuid.label('root'),
        ]
    ).cte(recursive=True)

    endpoints = cte.union_all(
        select(
            [
                EndpointSIPTemplate.parent_uuid.label('uuid'),
                (cte.c.level + 1).label('level'),
                (
                    cte.c.path
                    + cast(
                        func.row_number().over(
                            partition_by='level',
                            order_by=EndpointSIPTemplate.priority,
                        ),
                        String,
                    )
                ).label('path'),
                (cte.c.root),
            ]
        ).select_from(
            join(cte, EndpointSIPTemplate, cte.c.uuid == EndpointSIPTemplate.child_uuid)
        )
    )

    return (
        select(
            [
                endpoints.c.root,
                cast(
                    func.jsonb_object(
                        func.array_agg(
                            aggregate_order_by(
                                EndpointSIPSectionOption.key,
                                endpoints.c.path.desc(),
                            )
                        ),
                        func.array_agg(
                            aggregate_order_by(
                                EndpointSIPSectionOption.value,
                                endpoints.c.path.desc(),
                            )
                        ),
                    ),
                    JSONB,
                ).label('options'),
            ]
        )
        .select_from(
            join(
                endpoints,
                EndpointSIPSection,
                EndpointSIPSection.endpoint_sip_uuid == endpoints.c.uuid,
            ).join(
                EndpointSIPSectionOption,
                EndpointSIPSectionOption.endpoint_sip_section_uuid
                == EndpointSIPSection.uuid,
            )
        )
        .group_by('root')
    )


class EndpointSIPOptionsView(MaterializedView):
    __table__ = create_materialized_view(
        'endpoint_sip_options_view',
        _generate_selectable(),
        metadata=Base.metadata,
        indexes=[
            Index('endpoint_sip_options_view__idx_root', text('root'), unique=True),
        ],
    )
    __view_dependencies__ = (EndpointSIPSectionOption, EndpointSIP)

    @classmethod
    def get_option_value(cls, option):
        return cls.options[option].astext

----------------------------------------

File: alchemy/endpoint_sip_section.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import Enum, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, Index, UniqueConstraint

from accent_dao.helpers.db_manager import Base

from .endpoint_sip_section_option import EndpointSIPSectionOption


class EndpointSIPSection(Base):
    __tablename__ = 'endpoint_sip_section'
    __table_args__ = (
        UniqueConstraint('type', 'endpoint_sip_uuid'),
        Index('endpoint_sip_section__idx__endpoint_sip_uuid', 'endpoint_sip_uuid'),
    )

    uuid = Column(
        UUID(as_uuid=True),
        server_default=text('uuid_generate_v4()'),
        primary_key=True,
    )
    type = Column(
        'type',
        Enum(
            'aor',
            'auth',
            'endpoint',
            'identify',
            'outbound_auth',
            'registration_outbound_auth',
            'registration',
            name='endpoint_sip_section_type',
        ),
        nullable=False,
    )
    endpoint_sip_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey('endpoint_sip.uuid', ondelete='CASCADE'),
        nullable=False,
    )

    __mapper_args__ = {'polymorphic_on': type, 'polymorphic_identity': 'section'}

    _options = relationship(
        'EndpointSIPSectionOption',
        cascade='all, delete-orphan',
        passive_deletes=True,
        lazy='joined',
    )

    options = association_proxy(
        '_options',
        'option',
        creator=lambda _option: EndpointSIPSectionOption(
            key=_option[0], value=_option[1]
        ),
    )

    def find(self, term):
        return [
            (option.key, option.value) for option in self._options if option.key == term
        ]

    def add_or_replace(self, option_name, value):
        for option in self._options:
            if option.key == option_name:
                option.value = value
                return

        self._options.append(EndpointSIPSectionOption(key=option_name, value=value))


class AORSection(EndpointSIPSection):
    __mapper_args__ = {'polymorphic_identity': 'aor'}


class AuthSection(EndpointSIPSection):
    __mapper_args__ = {'polymorphic_identity': 'auth'}


class EndpointSection(EndpointSIPSection):
    __mapper_args__ = {'polymorphic_identity': 'endpoint'}


class IdentifySection(EndpointSIPSection):
    __mapper_args__ = {'polymorphic_identity': 'identify'}


class OutboundAuthSection(EndpointSIPSection):
    __mapper_args__ = {'polymorphic_identity': 'outbound_auth'}


class RegistrationOutboundAuthSection(EndpointSIPSection):
    __mapper_args__ = {'polymorphic_identity': 'registration_outbound_auth'}


class RegistrationSection(EndpointSIPSection):
    __mapper_args__ = {'polymorphic_identity': 'registration'}
----------------------------------------

File: alchemy/endpoint_sip_section_option.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.schema import Column, ForeignKey, Index
from sqlalchemy.types import Text

from accent_dao.helpers.db_manager import Base


class EndpointSIPSectionOption(Base):
    __tablename__ = 'endpoint_sip_section_option'
    __table_args__ = (
        Index(
            'endpoint_sip_section_option__idx__endpoint_sip_section_uuid',
            'endpoint_sip_section_uuid',
        ),
    )

    uuid = Column(
        UUID(as_uuid=True), server_default=text('uuid_generate_v4()'), primary_key=True
    )
    key = Column(Text, nullable=False)
    value = Column(Text, nullable=False)
    endpoint_sip_section_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey('endpoint_sip_section.uuid', ondelete='CASCADE'),
        nullable=False,
    )

    @property
    def option(self):
        return [self.key, self.value]

    @option.setter
    def option(self, option):
        self.key, self.value = option

----------------------------------------

File: alchemy/enum.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.types import Enum

from accent_dao.helpers.db_manager import Base

dialaction_action = Enum(
    'none',
    'endcall:busy',
    'endcall:congestion',
    'endcall:hangup',
    'user',
    'group',
    'queue',
    'voicemail',
    'extension',
    'outcall',
    'application:callbackdisa',
    'application:disa',
    'application:directory',
    'application:faxtomail',
    'application:voicemailmain',
    'application:password',
    'sound',
    'custom',
    'ivr',
    'conference',
    'switchboard',
    'application:custom',
    name='dialaction_action',
    metadata=Base.metadata,
)

dialaction_category = Enum(
    'callfilter',
    'group',
    'incall',
    'queue',
    'user',
    'ivr',
    'ivr_choice',
    'switchboard',
    name='dialaction_category',
    metadata=Base.metadata,
)

extenumbers_type = Enum(
    'extenfeatures',
    'featuremap',
    'generalfeatures',
    'group',
    'incall',
    'outcall',
    'queue',
    'user',
    'voicemenu',
    'conference',
    'parking',
    name='extenumbers_type',
    metadata=Base.metadata,
)

callfilter_type = Enum('bosssecretary', name='callfilter_type', metadata=Base.metadata)

callfilter_bosssecretary = Enum(
    'bossfirst-serial',
    'bossfirst-simult',
    'secretary-serial',
    'secretary-simult',
    'all',
    name='callfilter_bosssecretary',
    metadata=Base.metadata,
)

callfilter_callfrom = Enum(
    'internal', 'external', 'all', name='callfilter_callfrom', metadata=Base.metadata
)

generic_bsfilter = Enum(
    'no', 'boss', 'secretary', name='generic_bsfilter', metadata=Base.metadata
)

netiface_type = Enum('iface', name='netiface_type', metadata=Base.metadata)

schedule_path_type = Enum(
    'user',
    'group',
    'queue',
    'incall',
    'outcall',
    'voicemenu',
    name='schedule_path_type',
    metadata=Base.metadata,
)

stat_switchboard_endtype = Enum(
    'abandoned',
    'completed',
    'forwarded',
    'transferred',
    name='stat_switchboard_endtype',
    metadata=Base.metadata,
)

valid_trunk_protocols = [
    'sip',
    'iax',
    'sccp',
    'custom',
]
trunk_protocol = Enum(
    *valid_trunk_protocols, name='trunk_protocol', metadata=Base.metadata
)

----------------------------------------

File: alchemy/extension.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.orm.attributes import get_history
from sqlalchemy.schema import (
    Column,
    ForeignKeyConstraint,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import cast, func, not_, select
from sqlalchemy.types import Boolean, Integer, String

from accent_dao.alchemy import enum
from accent_dao.alchemy.context import Context
from accent_dao.helpers.db_manager import Base, IntAsString


class Extension(Base):
    __tablename__ = 'extensions'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('exten', 'context'),
        Index('extensions__idx__context', 'context'),
        Index('extensions__idx__exten', 'exten'),
        Index('extensions__idx__type', 'type'),
        Index('extensions__idx__typeval', 'typeval'),
        ForeignKeyConstraint(
            ('context',),
            ('context.name',),
            ondelete='CASCADE',
        ),
    )

    id = Column(Integer)
    commented = Column(Integer, nullable=False, server_default='0')
    context = Column(String(79), nullable=False, server_default='')
    exten = Column(String(40), nullable=False, server_default='')
    type = Column(enum.extenumbers_type, nullable=False)
    typeval = Column(IntAsString(255), nullable=False, server_default='')

    context_rel = relationship(
        'Context',
        primaryjoin='''Extension.context == Context.name''',
        foreign_keys='Extension.context',
    )

    def get_old_context(self):
        context_history = get_history(self, 'context')
        if context_history[2]:
            return context_history[2][0]
        return self.context

    @hybrid_property
    def tenant_uuid(self):
        if self.context_rel:
            return self.context_rel.tenant_uuid

        return None

    @tenant_uuid.expression
    def tenant_uuid(cls):
        return func.coalesce(
            select([Context.tenant_uuid])
            .where(Context.name == cls.context)
            .label('type'),
            None,
        )

    @hybrid_property
    def context_type(self):
        if self.context_ref:
            return self.context_rel.type

    @context_type.expression
    def context_type(cls):
        return func.coalesce(
            select([Context.contexttype])
            .where(Context.name == cls.context)
            .label('type'),
            'internal',
        )

    dialpattern = relationship(
        'DialPattern',
        primaryjoin="""and_(
            Extension.type == 'outcall',
            Extension.typeval == cast(DialPattern.id, String)
        )""",
        foreign_keys='Extension.typeval',
        viewonly=True,
    )

    outcall = association_proxy('dialpattern', 'outcall')

    line_extensions = relationship('LineExtension', viewonly=True)

    lines = association_proxy('line_extensions', 'line')

    group = relationship(
        'GroupFeatures',
        primaryjoin="""and_(
            Extension.type == 'group',
            Extension.typeval == cast(GroupFeatures.id, String)
        )""",
        foreign_keys='Extension.typeval',
        viewonly=True,
    )

    queue = relationship(
        'QueueFeatures',
        primaryjoin="""and_(
            Extension.type == 'queue',
            Extension.typeval == cast(QueueFeatures.id, String)
        )""",
        foreign_keys='Extension.typeval',
        viewonly=True,
    )

    incall = relationship(
        'Incall',
        primaryjoin="""and_(
            Extension.type == 'incall',
            Extension.typeval == cast(Incall.id, String)
        )""",
        foreign_keys='Extension.typeval',
        viewonly=True,
    )

    conference = relationship(
        'Conference',
        primaryjoin="""and_(
            Extension.type == 'conference',
            Extension.typeval == cast(Conference.id, String)
        )""",
        foreign_keys='Extension.typeval',
        viewonly=True,
    )

    parking_lot = relationship(
        'ParkingLot',
        primaryjoin="""and_(
            Extension.type == 'parking',
            Extension.typeval == cast(ParkingLot.id, String)
        )""",
        foreign_keys='Extension.typeval',
        viewonly=True,
    )

    @property
    def name(self):
        return self.typeval

    @hybrid_property
    def legacy_commented(self):
        return bool(self.commented)

    @legacy_commented.expression
    def legacy_commented(cls):
        return cast(cls.commented, Boolean)

    @legacy_commented.setter
    def legacy_commented(self, value):
        if value is not None:
            value = int(value)
        self.commented = value

    @hybrid_property
    def enabled(self):
        return self.commented == 0

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False)

    def is_pattern(self):
        return self.exten.startswith('_')

----------------------------------------

File: alchemy/external_app.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, ForeignKey
from sqlalchemy.types import JSON, String, Text

from accent_dao.helpers.db_manager import Base


class ExternalApp(Base):

    __tablename__ = 'external_app'

    name = Column(Text, primary_key=True)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        primary_key=True,
    )
    label = Column(Text)
    configuration = Column(JSON)

----------------------------------------

File: alchemy/feature_extension.py
Please review for update

# Copyright 2023 Accent Communications

from accent.accent_helpers import clean_extension
from sqlalchemy import text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.schema import Column, PrimaryKeyConstraint, UniqueConstraint
from sqlalchemy.types import Boolean, String

from accent_dao.helpers.db_manager import Base


class FeatureExtension(Base):
    __tablename__ = 'feature_extension'
    __table_args__ = (
        PrimaryKeyConstraint('uuid'),
        UniqueConstraint('exten'),
    )

    uuid = Column(UUID(as_uuid=True), server_default=text('uuid_generate_v4()'))
    enabled = Column(Boolean, nullable=False, server_default='true')
    exten = Column(String(40), nullable=False)
    feature = Column(String(255), nullable=False)

    def is_pattern(self):
        return self.exten.startswith('_')

    def clean_exten(self):
        return clean_extension(self.exten)

----------------------------------------

File: alchemy/features.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class Features(Base):

    __tablename__ = 'features'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('features__idx__category', 'category'),
    )

    id = Column(Integer)
    cat_metric = Column(Integer, nullable=False, server_default='0')
    var_metric = Column(Integer, nullable=False, server_default='0')
    commented = Column(Integer, nullable=False, server_default='0')
    filename = Column(String(128), nullable=False)
    category = Column(String(128), nullable=False)
    var_name = Column(String(128), nullable=False)
    var_val = Column(String(255))

----------------------------------------

File: alchemy/func_key.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index
from sqlalchemy.types import Integer

from accent_dao.helpers.db_manager import Base

from .func_key_destination_type import FuncKeyDestinationType
from .func_key_type import FuncKeyType


class FuncKey(Base):
    __tablename__ = 'func_key'
    __table_args__ = (Index('func_key__idx__type_id', 'type_id'),)

    id = Column(Integer, primary_key=True, autoincrement=True)
    type_id = Column(Integer, ForeignKey('func_key_type.id'), nullable=False)
    destination_type_id = Column(
        Integer,
        ForeignKey('func_key_destination_type.id'),
        primary_key=True,
    )

    func_key_type = relationship(FuncKeyType, foreign_keys=type_id)
    destination_type = relationship(
        FuncKeyDestinationType, foreign_keys=destination_type_id, viewonly=True
    )
    destination_type_name = association_proxy('destination_type', 'name')

    func_key_mapping = relationship('FuncKeyMapping', cascade='all,delete-orphan')

----------------------------------------

File: alchemy/func_key_dest_agent.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
    ForeignKeyConstraint,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.types import Integer

from accent_dao.alchemy.agentfeatures import AgentFeatures
from accent_dao.alchemy.feature_extension import FeatureExtension
from accent_dao.alchemy.func_key import FuncKey
from accent_dao.helpers.db_manager import Base


class FuncKeyDestAgent(Base):
    DESTINATION_TYPE_ID = 11

    __tablename__ = 'func_key_dest_agent'
    __table_args__ = (
        PrimaryKeyConstraint('func_key_id', 'destination_type_id'),
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        UniqueConstraint('agent_id', 'feature_extension_uuid'),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
        Index('func_key_dest_agent__idx__agent_id', 'agent_id'),
    )

    func_key_id = Column(Integer)
    destination_type_id = Column(Integer, server_default=f"{DESTINATION_TYPE_ID}")
    agent_id = Column(Integer, ForeignKey('agentfeatures.id'), nullable=False)
    feature_extension_uuid = Column(
        UUID(as_uuid=True), ForeignKey('feature_extension.uuid'), nullable=False
    )

    type = 'agent'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)
    agent = relationship(AgentFeatures)

    feature_extension = relationship(FeatureExtension, viewonly=True)
    feature_extension_feature = association_proxy(
        'feature_extension',
        'feature',
        # Only to keep value persistent in the instance
        creator=lambda _feature: FeatureExtension(feature=_feature),
    )

    def to_tuple(self):
        return (
            ('action', self.action),
            ('agent_id', self.agent_id),
        )

    @hybrid_property
    def action(self):
        ACTIONS = {
            'agentstaticlogin': 'login',
            'agentstaticlogoff': 'logout',
            'agentstaticlogtoggle': 'toggle',
        }
        return ACTIONS.get(
            self.feature_extension_feature, self.feature_extension_feature
        )

    @action.expression
    def action(cls):
        return cls.feature_extension_feature  # only used to pass test

    @action.setter
    def action(self, value):
        TYPEVALS = {
            'login': 'agentstaticlogin',
            'logout': 'agentstaticlogoff',
            'toggle': 'agentstaticlogtoggle',
        }
        self.feature_extension_feature = TYPEVALS.get(value, value)

----------------------------------------

File: alchemy/func_key_dest_bsfilter.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
    ForeignKeyConstraint,
    Index,
    PrimaryKeyConstraint,
)
from sqlalchemy.types import Integer

from accent_dao.alchemy.callfiltermember import Callfiltermember
from accent_dao.alchemy.func_key import FuncKey
from accent_dao.helpers.db_manager import Base


class FuncKeyDestBSFilter(Base):

    DESTINATION_TYPE_ID = 12

    __tablename__ = 'func_key_dest_bsfilter'
    __table_args__ = (
        PrimaryKeyConstraint('func_key_id', 'destination_type_id', 'filtermember_id'),
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
        Index('func_key_dest_bsfilter__idx__filtermember_id', 'filtermember_id'),
    )

    func_key_id = Column(Integer)
    destination_type_id = Column(Integer, server_default=f"{DESTINATION_TYPE_ID}")
    filtermember_id = Column(Integer, ForeignKey('callfiltermember.id'), nullable=False)

    type = 'bsfilter'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)
    filtermember = relationship(Callfiltermember)

    def to_tuple(self):
        return (('filter_member_id', self.filtermember_id),)

    @hybrid_property
    def filter_member_id(self):
        return self.filtermember_id

    @filter_member_id.setter
    def filter_member_id(self, value):
        self.filtermember_id = value

----------------------------------------

File: alchemy/func_key_dest_conference.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, ForeignKey, ForeignKeyConstraint, CheckConstraint
from sqlalchemy.types import Integer
from sqlalchemy.orm import relationship

from accent_dao.alchemy.func_key import FuncKey
from accent_dao.alchemy.conference import Conference
from accent_dao.helpers.db_manager import Base


class FuncKeyDestConference(Base):

    DESTINATION_TYPE_ID = 4

    __tablename__ = 'func_key_dest_conference'
    __table_args__ = (
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
    )

    func_key_id = Column(Integer, primary_key=True)
    destination_type_id = Column(Integer, primary_key=True, server_default=f"{DESTINATION_TYPE_ID}")
    conference_id = Column(Integer, ForeignKey('conference.id', ondelete='CASCADE'), primary_key=True)

    type = 'conference'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)
    conference = relationship(Conference)

    def to_tuple(self):
        return (('conference_id', self.conference_id),)

----------------------------------------

File: alchemy/func_key_dest_custom.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import CheckConstraint, Column, ForeignKeyConstraint, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String

from accent_dao.alchemy.func_key import FuncKey
from accent_dao.helpers.db_manager import Base


class FuncKeyDestCustom(Base):
    DESTINATION_TYPE_ID = 10

    __tablename__ = 'func_key_dest_custom'
    __table_args__ = (
        PrimaryKeyConstraint('func_key_id', 'destination_type_id'),
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
    )

    func_key_id = Column(Integer)
    destination_type_id = Column(Integer, server_default=f"{DESTINATION_TYPE_ID}")
    exten = Column(String(40), nullable=False)

    type = 'custom'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)

    def to_tuple(self):
        return (('exten', self.exten),)

----------------------------------------

File: alchemy/func_key_dest_features.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
    ForeignKeyConstraint,
    Index,
    PrimaryKeyConstraint,
)
from sqlalchemy.types import Integer

from accent_dao.alchemy.features import Features
from accent_dao.alchemy.func_key import FuncKey
from accent_dao.helpers.db_manager import Base


class FuncKeyDestFeatures(Base):
    DESTINATION_TYPE_ID = 8

    __tablename__ = 'func_key_dest_features'
    __table_args__ = (
        PrimaryKeyConstraint('func_key_id', 'destination_type_id', 'features_id'),
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
        Index('func_key_dest_features__idx__features_id', 'features_id'),
    )

    func_key_id = Column(Integer)
    destination_type_id = Column(Integer, server_default=f"{DESTINATION_TYPE_ID}")
    features_id = Column(Integer, ForeignKey('features.id'))

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)
    features = relationship(Features)

    @hybrid_property
    def feature_id(self):
        return self.features_id

    @feature_id.setter
    def feature_id(self, value):
        self.features_id = value


# These tables don't exist in database
class _FuncKeyDestFeaturesWithoutBaseDeclarative:
    def __init__(self, **kwargs):
        self._func_key_dest_features = FuncKeyDestFeatures(**kwargs)
        self._func_key_dest_features.type = self.type

    def __getattr__(self, attr):
        return getattr(self._func_key_dest_features, attr)


class FuncKeyDestOnlineRecording(_FuncKeyDestFeaturesWithoutBaseDeclarative):
    type = 'onlinerec'

    def to_tuple(self):
        return (('feature', 'onlinerec'),)


class FuncKeyDestTransfer(_FuncKeyDestFeaturesWithoutBaseDeclarative):
    type = 'transfer'

    def __init__(self, **kwargs):
        transfer = kwargs.pop('transfer', None)
        super().__init__(**kwargs)
        if transfer:
            self._func_key_dest_features.transfer = transfer

    def to_tuple(self):
        return (('transfer', self.transfer),)

----------------------------------------

File: alchemy/func_key_dest_forward.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
    ForeignKeyConstraint,
    PrimaryKeyConstraint,
)
from sqlalchemy.types import Integer, String

from accent_dao.alchemy.feature_extension import FeatureExtension
from accent_dao.alchemy.func_key import FuncKey
from accent_dao.helpers.db_manager import Base


class FuncKeyDestForward(Base):
    DESTINATION_TYPE_ID = 6

    __tablename__ = 'func_key_dest_forward'
    __table_args__ = (
        PrimaryKeyConstraint(
            'func_key_id', 'destination_type_id', 'feature_extension_uuid'
        ),
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
    )

    func_key_id = Column(Integer)
    destination_type_id = Column(Integer, server_default=f"{DESTINATION_TYPE_ID}")
    feature_extension_uuid = Column(
        UUID(as_uuid=True), ForeignKey('feature_extension.uuid'), nullable=False
    )
    number = Column(String(40))

    type = 'forward'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)

    feature_extension = relationship(FeatureExtension, viewonly=True)
    feature_extension_feature = association_proxy(
        'feature_extension',
        'feature',
        # Only to keep value persistent in the instance
        creator=lambda _feature: FeatureExtension(feature=_feature),
    )

    def to_tuple(self):
        return (
            ('exten', self.exten),
            ('forward', self.forward),
        )

    @hybrid_property
    def exten(self):
        return self.number

    @exten.setter
    def exten(self, value):
        self.number = value

    @hybrid_property
    def forward(self):
        FORWARDS = {'fwdbusy': 'busy', 'fwdrna': 'noanswer', 'fwdunc': 'unconditional'}
        return FORWARDS.get(
            self.feature_extension_feature, self.feature_extension_feature
        )

    @forward.expression
    def forward(cls):
        return cls.feature_extension_feature  # only used to pass test

    @forward.setter
    def forward(self, value):
        TYPEVALS = {'busy': 'fwdbusy', 'noanswer': 'fwdrna', 'unconditional': 'fwdunc'}
        self.feature_extension_feature = TYPEVALS.get(value, value)
----------------------------------------

File: alchemy/func_key_dest_group.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import CheckConstraint, Column, ForeignKey, ForeignKeyConstraint
from sqlalchemy.types import Integer

from accent_dao.alchemy.func_key import FuncKey
from accent_dao.alchemy.groupfeatures import GroupFeatures
from accent_dao.helpers.db_manager import Base


class FuncKeyDestGroup(Base):
    DESTINATION_TYPE_ID = 2

    __tablename__ = 'func_key_dest_group'
    __table_args__ = (
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
    )

    func_key_id = Column(Integer, primary_key=True)
    destination_type_id = Column(
        Integer, primary_key=True, server_default=f"{DESTINATION_TYPE_ID}"
    )
    group_id = Column(Integer, ForeignKey('groupfeatures.id'), primary_key=True)

    type = 'group'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)
    groupfeatures = relationship(GroupFeatures)

    def to_tuple(self):
        return (('group_id', self.group_id),)

----------------------------------------

File: alchemy/func_key_dest_group_member.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
    ForeignKeyConstraint,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.types import Integer

from accent_dao.alchemy.feature_extension import FeatureExtension
from accent_dao.alchemy.func_key import FuncKey
from accent_dao.alchemy.groupfeatures import GroupFeatures
from accent_dao.helpers.db_manager import Base


class FuncKeyDestGroupMember(Base):
    DESTINATION_TYPE_ID = 13

    __tablename__ = 'func_key_dest_groupmember'
    __table_args__ = (
        PrimaryKeyConstraint('func_key_id', 'destination_type_id'),
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        UniqueConstraint('group_id', 'feature_extension_uuid'),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
        Index('func_key_dest_groupmember__idx__group_id', 'group_id'),
    )

    func_key_id = Column(Integer)
    destination_type_id = Column(Integer, server_default=f"{DESTINATION_TYPE_ID}")
    group_id = Column(Integer, ForeignKey('groupfeatures.id'), nullable=False)
    feature_extension_uuid = Column(
        UUID(as_uuid=True), ForeignKey('feature_extension.uuid'), nullable=False
    )

    type = 'groupmember'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)
    group = relationship(GroupFeatures)

    feature_extension = relationship(FeatureExtension, viewonly=True)
    feature_extension_feature = association_proxy(
        'feature_extension',
        'feature',
        # Only to keep value persistent in the instance
        creator=lambda _feature: FeatureExtension(feature=_feature),
    )

    def to_tuple(self):
        return (
            ('action', self.action),
            ('group_id', self.group_id),
        )

    @hybrid_property
    def action(self):
        ACTIONS = {
            'groupmemberjoin': 'join',
            'groupmemberleave': 'leave',
            'groupmembertoggle': 'toggle',
        }
        return ACTIONS.get(
            self.feature_extension_feature, self.feature_extension_feature
        )

    @action.expression
    def action(cls):
        return cls.feature_extension_feature  # only used to pass test

    @action.setter
    def action(self, value):
        TYPEVALS = {
            'join': 'groupmemberjoin',
            'leave': 'groupmemberleave',
            'toggle': 'groupmembertoggle',
        }
        self.feature_extension_feature = TYPEVALS.get(value, value)

----------------------------------------

File: alchemy/func_key_dest_paging.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
    ForeignKeyConstraint,
    Index,
    PrimaryKeyConstraint,
)
from sqlalchemy.types import Integer

from accent_dao.alchemy.func_key import FuncKey
from accent_dao.alchemy.paging import Paging
from accent_dao.helpers.db_manager import Base


class FuncKeyDestPaging(Base):

    DESTINATION_TYPE_ID = 9

    __tablename__ = 'func_key_dest_paging'
    __table_args__ = (
        PrimaryKeyConstraint('func_key_id', 'destination_type_id', 'paging_id'),
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
        Index('func_key_dest_paging__idx__paging_id', 'paging_id'),
    )

    func_key_id = Column(Integer)
    destination_type_id = Column(Integer, server_default=f"{DESTINATION_TYPE_ID}")
    paging_id = Column(Integer, ForeignKey('paging.id'))

    type = 'paging'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)
    paging = relationship(Paging)

    def to_tuple(self):
        return (('paging_id', self.paging_id),)

----------------------------------------

File: alchemy/func_key_dest_park_position.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
    ForeignKeyConstraint,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import cast
from sqlalchemy.types import Integer, String

from accent_dao.alchemy.func_key import FuncKey
from accent_dao.alchemy.parking_lot import ParkingLot
from accent_dao.helpers.db_manager import Base


class FuncKeyDestParkPosition(Base):
    DESTINATION_TYPE_ID = 7

    __tablename__ = 'func_key_dest_park_position'
    __table_args__ = (
        PrimaryKeyConstraint('func_key_id', 'destination_type_id'),
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        UniqueConstraint('parking_lot_id', 'park_position'),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
        CheckConstraint("park_position ~ '^[0-9]+$'"),
    )

    func_key_id = Column(Integer)
    destination_type_id = Column(Integer, server_default=f"{DESTINATION_TYPE_ID}")
    parking_lot_id = Column(Integer, ForeignKey('parking_lot.id'), nullable=False)
    park_position = Column(String(40), nullable=False)

    type = 'park_position'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)
    parking_lot = relationship(ParkingLot)

    def to_tuple(self):
        return (
            ('parking_lot_id', self.parking_lot_id),
            ('position', self.position),
        )

    @hybrid_property
    def position(self):
        return int(self.park_position)

    @position.expression
    def position(cls):
        return cast(cls.park_position, Integer)

    @position.setter
    def position(self, value):
        self.park_position = value

----------------------------------------

File: alchemy/func_key_dest_parking.py
Please review for update

from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
    ForeignKeyConstraint,
    PrimaryKeyConstraint,
)
from sqlalchemy.types import Integer

from accent_dao.alchemy.func_key import FuncKey
from accent_dao.alchemy.parking_lot import ParkingLot
from accent_dao.helpers.db_manager import Base


class FuncKeyDestParking(Base):
    DESTINATION_TYPE_ID = 14

    __tablename__ = 'func_key_dest_parking'
    __table_args__ = (
        PrimaryKeyConstraint('func_key_id', 'destination_type_id'),
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
    )

    func_key_id = Column(Integer)
    destination_type_id = Column(Integer, server_default=f"{DESTINATION_TYPE_ID}")
    parking_lot_id = Column(
        Integer,
        ForeignKey('parking_lot.id'),
        nullable=False,
        unique=True,
    )

    type = 'parking'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)
    parking_lot = relationship(ParkingLot)

    def to_tuple(self):
        return (('parking_lot_id', self.parking_lot_id),)

----------------------------------------

File: alchemy/func_key_dest_queue.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import CheckConstraint, Column, ForeignKey, ForeignKeyConstraint
from sqlalchemy.types import Integer

from accent_dao.alchemy.func_key import FuncKey
from accent_dao.alchemy.queuefeatures import QueueFeatures
from accent_dao.helpers.db_manager import Base


class FuncKeyDestQueue(Base):
    DESTINATION_TYPE_ID = 3

    __tablename__ = 'func_key_dest_queue'
    __table_args__ = (
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
    )

    func_key_id = Column(Integer, primary_key=True)
    destination_type_id = Column(
        Integer, primary_key=True, server_default=f"{DESTINATION_TYPE_ID}"
    )
    queue_id = Column(Integer, ForeignKey('queuefeatures.id'), primary_key=True)

    type = 'queue'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)
    queue = relationship(QueueFeatures)

    def to_tuple(self):
        return (('queue_id', self.queue_id),)

----------------------------------------

File: alchemy/func_key_dest_service.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
    ForeignKeyConstraint,
    PrimaryKeyConstraint,
)
from sqlalchemy.types import Integer

from accent_dao.alchemy.feature_extension import FeatureExtension
from accent_dao.alchemy.func_key import FuncKey
from accent_dao.helpers.db_manager import Base


class FuncKeyDestService(Base):
    DESTINATION_TYPE_ID = 5

    __tablename__ = 'func_key_dest_service'
    __table_args__ = (
        PrimaryKeyConstraint(
            'func_key_id', 'destination_type_id', 'feature_extension_uuid'
        ),
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
    )

    func_key_id = Column(Integer)
    destination_type_id = Column(Integer, server_default=f"{DESTINATION_TYPE_ID}")
    feature_extension_uuid = Column(
        UUID(as_uuid=True), ForeignKey('feature_extension.uuid'), nullable=False
    )

    type = 'service'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)

    feature_extension = relationship(FeatureExtension, viewonly=True)
    feature_extension_feature = association_proxy(
        'feature_extension',
        'feature',
        # Only to keep value persistent in the instance
        creator=lambda _feature: FeatureExtension(feature=_feature),
    )

    def to_tuple(self):
        return (('service', self.service),)

    @hybrid_property
    def service(self):
        return self.feature_extension_feature

    @service.setter
    def service(self, value):
        self.feature_extension_feature = value

----------------------------------------

File: alchemy/func_key_dest_user.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import CheckConstraint, Column, ForeignKey, ForeignKeyConstraint
from sqlalchemy.types import Integer

from accent_dao.alchemy.func_key import FuncKey
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.helpers.db_manager import Base


class FuncKeyDestUser(Base):
    DESTINATION_TYPE_ID = 1

    __tablename__ = 'func_key_dest_user'
    __table_args__ = (
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        CheckConstraint(f'destination_type_id = {DESTINATION_TYPE_ID}'),
    )

    func_key_id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('userfeatures.id'), primary_key=True)
    destination_type_id = Column(
        Integer, primary_key=True, server_default=f"{DESTINATION_TYPE_ID}"
    )

    type = 'user'

    func_key = relationship(FuncKey, cascade='all,delete-orphan', single_parent=True)
    userfeatures = relationship(UserFeatures)

    @classmethod
    def for_user(cls, func_key, user):
        destination = cls(func_key=func_key, userfeatures=user)
        return destination

    def to_tuple(self):
        return (('user_id', self.user_id),)

----------------------------------------

File: alchemy/func_key_destination_type.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import sql
from sqlalchemy.schema import Column
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class FuncKeyDestinationType(Base):

    __tablename__ = 'func_key_destination_type'

    id = Column(Integer, primary_key=True)
    name = Column(String(128), nullable=False)

    @classmethod
    def query_id(cls, name):
        return sql.select([cls.id]).where(cls.name == name)

----------------------------------------

File: alchemy/func_key_mapping.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
    ForeignKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.types import Boolean, Integer, String

from accent_dao.alchemy.func_key import FuncKey
from accent_dao.alchemy.func_key_template import FuncKeyTemplate
from accent_dao.helpers.db_manager import Base


class FuncKeyMapping(Base):
    __tablename__ = 'func_key_mapping'
    __table_args__ = (
        ForeignKeyConstraint(
            ('func_key_id', 'destination_type_id'),
            ('func_key.id', 'func_key.destination_type_id'),
        ),
        UniqueConstraint('template_id', 'position'),
        CheckConstraint('position > 0'),
    )

    template_id = Column(
        Integer,
        ForeignKey('func_key_template.id', ondelete='CASCADE'),
        primary_key=True,
    )
    func_key_id = Column(Integer, primary_key=True)
    destination_type_id = Column(Integer, primary_key=True)
    label = Column(String(128))
    position = Column(Integer, nullable=False)
    blf = Column(Boolean, nullable=False, server_default='True')

    func_key = relationship(FuncKey, viewonly=True)
    destination_type_name = association_proxy('func_key', 'destination_type_name')

    func_key_template = relationship(FuncKeyTemplate, viewonly=True)
    func_key_template_private = association_proxy(
        'func_key_template',
        'private',
        # Only to keep value persistent in the instance
        creator=lambda _private: FuncKeyTemplate(private=_private),
    )

    def __init__(self, **kwargs):
        # destination should probably be retrieved by relationship
        # but that implies to transfer all persistor logic in this class
        self.destination = kwargs.pop('destination', None)
        super().__init__(**kwargs)

    @hybrid_property
    def id(self):
        return self.func_key_id

    @id.setter
    def id(self, value):
        self.func_key_id = value

    @hybrid_property
    def inherited(self):
        if not self.func_key_template:
            return False
        return not self.func_key_template.private

    @inherited.setter
    def inherited(self, value):
        self.func_key_template_private = not value

    def hash_destination(self):
        if self.destination:
            return self.destination.to_tuple()
        return None

----------------------------------------

File: alchemy/func_key_template.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column
from sqlalchemy.sql.schema import ForeignKey, Index
from sqlalchemy.types import Boolean, Integer, String

from accent_dao.helpers import errors
from accent_dao.helpers.db_manager import Base


class FuncKeyTemplate(Base):
    __tablename__ = 'func_key_template'
    __table_args__ = (Index('func_key_template__idx__tenant_uuid', 'tenant_uuid'),)

    id = Column(Integer, primary_key=True)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(128))
    private = Column(Boolean, nullable=False, server_default='False')

    def __init__(self, **kwargs):
        # keys should probably be retrieved by relationship
        # but that implies to convert FuncKeyMapping.destination as relationship
        self.keys = kwargs.pop('keys', {})
        super().__init__(**kwargs)

    def get(self, position):
        if position not in self.keys:
            raise errors.not_found('FuncKey', template_id=self.id, position=position)
        return self.keys[position]

    def merge(self, other):
        keys = dict(self.keys)
        keys.update(other.keys)
        merged_template = FuncKeyTemplate(name=self.name)
        merged_template.keys = keys
        return merged_template

----------------------------------------

File: alchemy/func_key_type.py
Please review for update

# Copyright 2023 Accent Communications


from sqlalchemy import sql
from sqlalchemy.schema import Column
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class FuncKeyType(Base):
    __tablename__ = 'func_key_type'

    id = Column(Integer, primary_key=True)
    name = Column(String(128), nullable=False)

    @classmethod
    def query_id(cls, name):
        return sql.select([cls.id]).where(cls.name == name)

----------------------------------------

File: alchemy/groupfeatures.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.orm.collections import attribute_mapped_collection
from sqlalchemy.schema import Column, ForeignKey, Index, PrimaryKeyConstraint
from sqlalchemy.sql import (
    cast,
    select,
)
from sqlalchemy.types import Integer, String, Text

from accent_dao.helpers.db_manager import Base

from .callerid import Callerid
from .extension import Extension
from .queue import Queue
from .rightcallmember import RightCallMember
from .schedulepath import SchedulePath


class GroupFeatures(Base):
    __tablename__ = 'groupfeatures'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('groupfeatures__idx__name', 'name'),
        Index('groupfeatures__idx__uuid', 'uuid'),
        Index('groupfeatures__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer)
    uuid = Column(
        UUID(as_uuid=True), server_default=text('uuid_generate_v4()'), nullable=False
    )
    tenant_uuid = Column(
        String(36), ForeignKey('tenant.uuid', ondelete='CASCADE'), nullable=False
    )
    name = Column(String(128), nullable=False)
    label = Column(Text, nullable=False)
    transfer_user = Column(Integer, nullable=False, server_default='0')
    transfer_call = Column(Integer, nullable=False, server_default='0')
    write_caller = Column(Integer, nullable=False, server_default='0')
    write_calling = Column(Integer, nullable=False, server_default='0')
    ignore_forward = Column(Integer, nullable=False, server_default='1')
    timeout = Column(Integer)
    preprocess_subroutine = Column(String(79))
    mark_answered_elsewhere = Column(Integer, nullable=False, server_default='0')

    caller_id = relationship(
        'Callerid',
        primaryjoin="""and_(Callerid.type == 'group',
                            Callerid.typeval == GroupFeatures.id)""",
        foreign_keys='Callerid.typeval',
        cascade='all, delete-orphan',
        uselist=False,
    )

    caller_id_mode = association_proxy(
        'caller_id', 'mode', creator=lambda _mode: Callerid(type='group', mode=_mode)
    )
    caller_id_name = association_proxy(
        'caller_id', 'name', creator=lambda _name: Callerid(type='group', name=_name)
    )

    extensions = relationship(
        'Extension',
        primaryjoin="""and_(Extension.type == 'group',
                            Extension.typeval == cast(GroupFeatures.id, String))""",
        foreign_keys='Extension.typeval',
        viewonly=True,
    )

    incall_dialactions = relationship(
        'Dialaction',
        primaryjoin="""and_(Dialaction.category == 'incall',
                            Dialaction.action == 'group',
                            Dialaction.actionarg1 == cast(GroupFeatures.id, String))""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )

    incalls = association_proxy('incall_dialactions', 'incall')

    group_dialactions = relationship(
        'Dialaction',
        primaryjoin="""and_(Dialaction.category == 'group',
                            Dialaction.categoryval == cast(GroupFeatures.id, String))""",
        cascade='all, delete-orphan',
        collection_class=attribute_mapped_collection('event'),
        foreign_keys='Dialaction.categoryval',
    )

    user_queue_members = relationship(
        'QueueMember',
        primaryjoin="""and_(QueueMember.category == 'group',
                            not_(QueueMember.interface.startswith('Local/')),
                            QueueMember.queue_name == GroupFeatures.name)""",
        order_by='QueueMember.position',
        foreign_keys='QueueMember.queue_name',
        cascade='all, delete-orphan',
        passive_updates=False,
    )
    users = association_proxy('user_queue_members', 'user')

    extension_queue_members = relationship(
        'QueueMember',
        primaryjoin="""and_(QueueMember.category == 'group',
                            QueueMember.interface.startswith('Local/'),
                            QueueMember.queue_name == GroupFeatures.name)""",
        order_by='QueueMember.position',
        foreign_keys='QueueMember.queue_name',
        cascade='all, delete-orphan',
        passive_updates=False,
    )

    queue = relationship(
        'Queue',
        primaryjoin="""and_(Queue.category == 'group',
                            Queue.name == GroupFeatures.name)""",
        foreign_keys='Queue.name',
        cascade='all, delete-orphan',
        uselist=False,
        passive_updates=False,
    )

    _dialaction_actions = relationship(
        'Dialaction',
        primaryjoin="""and_(Dialaction.action == 'group',
                            Dialaction.actionarg1 == cast(GroupFeatures.id, String))""",
        foreign_keys='Dialaction.actionarg1',
        cascade='all, delete-orphan',
    )

    enabled = association_proxy('queue', 'enabled')
    music_on_hold = association_proxy('queue', 'musicclass')
    retry_delay = association_proxy('queue', 'retry')
    ring_in_use = association_proxy('queue', 'ring_in_use')
    ring_strategy = association_proxy('queue', 'strategy')
    user_timeout = association_proxy('queue', 'timeout')
    max_calls = association_proxy('queue', 'maxlen')

    func_keys_group = relationship(
        'FuncKeyDestGroup',
        cascade='all, delete-orphan',
    )

    func_keys_group_member = relationship(
        'FuncKeyDestGroupMember',
        cascade='all, delete-orphan',
    )

    schedule_paths = relationship(
        'SchedulePath',
        primaryjoin="""and_(SchedulePath.path == 'group',
                            SchedulePath.pathid == GroupFeatures.id)""",
        foreign_keys='SchedulePath.pathid',
        cascade='all, delete-orphan',
    )

    schedules = association_proxy(
        'schedule_paths',
        'schedule',
        creator=lambda _schedule: SchedulePath(
            path='group', schedule_id=_schedule.id, schedule=_schedule
        ),
    )
    rightcall_members = relationship(
        'RightCallMember',
        primaryjoin="""and_(RightCallMember.type == 'group',
        RightCallMember.typeval == cast(GroupFeatures.id, String))""",
        foreign_keys='RightCallMember.typeval',
        cascade='all, delete-orphan',
    )
    call_permissions = association_proxy(
        'rightcall_members',
        'rightcall',
        creator=lambda _call_permission: RightCallMember(
            type='group', typeval=str(_call_permission.id), rightcall=_call_permission
        ),
    )

    call_pickup_interceptors = relationship(
        'PickupMember',
        primaryjoin="""and_(PickupMember.category == 'member',
                            PickupMember.membertype == 'group',
                            PickupMember.memberid == GroupFeatures.id)""",
        foreign_keys='PickupMember.memberid',
        cascade='delete, delete-orphan',
    )

    call_pickup_targets = relationship(
        'PickupMember',
        primaryjoin="""and_(PickupMember.category == 'pickup',
                            PickupMember.membertype == 'group',
                            PickupMember.memberid == GroupFeatures.id)""",
        foreign_keys='PickupMember.memberid',
        cascade='delete, delete-orphan',
    )

    call_pickup_interceptor_pickups = relationship(
        'Pickup',
        primaryjoin="""and_(
            PickupMember.category == 'member',
            PickupMember.membertype == 'group',
            PickupMember.memberid == GroupFeatures.id
        )""",
        secondary="join(PickupMember, Pickup, Pickup.id == PickupMember.pickupid)",
        secondaryjoin="Pickup.id == PickupMember.pickupid",
        foreign_keys='PickupMember.pickupid,PickupMember.memberid',
        viewonly=True,
    )
    users_from_call_pickup_user_targets = association_proxy(
        'call_pickup_interceptor_pickups',
        'user_targets',
    )
    users_from_call_pickup_group_targets = association_proxy(
        'call_pickup_interceptor_pickups',
        'users_from_group_targets',
    )

    def __init__(self, **kwargs):
        retry = kwargs.pop('retry_delay', 5)
        ring_in_use = kwargs.pop('ring_in_use', True)
        strategy = kwargs.pop('ring_strategy', 'ringall')
        timeout = kwargs.pop('user_timeout', 15)
        musicclass = kwargs.pop('music_on_hold', None)
        enabled = kwargs.pop('enabled', True)
        max_calls = kwargs.pop('max_calls', 0)
        super().__init__(**kwargs)
        if not self.queue:
            self.queue = Queue(
                retry=retry,
                ring_in_use=ring_in_use,
                strategy=strategy,
                timeout=timeout,
                musicclass=musicclass,
                enabled=enabled,
                queue_youarenext='queue-youarenext',
                queue_thereare='queue-thereare',
                queue_callswaiting='queue-callswaiting',
                queue_holdtime='queue-holdtime',
                queue_minutes='queue-minutes',
                queue_seconds='queue-seconds',
                queue_thankyou='queue-thankyou',
                queue_reporthold='queue-reporthold',
                periodic_announce='queue-periodic-announce',
                announce_frequency=0,
                periodic_announce_frequency=0,
                announce_round_seconds=0,
                announce_holdtime='no',
                wrapuptime=0,
                maxlen=max_calls,
                memberdelay=0,
                weight=0,
                category='group',
                autofill=1,
                announce_position='no',
            )

    @property
    def fallbacks(self):
        return self.group_dialactions

    # Note: fallbacks[key] = Dialaction() doesn't pass in this method
    @fallbacks.setter
    def fallbacks(self, dialactions):
        for event in list(self.group_dialactions.keys()):
            if event not in dialactions:
                self.group_dialactions.pop(event, None)

        for event, dialaction in dialactions.items():
            if dialaction is None:
                self.group_dialactions.pop(event, None)
                continue

            if event not in self.group_dialactions:
                dialaction.category = 'group'
                dialaction.event = event
                self.group_dialactions[event] = dialaction

            self.group_dialactions[event].action = dialaction.action
            self.group_dialactions[event].actionarg1 = dialaction.actionarg1
            self.group_dialactions[event].actionarg2 = dialaction.actionarg2

    @hybrid_property
    def mark_answered_elsewhere_bool(self):
        return self.mark_answered_elsewhere == 1

    @mark_answered_elsewhere_bool.setter
    def mark_answered_elsewhere_bool(self, value):
        self.mark_answered_elsewhere = int(value is True)

    @hybrid_property
    def exten(self):
        for extension in self.extensions:
            return extension.exten
        return None

    @exten.expression
    def exten(cls):
        return (
            select([Extension.exten])
            .where(Extension.type == 'group')
            .where(Extension.typeval == cast(cls.id, String))
            .as_scalar()
        )

----------------------------------------

File: alchemy/iaxcallnumberlimits.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class IAXCallNumberLimits(Base):

    __tablename__ = 'iaxcallnumberlimits'

    id = Column(Integer, primary_key=True)
    destination = Column(String(39), nullable=False)
    netmask = Column(String(39), nullable=False)
    calllimits = Column(Integer, nullable=False, server_default='0')

----------------------------------------

File: alchemy/incall.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
)
from sqlalchemy.sql import (
    cast,
    select,
)
from sqlalchemy.types import (
    Boolean,
    Integer,
    String,
    Text,
)

from accent_dao.alchemy.callerid import Callerid
from accent_dao.alchemy.dialaction import Dialaction
from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.schedulepath import SchedulePath
from accent_dao.helpers.db_manager import Base


class Incall(Base):
    __tablename__ = 'incall'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('incall__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )

    # NOTE: This field is a workaround and must not be exposed to the API.
    main = Column(Boolean, nullable=False, server_default='false')

    preprocess_subroutine = Column(String(79))
    greeting_sound = Column(Text)
    commented = Column(Integer, nullable=False, server_default='0')
    description = Column(Text)

    caller_id = relationship(
        'Callerid',
        primaryjoin="""and_(Callerid.type == 'incall',
                            Callerid.typeval == Incall.id)""",
        foreign_keys='Callerid.typeval',
        cascade='all, delete-orphan',
        uselist=False,
    )

    caller_id_mode = association_proxy(
        'caller_id',
        'mode',
        creator=lambda _mode: Callerid(type='incall', mode=_mode),
    )
    caller_id_name = association_proxy(
        'caller_id',
        'name',
        creator=lambda _name: Callerid(type='incall', name=_name),
    )

    dialaction = relationship(
        'Dialaction',
        primaryjoin="""and_(Dialaction.category == 'incall',
                            Dialaction.categoryval == cast(Incall.id, String))""",
        foreign_keys='Dialaction.categoryval',
        cascade='all, delete-orphan',
        uselist=False,
    )

    extensions = relationship(
        'Extension',
        primaryjoin="""and_(Extension.type == 'incall',
                            Extension.typeval == cast(Incall.id, String))""",
        foreign_keys='Extension.typeval',
        viewonly=True,
    )

    schedule_paths = relationship(
        'SchedulePath',
        primaryjoin="""and_(SchedulePath.path == 'incall',
                            SchedulePath.pathid == Incall.id)""",
        foreign_keys='SchedulePath.pathid',
        cascade='all, delete-orphan',
    )

    schedules = association_proxy(
        'schedule_paths',
        'schedule',
        creator=lambda _schedule: SchedulePath(
            path='incall',
            schedule_id=_schedule.id,
            schedule=_schedule,
        ),
    )

    @property
    def destination(self):
        if self.dialaction is None:
            return Dialaction(action='none')
        return self.dialaction

    @destination.setter
    def destination(self, destination):
        if destination is None:
            self.dialaction = None
            return

        if not self.dialaction:
            destination.event = 'answer'
            destination.category = 'incall'
            self.dialaction = destination

        self.dialaction.action = destination.action
        self.dialaction.actionarg1 = destination.actionarg1
        self.dialaction.actionarg2 = destination.actionarg2

    @hybrid_property
    def user_id(self):
        if self.dialaction and self.dialaction.action == 'user':
            return int(self.dialaction.actionarg1)
        return None

    @user_id.expression
    def user_id(cls):
        return (
            select([cast(Dialaction.actionarg1, Integer)])
            .where(Dialaction.action == 'user')
            .where(Dialaction.category == 'incall')
            .where(Dialaction.categoryval == cast(cls.id, String))
            .as_scalar()
        )

    @hybrid_property
    def exten(self):
        for extension in self.extensions:
            return extension.exten
        return None

    @exten.expression
    def exten(cls):
        return (
            select([Extension.exten])
            .where(Extension.type == 'incall')
            .where(Extension.typeval == cast(cls.id, String))
            .as_scalar()
        )

----------------------------------------

File: alchemy/infos.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql.schema import Column, PrimaryKeyConstraint
from sqlalchemy.types import Boolean, String

from accent_dao.helpers.db_manager import Base
from accent_dao.helpers.uuid import new_uuid


class Infos(Base):
    __tablename__ = 'infos'
    __table_args__ = (
        PrimaryKeyConstraint('uuid'),
    )

    uuid = Column(String(38), nullable=False, default=new_uuid)
    accent_version = Column(String(64), nullable=False)
    live_reload_enabled = Column(Boolean, nullable=False, server_default='True')
    timezone = Column(String(128))
    configured = Column(Boolean, nullable=False, server_default='False')

----------------------------------------

File: alchemy/ingress_http.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import Column, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.schema import ForeignKey, Index
from sqlalchemy.types import String, Text

from accent_dao.helpers.db_manager import Base


class IngressHTTP(Base):
    __tablename__ = 'ingress_http'
    __table_args__ = (Index('ingress_http__idx__tenant_uuid', 'tenant_uuid'),)

    uuid = Column(
        UUID(as_uuid=True),
        server_default=text('uuid_generate_v4()'),
        primary_key=True,
    )
    uri = Column(Text, nullable=False)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        unique=True,
        nullable=False,
    )

----------------------------------------

File: alchemy/ivr.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.orm import relationship
from sqlalchemy.orm.collections import attribute_mapped_collection
from sqlalchemy.schema import Column, ForeignKey, Index, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String, Text

from accent_dao.alchemy.dialaction import Dialaction
from accent_dao.alchemy.ivr_choice import IVRChoice
from accent_dao.helpers.db_manager import Base


class IVR(Base):
    __tablename__ = 'ivr'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('ivr__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer)
    tenant_uuid = Column(
        String(36), ForeignKey('tenant.uuid', ondelete='CASCADE'), nullable=False
    )
    name = Column(String(128), nullable=False)
    greeting_sound = Column(Text)
    menu_sound = Column(Text, nullable=False)
    invalid_sound = Column(Text)
    abort_sound = Column(Text)
    timeout = Column(Integer, nullable=False, server_default='5')
    max_tries = Column(Integer, nullable=False, server_default='3')
    description = Column(Text)

    dialactions = relationship(
        Dialaction,
        primaryjoin="""and_(
            Dialaction.category == 'ivr',
            Dialaction.categoryval == cast(IVR.id, String)
        )""",
        foreign_keys='Dialaction.categoryval',
        collection_class=attribute_mapped_collection('event'),
        cascade='all, delete-orphan',
    )

    choices = relationship(
        IVRChoice,
        cascade='all, delete-orphan',
    )

    incall_dialactions = relationship(
        'Dialaction',
        primaryjoin="""and_(
            Dialaction.category == 'incall',
            Dialaction.action == 'ivr',
            Dialaction.actionarg1 == cast(IVR.id, String)
        )""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )

    incalls = association_proxy('incall_dialactions', 'incall')

    _dialaction_actions = relationship(
        Dialaction,
        primaryjoin="""and_(
            Dialaction.action == 'ivr',
            Dialaction.actionarg1 == cast(IVR.id, String),
        )""",
        foreign_keys='Dialaction.actionarg1',
        cascade='all, delete-orphan',
    )

    @property
    def invalid_destination(self):
        return self.dialactions.get('invalid')

    @invalid_destination.setter
    def invalid_destination(self, destination):
        self._set_dialaction('invalid', destination)

    @property
    def timeout_destination(self):
        return self.dialactions.get('timeout')

    @timeout_destination.setter
    def timeout_destination(self, destination):
        self._set_dialaction('timeout', destination)

    @property
    def abort_destination(self):
        return self.dialactions.get('abort')

    @abort_destination.setter
    def abort_destination(self, destination):
        self._set_dialaction('abort', destination)

    def _set_dialaction(self, event, dialaction):
        if dialaction is None:
            self.dialactions.pop(event, None)
            return

        if event not in self.dialactions:
            dialaction.event = event
            dialaction.category = 'ivr'
            self.dialactions[event] = dialaction

        self.dialactions[event].action = dialaction.action
        self.dialactions[event].actionarg1 = dialaction.actionarg1
        self.dialactions[event].actionarg2 = dialaction.actionarg2

----------------------------------------

File: alchemy/ivr_choice.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String

from accent_dao.alchemy.dialaction import Dialaction
from accent_dao.helpers.db_manager import Base


class IVRChoice(Base):
    __tablename__ = 'ivr_choice'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('ivr_choice__idx__ivr_id', 'ivr_id'),
    )

    id = Column(Integer)
    ivr_id = Column(Integer, ForeignKey('ivr.id', ondelete='CASCADE'), nullable=False)
    exten = Column(String(40), nullable=False)

    dialaction = relationship(
        Dialaction,
        primaryjoin="""and_(Dialaction.category == 'ivr_choice',
                            Dialaction.categoryval == cast(IVRChoice.id, String))""",
        foreign_keys='Dialaction.categoryval',
        cascade='all, delete-orphan',
        back_populates='ivr_choice',
        uselist=False,
    )

    @property
    def destination(self):
        return self.dialaction

    @destination.setter
    def destination(self, destination):
        if not self.dialaction:
            destination.event = 'ivr_choice'
            destination.category = 'ivr_choice'
            self.dialaction = destination

        self.dialaction.action = destination.action
        self.dialaction.actionarg1 = destination.actionarg1
        self.dialaction.actionarg2 = destination.actionarg2

----------------------------------------

File: alchemy/line_extension.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
)
from sqlalchemy.types import Boolean, Integer

from accent_dao.helpers.db_manager import Base


class LineExtension(Base):
    __tablename__ = 'line_extension'
    __table_args__ = (
        PrimaryKeyConstraint('line_id', 'extension_id'),
        Index('line_extension__idx__line_id', 'line_id'),
        Index('line_extension__idx__extension_id', 'extension_id'),
    )

    line_id = Column(
        Integer, ForeignKey('linefeatures.id', ondelete='CASCADE'), nullable=False
    )
    extension_id = Column(
        Integer, ForeignKey('extensions.id', ondelete='CASCADE'), nullable=False
    )
    main_extension = Column(Boolean, nullable=False)

    linefeatures = relationship("LineFeatures")
    extensions = relationship("Extension")

    main_extension_rel = relationship(
        "Extension",
        primaryjoin="and_(LineExtension.extension_id == Extension.id, LineExtension.main_extension == True)",
    )

    line = relationship('LineFeatures', back_populates='line_extensions')

    extension = relationship('Extension')

----------------------------------------

File: alchemy/linefeatures.py
Please review for update

# Copyright 2023 Accent Communications

import re

from sqlalchemy import ForeignKeyConstraint, func, sql
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql.expression import bindparam, select
from sqlalchemy.types import (
    Integer,
    String,
    Text,
)

from accent_dao.helpers.db_manager import Base
from accent_dao.helpers.exception import InputError

from .context import Context
from .endpoint_sip_options_view import EndpointSIPOptionsView
from .sccpline import SCCPLine

caller_id_regex = re.compile(
    r'''
    "                      #name start
    (?P<name>[^"]+)        #inside ""
    "                      #name end
    \s+                    #space between name and number
    (
    <                      #number start
    (?P<num>\+?[\dA-Z]+)   #inside <>
    >                      #number end
    )?                     #number is optional
    ''',
    re.VERBOSE,
)


class LineFeatures(Base):
    CALLER_ID = '"{name}" <{num}>'

    __tablename__ = 'linefeatures'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('name'),
        CheckConstraint(
            '''
            ( CASE WHEN endpoint_sip_uuid IS NULL THEN 0 ELSE 1 END
            + CASE WHEN endpoint_sccp_id IS NULL THEN 0 ELSE 1 END
            + CASE WHEN endpoint_custom_id IS NULL THEN 0 ELSE 1 END
            ) <= 1
            ''',
            name='linefeatures_endpoints_check',
        ),
        Index('linefeatures__idx__context', 'context'),
        Index('linefeatures__idx__device', 'device'),
        Index('linefeatures__idx__number', 'number'),
        Index('linefeatures__idx__provisioningid', 'provisioningid'),
        Index('linefeatures__idx__endpoint_sccp_id', 'endpoint_sccp_id'),
        Index('linefeatures__idx__endpoint_custom_id', 'endpoint_custom_id'),
        Index('linefeatures__idx__application_uuid', 'application_uuid'),
        Index('linefeatures__idx__endpoint_sip_uuid', 'endpoint_sip_uuid'),
        ForeignKeyConstraint(
            ('context',),
            ('context.name',),
            ondelete='CASCADE',
        ),
    )

    id = Column(Integer)
    device = Column(String(32))
    configregistrar = Column(String(128))
    name = Column(String(128))
    number = Column(String(40))
    context = Column(String(79), nullable=False)
    provisioningid = Column(Integer, nullable=False)
    num = Column(Integer, server_default='1')
    ipfrom = Column(String(15))
    application_uuid = Column(
        String(36), ForeignKey('application.uuid', ondelete='SET NULL')
    )
    commented = Column(Integer, nullable=False, server_default='0')
    description = Column(Text)

    endpoint_sip_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey('endpoint_sip.uuid', ondelete='SET NULL'),
    )
    endpoint_sccp_id = Column(Integer, ForeignKey('sccpline.id', ondelete='SET NULL'))
    endpoint_custom_id = Column(
        Integer, ForeignKey('usercustom.id', ondelete='SET NULL')
    )

    context_rel = relationship(
        'Context',
        primaryjoin='LineFeatures.context == Context.name',
        foreign_keys='LineFeatures.context',
        viewonly=True,
    )

    application = relationship('Application', viewonly=True)

    endpoint_sip = relationship('EndpointSIP', viewonly=True)
    endpoint_sccp = relationship('SCCPLine', viewonly=True)
    endpoint_custom = relationship('UserCustom', viewonly=True)

    line_extensions = relationship(
        'LineExtension',
        order_by='desc(LineExtension.main_extension)',
        cascade='all, delete-orphan',
        back_populates='line',
    )

    extensions = association_proxy('line_extensions', 'extension')

    user_lines = relationship(
        'UserLine',
        order_by='desc(UserLine.main_user)',
        cascade='all, delete-orphan',
        back_populates='line',
    )

    users = association_proxy('user_lines', 'user')

    @hybrid_property
    def protocol(self):
        if self.endpoint_sip_uuid:
            return 'sip'
        elif self.endpoint_sccp_id:
            return 'sccp'
        elif self.endpoint_custom_id:
            return 'custom'

    @protocol.expression
    def protocol(cls):
        return sql.case(
            [
                (cls.endpoint_sip_uuid.isnot(None), 'sip'),
                (cls.endpoint_sccp_id.isnot(None), 'sccp'),
                (cls.endpoint_custom_id.isnot(None), 'custom'),
            ],
            else_=None,
        )

    @hybrid_property
    def caller_id_name(self):
        if self.endpoint_sip:
            return self._sip_caller_id_name()
        elif self.endpoint_sccp:
            return self._sccp_caller_id_name()

    def _sip_caller_id_name(self):
        if not self.endpoint_sip:
            return None

        for key, value in self.endpoint_sip.endpoint_section_options:
            if key != 'callerid':
                continue

            match = caller_id_regex.match(value)
            if not match:
                return None

            return match.group('name')

    def _sccp_caller_id_name(self):
        return self.endpoint_sccp.cid_name

    @caller_id_name.expression
    def caller_id_name(cls):
        regex = '"([^"]+)"\\s+'

        return sql.case(
            [
                (
                    cls.endpoint_sip_uuid.isnot(None),
                    cls._sip_query_option('callerid', regex_filter=regex),
                ),
                (cls.endpoint_sccp_id.isnot(None), cls._sccp_query_option('cid_name')),
            ],
            else_=None,
        )

    @caller_id_name.setter
    def caller_id_name(self, value):
        if value is None:
            if (
                self.endpoint_sip_uuid
                or self.endpoint_sccp_id
                or self.endpoint_custom_id
            ):
                raise InputError("Cannot set caller id to None")
            return

        if self.endpoint_sip_uuid:
            self._set_sip_caller_id_name(value)
        elif self.endpoint_sccp_id:
            self._set_sccp_caller_id_name(value)
        elif self.endpoint_custom_id:
            raise InputError("Cannot set caller id on endpoint of type 'custom'")
        else:
            raise InputError("Cannot set caller id if no endpoint associated")

    def _set_sip_caller_id_name(self, value):
        num = self._sip_caller_id_num()
        callerid = self.CALLER_ID.format(name=value, num=num)
        self.endpoint_sip.caller_id = callerid

    def _set_sccp_caller_id_name(self, value):
        self.endpoint_sccp.cid_name = value

    @hybrid_property
    def caller_id_num(self):
        if self.endpoint_sip:
            return self._sip_caller_id_num()
        elif self.endpoint_sccp:
            return self._sccp_caller_id_num()

    def _sip_caller_id_num(self):
        if not self.endpoint_sip_uuid:
            return None

        for key, option in self.endpoint_sip.endpoint_section_options:
            if key != 'callerid':
                continue

            match = caller_id_regex.match(option)
            if not match:
                return None

            return match.group('num')

    def _sccp_caller_id_num(self):
        return self.endpoint_sccp.cid_num

    @caller_id_num.expression
    def caller_id_num(cls):
        regex = '<([0-9A-Z]+)?>'

        return sql.case(
            [
                (
                    cls.endpoint_sip_uuid.isnot(None),
                    cls._sip_query_option('callerid', regex_filter=regex),
                ),
                (cls.endpoint_sccp_id.isnot(None), cls._sccp_query_option('cid_num')),
            ]
        )

    @caller_id_num.setter
    def caller_id_num(self, value):
        if value is None:
            if (
                self.endpoint_sip_uuid
                or self.endpoint_sccp_id
                or self.endpoint_custom_id
            ):
                raise InputError("Cannot set caller id num to None")
            return

        if self.endpoint_sip_uuid:
            self._set_sip_caller_id_num(value)
        elif self.endpoint_sccp_id:
            raise InputError("Cannot set caller id num on endpoint of type 'sccp'")
        elif self.endpoint_custom_id:
            raise InputError("Cannot set caller id on endpoint of type 'custom'")
        else:
            raise InputError("Cannot set caller id if no endpoint associated")

    def _set_sip_caller_id_num(self, value):
        name = self._sip_caller_id_name()
        callerid = self.CALLER_ID.format(name=name, num=value)
        self.endpoint_sip.caller_id = callerid

    @hybrid_property
    def provisioning_extension(self):
        return self.provisioning_code

    @hybrid_property
    def provisioning_code(self):
        if self.provisioningid is None:
            return None
        return str(self.provisioningid)

    @provisioning_code.expression
    def provisioning_code(cls):
        return sql.cast(sql.func.nullif(cls.provisioningid, 0), String)

    @provisioning_code.setter
    def provisioning_code(self, value):
        if value is None:
            self.provisioningid = None
        elif value.isdigit():
            self.provisioningid = int(value)

    @hybrid_property
    def position(self):
        return self.num

    @position.setter
    def position(self, value):
        self.num = value

    @hybrid_property
    def device_slot(self):
        return self.num

    @hybrid_property
    def device_id(self):
        if self.device == '':
            return None
        return self.device

    @device_id.expression
    def device_id(cls):
        return sql.func.nullif(cls.device, '')

    @device_id.setter
    def device_id(self, value):
        value = value or ''
        self.device = value

    @hybrid_property
    def tenant_uuid(self):
        return self.context_rel.tenant_uuid

    @tenant_uuid.expression
    def tenant_uuid(cls):
        return (
            sql.select([Context.tenant_uuid])
            .where(
                Context.name == cls.context,
            )
            .label('tenant_uuid')
        )

    @hybrid_property
    def registrar(self):
        return self.configregistrar

    @registrar.setter
    def registrar(self, value):
        self.configregistrar = value

    def is_associated(self):
        return (
            self.endpoint_sip_uuid or self.endpoint_sccp_id or self.endpoint_custom_id
        )

    def update_extension(self, extension):
        self.number = extension.exten
        self.context = extension.context

    def clear_extension(self):
        self.number = None

    def update_name(self):
        if self.endpoint_sip and self.endpoint_sip.name not in ("", None):
            self.name = self.endpoint_sip.name
        elif self.endpoint_sccp and self.endpoint_sccp.name not in ("", None):
            self.name = self.endpoint_sccp.name
        elif self.endpoint_custom and self.endpoint_custom.interface not in ("", None):
            self.name = self.endpoint_custom.interface
        else:
            self.name = None

    def associate_device(self, device):
        self.device = device.id

    def remove_device(self):
        self.device = ''

    @classmethod
    def _sip_query_option(cls, option, regex_filter=None):
        attr = EndpointSIPOptionsView.get_option_value(option)
        if regex_filter:
            attr = func.unnest(
                func.regexp_matches(
                    attr, bindparam('regexp', regex_filter, unique=True)
                )
            )

        return (
            select([attr])
            .where(EndpointSIPOptionsView.root == cls.endpoint_sip_uuid)
            .as_scalar()
        )

    @classmethod
    def _sccp_query_option(cls, option):
        if option not in dir(SCCPLine):
            return

        return (
            select([getattr(SCCPLine, option)])
            .where(SCCPLine.id == cls.endpoint_sccp_id)
            .as_scalar()
        )

----------------------------------------

File: alchemy/mail.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, PrimaryKeyConstraint, UniqueConstraint
from sqlalchemy.types import Integer, String, Text

from accent_dao.helpers.db_manager import Base


class Mail(Base):
    __tablename__ = 'mail'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('origin'),
    )

    id = Column(Integer, nullable=False)
    mydomain = Column(String(255), nullable=False, server_default='0')
    origin = Column(
        String(255), nullable=False, server_default='accent-clients.accentvoice.io'
    )
    relayhost = Column(String(255))
    fallback_relayhost = Column(String(255))
    canonical = Column(Text, nullable=False)

----------------------------------------

File: alchemy/meeting.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, UniqueConstraint
from sqlalchemy.sql.schema import ForeignKey, Index
from sqlalchemy.types import Boolean, DateTime, String, Text

from accent_dao.helpers.datetime import utcnow_with_tzinfo
from accent_dao.helpers.db_manager import Base


class MeetingOwner(Base):
    __tablename__ = 'meeting_owner'

    meeting_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey('meeting.uuid', ondelete='CASCADE'),
        primary_key=True,
    )
    user_uuid = Column(
        String(38),  # 38 is copied from userfeatures.uuid
        ForeignKey('userfeatures.uuid', ondelete='CASCADE'),
        primary_key=True,
    )

    owner = relationship('UserFeatures', foreign_keys='MeetingOwner.user_uuid')


class Meeting(Base):
    __tablename__ = 'meeting'
    __table_args__ = (
        UniqueConstraint('number', 'tenant_uuid'),
        Index('meeting__idx__guest_endpoint_sip_uuid', 'guest_endpoint_sip_uuid'),
        Index('meeting__idx__tenant_uuid', 'tenant_uuid'),
    )

    uuid = Column(
        UUID(as_uuid=True), server_default=text('uuid_generate_v4()'), primary_key=True
    )
    name = Column(Text)
    guest_endpoint_sip_uuid = Column(
        UUID(as_uuid=True), ForeignKey('endpoint_sip.uuid', ondelete='SET NULL')
    )
    tenant_uuid = Column(
        String(36), ForeignKey('tenant.uuid', ondelete='CASCADE'), nullable=False
    )
    created_at = Column(
        DateTime(timezone=True),
        default=utcnow_with_tzinfo,
        server_default=text("(now() at time zone 'utc')"),
    )
    persistent = Column(Boolean, server_default='false', nullable=False)
    number = Column(Text, nullable=False)
    require_authorization = Column(Boolean, server_default='false', nullable=False)

    meeting_owners = relationship(
        'MeetingOwner',
        cascade='all, delete-orphan',
    )
    owners = association_proxy(
        'meeting_owners', 'owner', creator=lambda owner: MeetingOwner(owner=owner)
    )
    guest_endpoint_sip = relationship(
        'EndpointSIP',
        cascade='all, delete-orphan',
        single_parent=True,
    )
    ingress_http = relationship(
        'IngressHTTP',
        foreign_keys='IngressHTTP.tenant_uuid',
        uselist=False,
        viewonly=True,
        primaryjoin='Meeting.tenant_uuid == IngressHTTP.tenant_uuid',
    )
    meeting_authorizations = relationship(
        'MeetingAuthorization',
        primaryjoin='MeetingAuthorization.meeting_uuid == Meeting.uuid',
        foreign_keys='MeetingAuthorization.meeting_uuid',
        cascade='all, delete-orphan',
    )

    @property
    def owner_uuids(self):
        return [owner.uuid for owner in self.owners]

----------------------------------------

File: alchemy/meeting_authorization.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column
from sqlalchemy.sql.schema import ForeignKey, Index
from sqlalchemy.types import DateTime, Text

from accent_dao.helpers.datetime import utcnow_with_tzinfo
from accent_dao.helpers.db_manager import Base


class MeetingAuthorization(Base):
    __tablename__ = 'meeting_authorization'
    __table_args__ = (
        Index('meeting_authorization__idx__guest_uuid', 'guest_uuid'),
        Index('meeting_authorization__idx__meeting_uuid', 'meeting_uuid'),
    )

    uuid = Column(
        UUID(as_uuid=True), server_default=text('uuid_generate_v4()'), primary_key=True
    )
    guest_uuid = Column(UUID(as_uuid=True), nullable=False)
    meeting_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey('meeting.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    guest_name = Column(Text)
    status = Column(Text)
    created_at = Column(
        DateTime(timezone=True),
        default=utcnow_with_tzinfo,
        server_default=text("(now() at time zone 'utc')"),
    )

    meeting = relationship(
        'Meeting',
        primaryjoin='Meeting.uuid == MeetingAuthorization.meeting_uuid',
        foreign_keys='MeetingAuthorization.meeting_uuid',
        viewonly=True,
    )
    guest_endpoint_sip = relationship(
        'EndpointSIP',
        secondary='meeting',
        secondaryjoin='EndpointSIP.uuid == Meeting.guest_endpoint_sip_uuid',
        primaryjoin='MeetingAuthorization.meeting_uuid == Meeting.uuid',
        viewonly=True,
        uselist=False,
    )

----------------------------------------

File: alchemy/moh.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import (
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.types import String, Text

from accent_dao.helpers.db_manager import Base
from accent_dao.helpers.uuid import new_uuid


class MOH(Base):

    __tablename__ = 'moh'
    __table_args__ = (
        PrimaryKeyConstraint('uuid'),
        UniqueConstraint('name'),
        Index('moh__idx__tenant_uuid', 'tenant_uuid'),
    )

    uuid = Column(String(38), nullable=False, default=new_uuid)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(Text, nullable=False)
    label = Column(Text, nullable=False)
    mode = Column(Text, nullable=False)
    application = Column(Text)
    sort = Column(Text)

----------------------------------------

File: alchemy/netiface.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, PrimaryKeyConstraint, UniqueConstraint
from sqlalchemy.types import Enum, Integer, String, Text

from accent_dao.alchemy import enum
from accent_dao.helpers.db_manager import Base


class Netiface(Base):
    __tablename__ = 'netiface'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('ifname'),
    )

    id = Column(Integer, nullable=False)
    ifname = Column(String(64), nullable=False, server_default='')
    hwtypeid = Column(Integer, nullable=False, server_default='65534')
    networktype = Column(
        Enum('data', 'voip', name='netiface_networktype', metadata=Base.metadata),
        nullable=False,
    )
    type = Column(enum.netiface_type, nullable=False)
    family = Column(
        Enum('inet', 'inet6', name='netiface_family', metadata=Base.metadata),
        nullable=False,
    )
    method = Column(
        Enum('static', 'dhcp', 'manual', name='netiface_method', metadata=Base.metadata)
    )
    address = Column(String(39))
    netmask = Column(String(39))
    broadcast = Column(String(15))
    gateway = Column(String(39))
    mtu = Column(Integer)
    vlanrawdevice = Column(String(64))
    vlanid = Column(Integer)
    options = Column(Text, nullable=False)
    disable = Column(Integer, nullable=False, server_default='0')
    dcreate = Column(Integer, nullable=False, server_default='0')
    description = Column(Text)

----------------------------------------

File: alchemy/outcall.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.ext.orderinglist import ordering_list
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import (
    cast,
    func,
    not_,
)
from sqlalchemy.types import (
    Boolean,
    Integer,
    String,
    Text,
)

from accent_dao.alchemy.dialpattern import DialPattern
from accent_dao.alchemy.outcalltrunk import OutcallTrunk
from accent_dao.alchemy.rightcallmember import RightCallMember
from accent_dao.alchemy.schedulepath import SchedulePath
from accent_dao.helpers.db_manager import Base


class Outcall(Base):
    __tablename__ = 'outcall'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('name'),
        Index('outcall__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer, nullable=False)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(128), nullable=False)
    context = Column(String(79))
    internal = Column(Integer, nullable=False, server_default='0')
    preprocess_subroutine = Column(String(79))
    hangupringtime = Column(Integer, nullable=False, server_default='0')
    commented = Column(Integer, nullable=False, server_default='0')
    description = Column(Text)

    dialpatterns = relationship(
        'DialPattern',
        primaryjoin="""and_(DialPattern.type == 'outcall',
                            DialPattern.typeid == Outcall.id)""",
        foreign_keys='DialPattern.typeid',
        cascade='all, delete-orphan',
    )

    extensions = association_proxy('dialpatterns', 'extension')

    outcall_trunks = relationship(
        'OutcallTrunk',
        order_by='OutcallTrunk.priority',
        collection_class=ordering_list('priority'),
        cascade='all, delete-orphan',
        back_populates='outcall',
    )

    trunks = association_proxy(
        'outcall_trunks',
        'trunk',
        creator=lambda _trunk: OutcallTrunk(trunk=_trunk),
    )

    _dialaction_actions = relationship(
        'Dialaction',
        primaryjoin="""and_(Dialaction.action == 'outcall',
                            Dialaction.actionarg1 == cast(Outcall.id, String))""",
        foreign_keys='Dialaction.actionarg1',
        cascade='all, delete-orphan',
    )

    schedule_paths = relationship(
        'SchedulePath',
        primaryjoin="""and_(SchedulePath.path == 'outcall',
                            SchedulePath.pathid == Outcall.id)""",
        foreign_keys='SchedulePath.pathid',
        cascade='all, delete-orphan',
    )
    schedules = association_proxy(
        'schedule_paths',
        'schedule',
        creator=lambda _schedule: SchedulePath(
            path='outcall',
            schedule_id=_schedule.id,
            schedule=_schedule,
        ),
    )

    rightcall_members = relationship(
        'RightCallMember',
        primaryjoin="""and_(RightCallMember.type == 'outcall',
                            RightCallMember.typeval == cast(Outcall.id, String))""",
        foreign_keys='RightCallMember.typeval',
        cascade='all, delete-orphan',
    )
    call_permissions = association_proxy(
        'rightcall_members',
        'rightcall',
        creator=lambda _call_permission: RightCallMember(
            type='outcall',
            typeval=str(_call_permission.id),
            rightcall=_call_permission,
        ),
    )

    @hybrid_property
    def internal_caller_id(self):
        return self.internal == 1

    @internal_caller_id.expression
    def internal_caller_id(cls):
        return cast(cls.internal, Boolean)

    @internal_caller_id.setter
    def internal_caller_id(self, value):
        self.internal = int(value == 1)

    @hybrid_property
    def ring_time(self):
        if self.hangupringtime == 0:
            return None
        return self.hangupringtime

    @ring_time.expression
    def ring_time(cls):
        return func.nullif(cls.hangupringtime, 0)

    @ring_time.setter
    def ring_time(self, value):
        if value is None:
            self.hangupringtime = 0
        else:
            self.hangupringtime = value

    @hybrid_property
    def enabled(self):
        return self.commented == 0

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False)

    def associate_extension(self, extension, **kwargs):
        if extension not in self.extensions:
            extension.type = 'outcall'
            dialpattern = DialPattern(type='outcall', exten=extension.exten, **kwargs)
            self.dialpatterns.append(dialpattern)
            index = self.dialpatterns.index(dialpattern)
            self.dialpatterns[index].extension = extension
            self._fix_context()

    def dissociate_extension(self, extension):
        if extension in self.extensions:
            self.extensions.remove(extension)
            extension.type = 'user'
            extension.typeval = '0'
            self._fix_context()

    def update_extension_association(self, extension, **kwargs):
        for dialpattern in self.dialpatterns:
            if extension == dialpattern.extension:
                dialpattern.strip_digits = kwargs.get(
                    'strip_digits', dialpattern.strip_digits
                )
                dialpattern.prefix = kwargs.get('prefix', dialpattern.prefix)
                dialpattern.external_prefix = kwargs.get(
                    'external_prefix', dialpattern.external_prefix
                )
                dialpattern.caller_id = kwargs.get('caller_id', dialpattern.caller_id)

    def _fix_context(self):
        for extension in self.extensions:
            self.context = extension.context
            return
        self.context = None

----------------------------------------

File: alchemy/outcalltrunk.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index, PrimaryKeyConstraint
from sqlalchemy.types import Integer

from accent_dao.helpers.db_manager import Base


class OutcallTrunk(Base):
    __tablename__ = 'outcalltrunk'
    __table_args__ = (
        PrimaryKeyConstraint('outcallid', 'trunkfeaturesid'),
        Index('outcalltrunk__idx__priority', 'priority'),
    )

    outcallid = Column(
        Integer, ForeignKey('outcall.id', ondelete='CASCADE'), nullable=False
    )
    trunkfeaturesid = Column(Integer, ForeignKey('trunkfeatures.id'), nullable=False)
    priority = Column(Integer, nullable=False, server_default='0')

    trunk = relationship('TrunkFeatures', back_populates='outcall_trunks')

    outcall = relationship('Outcall', back_populates='outcall_trunks')

    @hybrid_property
    def outcall_id(self):
        return self.outcallid

    @outcall_id.setter
    def outcall_id(self, value):
        self.outcallid = value

    @hybrid_property
    def trunk_id(self):
        return self.trunkfeaturesid

    @trunk_id.setter
    def trunk_id(self, value):
        self.trunkfeaturesid = value

----------------------------------------

File: alchemy/paging.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import cast, not_
from sqlalchemy.types import Boolean, Integer, String, Text

from accent_dao.helpers.db_manager import Base

from .paginguser import PagingUser


class Paging(Base):
    __tablename__ = 'paging'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('number'),
        Index('paging__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer, nullable=False)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    number = Column(String(32))
    name = Column(String(128))
    duplex = Column(Integer, nullable=False, server_default='0')
    ignore = Column(Integer, nullable=False, server_default='0')
    record = Column(Integer, nullable=False, server_default='0')
    quiet = Column(Integer, nullable=False, server_default='0')
    timeout = Column(Integer, nullable=False, server_default='30')
    announcement_file = Column(String(64))
    announcement_play = Column(Integer, nullable=False, server_default='0')
    announcement_caller = Column(Integer, nullable=False, server_default='0')
    commented = Column(Integer, nullable=False, server_default='0')
    description = Column(Text)

    paging_members = relationship(
        'PagingUser',
        primaryjoin="""and_(
            PagingUser.pagingid == Paging.id,
            PagingUser.caller == 0
        )""",
        cascade='all, delete-orphan',
    )

    users_member = association_proxy(
        'paging_members',
        'user',
        creator=lambda _user: PagingUser(user=_user, caller=0),
    )

    paging_callers = relationship(
        'PagingUser',
        primaryjoin="""and_(
            PagingUser.pagingid == Paging.id,
            PagingUser.caller == 1
        )""",
        cascade='all, delete-orphan',
    )

    users_caller = association_proxy(
        'paging_callers',
        'user',
        creator=lambda _user: PagingUser(user=_user, caller=1),
    )

    func_keys = relationship('FuncKeyDestPaging', cascade='all, delete-orphan')

    @hybrid_property
    def enabled(self):
        return self.commented == 0

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False)

    @hybrid_property
    def duplex_bool(self):
        return self.duplex == 1

    @duplex_bool.expression
    def duplex_bool(cls):
        return cast(cls.duplex, Boolean)

    @duplex_bool.setter
    def duplex_bool(self, value):
        self.duplex = int(value)

    @hybrid_property
    def record_bool(self):
        return self.record == 1

    @record_bool.expression
    def record_bool(cls):
        return cast(cls.record, Boolean)

    @record_bool.setter
    def record_bool(self, value):
        self.record = int(value)

    @hybrid_property
    def ignore_forward(self):
        return self.ignore == 1

    @ignore_forward.expression
    def ignore_forward(cls):
        return cast(cls.ignore, Boolean)

    @ignore_forward.setter
    def ignore_forward(self, value):
        self.ignore = int(value)

    @hybrid_property
    def caller_notification(self):
        return self.quiet == 0

    @caller_notification.expression
    def caller_notification(cls):
        return not_(cast(cls.quiet, Boolean))

    @caller_notification.setter
    def caller_notification(self, value):
        self.quiet = int(value == 0)

    @hybrid_property
    def announce_caller(self):
        return self.announcement_caller == 0

    @announce_caller.expression
    def announce_caller(cls):
        return not_(cast(cls.announcement_caller, Boolean))

    @announce_caller.setter
    def announce_caller(self, value):
        self.announcement_caller = int(value == 0)

    @hybrid_property
    def announce_sound(self):
        return self.announcement_file

    @announce_sound.setter
    def announce_sound(self, value):
        self.announcement_play = int(value is not None)
        self.announcement_file = value

----------------------------------------

File: alchemy/paginguser.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index, PrimaryKeyConstraint
from sqlalchemy.types import Integer

from accent_dao.helpers.db_manager import Base


class PagingUser(Base):
    __tablename__ = 'paginguser'
    __table_args__ = (
        PrimaryKeyConstraint('pagingid', 'userfeaturesid', 'caller'),
        Index('paginguser__idx__pagingid', 'pagingid'),
    )

    pagingid = Column(Integer, ForeignKey('paging.id'), nullable=False)
    userfeaturesid = Column(Integer, ForeignKey('userfeatures.id'), nullable=False)
    caller = Column(Integer, nullable=False, autoincrement=False)

    paging = relationship('Paging')
    user = relationship('UserFeatures')

    @hybrid_property
    def paging_id(self):
        return self.pagingid

    @paging_id.setter
    def paging_id(self, value):
        self.pagingid = value

    @hybrid_property
    def user_id(self):
        return self.userfeaturesid

    @user_id.setter
    def user_id(self, value):
        self.userfeaturesid = value

----------------------------------------

File: alchemy/parking_lot.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index, PrimaryKeyConstraint
from sqlalchemy.sql import (
    cast,
    select,
)
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base

from .extension import Extension


class ParkingLot(Base):
    __tablename__ = 'parking_lot'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('parking_lot__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(128))
    slots_start = Column(String(40), nullable=False)
    slots_end = Column(String(40), nullable=False)
    timeout = Column(Integer)
    music_on_hold = Column(String(128))

    extensions = relationship(
        'Extension',
        primaryjoin="""and_(
            Extension.type == 'parking',
            Extension.typeval == cast(ParkingLot.id, String)
        )""",
        foreign_keys='Extension.typeval',
        viewonly=True,
    )

    func_keys_park_position = relationship(
        'FuncKeyDestParkPosition',
        cascade='all, delete-orphan',
    )

    func_keys_parking = relationship(
        'FuncKeyDestParking',
        cascade='all, delete-orphan',
    )

    def in_slots_range(self, exten):
        if not str(exten).isdigit() or str(exten).startswith('0'):
            return False

        exten = int(exten)
        start = int(self.slots_start)
        end = int(self.slots_end)

        if start <= exten <= end:
            return True
        return False

    @hybrid_property
    def exten(self):
        for extension in self.extensions:
            return extension.exten
        return None

    @exten.expression
    def exten(cls):
        return (
            select([Extension.exten])
            .where(Extension.type == 'parking')
            .where(Extension.typeval == cast(cls.id, String))
            .as_scalar()
        )

    @hybrid_property
    def context(self):
        for extension in self.extensions:
            return extension.context
        return None

    @context.expression
    def context(cls):
        return (
            select([Extension.context])
            .where(Extension.type == 'parking')
            .where(Extension.typeval == cast(cls.id, String))
            .as_scalar()
        )

----------------------------------------

File: alchemy/phone_number.py
Please review for update


from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKeyConstraint,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import text
from sqlalchemy.types import Boolean, String, Text

from accent_dao.helpers.db_manager import Base


class PhoneNumber(Base):
    __tablename__ = 'phone_number'
    __table_args__ = (
        PrimaryKeyConstraint('uuid'),
        ForeignKeyConstraint(
            ('tenant_uuid',),
            ('tenant.uuid',),
            ondelete='CASCADE',
        ),
        UniqueConstraint('number', 'tenant_uuid'),
        Index(
            'only_one_main_allowed',
            'main',
            'tenant_uuid',
            unique=True,
            postgresql_where=(text('main is true')),
        ),
        CheckConstraint(
            'CASE WHEN main THEN shared ELSE true END',
            name='phone_number_shared_if_main',
        ),
    )

    uuid = Column(UUID(as_uuid=True), server_default=text('uuid_generate_v4()'))
    tenant_uuid = Column(String(36), nullable=False)
    number = Column(Text, nullable=False)
    caller_id_name = Column(Text, nullable=True)
    shared = Column(Boolean, nullable=False, server_default=text('false'))
    _main = Column('main', Boolean, nullable=False, server_default=text('false'))

    @hybrid_property
    def main(self):
        return self._main

    @main.setter
    def main(self, value):
        self._main = value
        if value:
            self.shared = True

    def __repr__(self):
        return f'{self.__class__.__name__}(uuid={self.uuid}, number={self.number})'

----------------------------------------

File: alchemy/pickup.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import cast, not_
from sqlalchemy.sql.schema import ForeignKey
from sqlalchemy.types import Boolean, Integer, String, Text

from accent_dao.helpers.db_manager import Base

from .pickupmember import PickupMember


class Pickup(Base):
    __tablename__ = 'pickup'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('name'),
        Index('pickup__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer, nullable=False, autoincrement=False)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(128), nullable=False)
    commented = Column(Integer, nullable=False, server_default='0')
    description = Column(Text)

    pickupmember_user_targets = relationship(
        'PickupMember',
        primaryjoin="""and_(
            PickupMember.pickupid == Pickup.id,
            PickupMember.category == 'pickup',
            PickupMember.membertype == 'user'
        )""",
        foreign_keys='PickupMember.pickupid',
        cascade='all, delete-orphan',
    )
    user_targets = association_proxy(
        'pickupmember_user_targets',
        'user',
        creator=lambda _user: PickupMember(
            user=_user, category='pickup', membertype='user'
        ),
    )

    pickupmember_group_targets = relationship(
        'PickupMember',
        primaryjoin="""and_(
            PickupMember.pickupid == Pickup.id,
            PickupMember.category == 'pickup',
            PickupMember.membertype == 'group'
        )""",
        foreign_keys='PickupMember.pickupid',
        cascade='all, delete-orphan',
    )
    group_targets = association_proxy(
        'pickupmember_group_targets',
        'group',
        creator=lambda _group: PickupMember(
            group=_group, category='pickup', membertype='group'
        ),
    )
    users_from_group_targets = association_proxy(
        'pickupmember_group_targets', 'users_from_group'
    )

    pickupmember_user_interceptors = relationship(
        'PickupMember',
        primaryjoin="""and_(
            PickupMember.pickupid == Pickup.id,
            PickupMember.category == 'member',
            PickupMember.membertype == 'user'
        )""",
        foreign_keys='PickupMember.pickupid',
        cascade='all, delete-orphan',
    )
    user_interceptors = association_proxy(
        'pickupmember_user_interceptors',
        'user',
        creator=lambda _user: PickupMember(
            user=_user, category='member', membertype='user'
        ),
    )

    pickupmember_group_interceptors = relationship(
        'PickupMember',
        primaryjoin="""and_(
            PickupMember.pickupid == Pickup.id,
            PickupMember.category == 'member',
            PickupMember.membertype == 'group'
        )""",
        foreign_keys='PickupMember.pickupid',
        cascade='all, delete-orphan',
    )
    group_interceptors = association_proxy(
        'pickupmember_group_interceptors',
        'group',
        creator=lambda _group: PickupMember(
            group=_group, category='member', membertype='group'
        ),
    )

    pickupmember_queue_targets = relationship(
        'PickupMember',
        primaryjoin="""and_(
            PickupMember.pickupid == Pickup.id,
            PickupMember.category == 'pickup',
            PickupMember.membertype == 'queue'
        )""",
        foreign_keys='PickupMember.pickupid',
        cascade='all, delete-orphan',
    )

    pickupmember_queue_interceptors = relationship(
        'PickupMember',
        primaryjoin="""and_(
            PickupMember.pickupid == Pickup.id,
            PickupMember.category == 'member',
            PickupMember.membertype == 'queue'
        )""",
        foreign_keys='PickupMember.pickupid',
        cascade='all, delete-orphan',
    )

    @hybrid_property
    def enabled(self):
        if self.commented is None:
            return None
        return self.commented == 0

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False)

----------------------------------------

File: alchemy/pickupmember.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, PrimaryKeyConstraint
from sqlalchemy.types import Enum, Integer

from accent_dao.helpers.db_manager import Base


class PickupMember(Base):
    __tablename__ = 'pickupmember'
    __table_args__ = (
        PrimaryKeyConstraint('pickupid', 'category', 'membertype', 'memberid'),
    )

    pickupid = Column(Integer, nullable=False, autoincrement=False)
    category = Column(
        Enum('member', 'pickup', name='pickup_category', metadata=Base.metadata),
        nullable=False,
        autoincrement=False,
    )
    membertype = Column(
        Enum(
            'group', 'queue', 'user', name='pickup_membertype', metadata=Base.metadata
        ),
        nullable=False,
        autoincrement=False,
    )
    memberid = Column(Integer, nullable=False, autoincrement=False)

    user = relationship(
        'UserFeatures',
        primaryjoin="""and_(PickupMember.membertype == 'user',
            PickupMember.memberid == UserFeatures.id)""",
        foreign_keys='PickupMember.memberid',
    )

    group = relationship(
        'GroupFeatures',
        primaryjoin="""and_(PickupMember.membertype == 'group',
            PickupMember.memberid == GroupFeatures.id)""",
        foreign_keys='PickupMember.memberid',
    )

    users_from_group = association_proxy('group', 'users')

----------------------------------------

File: alchemy/pjsip_transport.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, PrimaryKeyConstraint, UniqueConstraint
from sqlalchemy.types import Text

from accent_dao.helpers.db_manager import Base

from .pjsip_transport_option import PJSIPTransportOption


class PJSIPTransport(Base):
    __tablename__ = 'pjsip_transport'
    __table_args__ = (
        PrimaryKeyConstraint('uuid'),
        UniqueConstraint('name'),
    )

    uuid = Column(UUID(as_uuid=True), server_default=text('uuid_generate_v4()'))
    name = Column(Text, nullable=False)
    _options = relationship(
        'PJSIPTransportOption',
        cascade='all, delete-orphan',
        passive_deletes=True,
        passive_updates=False,
    )

    def __init__(self, **kwargs):
        options = kwargs.pop('options', [])
        super().__init__(**kwargs)
        for key, value in options:
            self._options.append(PJSIPTransportOption(key=key, value=value))

    @property
    def options(self):
        return [[option.key, option.value] for option in self._options]

    @options.setter
    def options(self, options):
        remaining_options = list(options)
        new_options = []

        for option in self._options:
            if (option.key, option.value) not in remaining_options:
                continue
            new_options.append(option)
            remaining_options.remove((options.key, options.value))

        for key, value in remaining_options:
            new_options.append(PJSIPTransportOption(key=key, value=value))

        self._options = new_options

----------------------------------------

File: alchemy/pjsip_transport_option.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.schema import Column, ForeignKey, Index
from sqlalchemy.types import Integer, Text

from accent_dao.helpers.db_manager import Base


class PJSIPTransportOption(Base):
    __tablename__ = 'pjsip_transport_option'
    __table_args__ = (
        Index(
            'pjsip_transport_option__idx__pjsip_transport_uuid',
            'pjsip_transport_uuid',
        ),
    )

    id = Column(Integer, primary_key=True)
    key = Column(Text, nullable=False)
    value = Column(Text, nullable=False)
    pjsip_transport_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey('pjsip_transport.uuid', ondelete='CASCADE'),
        nullable=False,
    )

----------------------------------------

File: alchemy/provisioning.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class Provisioning(Base):
    __tablename__ = 'provisioning'
    __table_args__ = (PrimaryKeyConstraint('id'),)

    id = Column(Integer, nullable=False)
    net4_ip = Column(String(39))
    http_base_url = Column(String(255))
    dhcp_integration = Column(Integer, nullable=False, server_default='0')
    http_port = Column(Integer, nullable=False)

----------------------------------------

File: alchemy/queue.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.sql.schema import CheckConstraint
from sqlalchemy.types import Enum, Integer, String, Text

from accent_dao.helpers.asterisk import AsteriskOptionsMixin
from accent_dao.helpers.db_manager import Base


class Queue(Base, AsteriskOptionsMixin):
    EXCLUDE_OPTIONS = {  # noqa: RUF012
        'name',
        'category',
        'commented',
    }
    EXCLUDE_OPTIONS_CONFD = {  # noqa: RUF012
        'musicclass',
    }
    AST_TRUE_INTEGER_COLUMNS = {  # noqa: RUF012
        'ringinuse',
        'timeoutrestart',
        'autofill',
        'setinterfacevar',
        'setqueueentryvar',
        'setqueuevar',
        'reportholdtime',
        'random-periodic-announce',
    }

    # This should eventually be a column to set arbitrary asterisk options
    _options = []  # noqa: RUF012

    __tablename__ = 'queue'
    __table_args__ = (
        PrimaryKeyConstraint('name'),
        Index('queue__idx__category', 'category'),
        CheckConstraint("autopause in ('no', 'yes', 'all')"),
    )

    name = Column(String(128))
    musicclass = Column(String(128))
    announce = Column(String(128))
    context = Column(String(79))
    timeout = Column(Integer, server_default='0')
    monitor_type = Column(
        'monitor-type',
        Enum('no', 'mixmonitor', name='queue_monitor_type', metadata=Base.metadata),
    )
    monitor_format = Column('monitor-format', String(128))
    queue_youarenext = Column('queue-youarenext', String(128))
    queue_thereare = Column('queue-thereare', String(128))
    queue_callswaiting = Column('queue-callswaiting', String(128))
    queue_holdtime = Column('queue-holdtime', String(128))
    queue_minutes = Column('queue-minutes', String(128))
    queue_seconds = Column('queue-seconds', String(128))
    queue_thankyou = Column('queue-thankyou', String(128))
    queue_reporthold = Column('queue-reporthold', String(128))
    periodic_announce = Column('periodic-announce', Text)
    announce_frequency = Column('announce-frequency', Integer)
    periodic_announce_frequency = Column('periodic-announce-frequency', Integer)
    announce_round_seconds = Column('announce-round-seconds', Integer)
    announce_holdtime = Column('announce-holdtime', String(4))
    retry = Column(Integer)
    wrapuptime = Column(Integer)
    maxlen = Column(Integer)
    servicelevel = Column(Integer)
    strategy = Column(String(11))
    joinempty = Column(String(255))
    leavewhenempty = Column(String(255))
    ringinuse = Column(Integer, nullable=False, server_default='0')
    reportholdtime = Column(Integer, nullable=False, server_default='0')
    memberdelay = Column(Integer)
    weight = Column(Integer)
    timeoutrestart = Column(Integer, nullable=False, server_default='0')
    commented = Column(Integer, nullable=False, server_default='0')
    category = Column(
        Enum('group', 'queue', name='queue_category', metadata=Base.metadata),
        nullable=False,
    )
    timeoutpriority = Column(String(10), nullable=False, server_default='app')
    autofill = Column(Integer, nullable=False, server_default='1')
    autopause = Column(String(3), nullable=False, server_default='no')
    setinterfacevar = Column(Integer, nullable=False, server_default='0')
    setqueueentryvar = Column(Integer, nullable=False, server_default='0')
    setqueuevar = Column(Integer, nullable=False, server_default='0')
    membermacro = Column(String(1024))
    min_announce_frequency = Column(
        'min-announce-frequency', Integer, nullable=False, server_default='60'
    )
    random_periodic_announce = Column(
        'random-periodic-announce', Integer, nullable=False, server_default='0'
    )
    announce_position = Column(
        'announce-position', String(1024), nullable=False, server_default='yes'
    )
    announce_position_limit = Column(
        'announce-position-limit', Integer, nullable=False, server_default='5'
    )
    defaultrule = Column(String(1024))

    groupfeatures = relationship(
        'GroupFeatures',
        primaryjoin="""and_(Queue.category == 'group',
                            Queue.name == GroupFeatures.name)""",
        foreign_keys='Queue.name',
        uselist=False,
    )

    queuefeatures = relationship(
        'QueueFeatures',
        primaryjoin="""and_(Queue.category == 'queue',
                            Queue.name == QueueFeatures.name)""",
        foreign_keys='Queue.name',
        uselist=False,
    )

    @hybrid_property
    def enabled(self):
        if self.commented is None:
            return None
        return self.commented == 0

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False) if value is not None else None

    @hybrid_property
    def ring_in_use(self):
        return bool(self.ringinuse)

    @ring_in_use.setter
    def ring_in_use(self, value):
        self.ringinuse = int(value)

    @property
    def label(self):
        try:
            if self.category == 'group':
                return self.groupfeatures.label
            elif self.category == 'queue':
                return self.queuefeatures.displayname
        except AttributeError:
            pass
        return 'unknown'

----------------------------------------

File: alchemy/queue_log.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.types import DateTime, Integer, String, Text

from accent_dao.helpers.db_manager import Base


class QueueLog(Base):
    __tablename__ = 'queue_log'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('queue_log__idx_agent', 'agent'),
        Index('queue_log__idx_callid', 'callid'),
        Index('queue_log__idx_event', 'event'),
        Index('queue_log__idx_time', 'time'),
    )

    time = Column(DateTime(timezone=True))
    callid = Column(String(80))
    queuename = Column(String(256))
    agent = Column(Text)
    event = Column(String(20))
    data1 = Column(Text)
    data2 = Column(Text)
    data3 = Column(Text)
    data4 = Column(Text)
    data5 = Column(Text)
    id = Column(Integer)

----------------------------------------

File: alchemy/queuefeatures.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.dialects.postgresql import DOUBLE_PRECISION
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.orm.collections import attribute_mapped_collection
from sqlalchemy.schema import (
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import (
    cast,
    func,
    select,
)
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base

from .callerid import Callerid
from .extension import Extension
from .queue import Queue
from .schedulepath import SchedulePath

DEFAULT_QUEUE_OPTIONS = {
    'timeout': '15',
    'queue-youarenext': 'queue-youarenext',
    'queue-thereare': 'queue-thereare',
    'queue-callswaiting': 'queue-callswaiting',
    'queue-holdtime': 'queue-holdtime',
    'queue-minutes': 'queue-minutes',
    'queue-seconds': 'queue-seconds',
    'queue-thankyou': 'queue-thankyou',
    'queue-reporthold': 'queue-reporthold',
    'periodic-announce': 'queue-periodic-announce',
    'announce-frequency': '0',
    'periodic-announce-frequency': '0',
    'announce-round-seconds': '0',
    'announce-holdtime': 'no',
    'retry': '5',
    'wrapuptime': '0',
    'maxlen': '0',
    'servicelevel': '0',
    'strategy': 'ringall',
    'memberdelay': '0',
    'weight': '0',
    'timeoutpriority': 'conf',
    'setqueueentryvar': '1',
    'setqueuevar': '1',
}


class QueueFeatures(Base):

    __tablename__ = 'queuefeatures'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('name'),
        Index('queuefeatures__idx__context', 'context'),
        Index('queuefeatures__idx__number', 'number'),
        Index('queuefeatures__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(128), nullable=False)
    displayname = Column(String(128), nullable=False)
    number = Column(String(40))
    context = Column(String(79))
    data_quality = Column(Integer, nullable=False, server_default='0')
    hitting_callee = Column(Integer, nullable=False, server_default='0')
    hitting_caller = Column(Integer, nullable=False, server_default='0')
    retries = Column(Integer, nullable=False, server_default='0')
    ring = Column(Integer, nullable=False, server_default='0')
    transfer_user = Column(Integer, nullable=False, server_default='0')
    transfer_call = Column(Integer, nullable=False, server_default='0')
    write_caller = Column(Integer, nullable=False, server_default='0')
    write_calling = Column(Integer, nullable=False, server_default='0')
    ignore_forward = Column(Integer, nullable=False, server_default='1')
    url = Column(String(255), nullable=False, server_default='')
    announceoverride = Column(String(128), nullable=False, server_default='')
    timeout = Column(Integer)
    preprocess_subroutine = Column(String(79))
    announce_holdtime = Column(Integer, nullable=False, server_default='0')
    waittime = Column(Integer)
    waitratio = Column(DOUBLE_PRECISION)
    mark_answered_elsewhere = Column(Integer, nullable=False, server_default='1')

    _queue = relationship(
        'Queue',
        primaryjoin="""and_(Queue.category == 'queue',
                            Queue.name == QueueFeatures.name)""",
        foreign_keys='Queue.name',
        cascade='all, delete-orphan',
        uselist=False,
        passive_updates=False,
    )
    enabled = association_proxy('_queue', 'enabled')
    options = association_proxy('_queue', 'options')
    music_on_hold = association_proxy('_queue', 'musicclass')

    caller_id = relationship(
        'Callerid',
        primaryjoin="""and_(Callerid.type == 'queue',
                            Callerid.typeval == QueueFeatures.id)""",
        foreign_keys='Callerid.typeval',
        cascade='all, delete-orphan',
        uselist=False
    )

    caller_id_mode = association_proxy(
        'caller_id', 'mode',
        creator=lambda _mode: Callerid(type='queue', mode=_mode)
    )
    caller_id_name = association_proxy(
        'caller_id', 'name',
        creator=lambda _name: Callerid(type='queue', name=_name)
    )

    extensions = relationship(
        'Extension',
        primaryjoin="""and_(Extension.type == 'queue',
                            Extension.typeval == cast(QueueFeatures.id, String))""",
        foreign_keys='Extension.typeval',
        viewonly=True,
    )

    func_keys = relationship(
        'FuncKeyDestQueue',
        cascade='all, delete-orphan'
    )

    queue_dialactions = relationship(
        'Dialaction',
        primaryjoin="""and_(Dialaction.category == 'queue',
                            Dialaction.categoryval == cast(QueueFeatures.id, String))""",
        foreign_keys='Dialaction.categoryval',
        cascade='all, delete-orphan',
        collection_class=attribute_mapped_collection('event'),
    )

    _dialaction_actions = relationship(
        'Dialaction',
        primaryjoin="""and_(Dialaction.action == 'queue',
                            Dialaction.actionarg1 == cast(QueueFeatures.id, String))""",
        foreign_keys='Dialaction.actionarg1',
        cascade='all, delete-orphan',
    )

    user_queue_members = relationship(
        'QueueMember',
        primaryjoin="""and_(QueueMember.category == 'queue',
                            QueueMember.usertype == 'user',
                            QueueMember.queue_name == QueueFeatures.name)""",
        foreign_keys='QueueMember.queue_name',
        order_by='QueueMember.position',
        cascade='all, delete-orphan',
    )

    agent_queue_members = relationship(
        'QueueMember',
        primaryjoin="""and_(QueueMember.category == 'queue',
                            QueueMember.usertype == 'agent',
                            QueueMember.queue_name == QueueFeatures.name)""",
        foreign_keys='QueueMember.queue_name',
        order_by='QueueMember.position',
        cascade='all, delete-orphan',
    )

    schedule_paths = relationship(
        'SchedulePath',
        primaryjoin="""and_(SchedulePath.path == 'queue',
                            SchedulePath.pathid == QueueFeatures.id)""",
        foreign_keys='SchedulePath.pathid',
        cascade='all, delete-orphan',
    )
    schedules = association_proxy(
        'schedule_paths', 'schedule',
        creator=lambda _schedule: SchedulePath(path='queue', schedule=_schedule)
    )

    def __init__(self, **kwargs):
        options = kwargs.pop('options', [])
        options = self.merge_options_with_default_values(options)
        enabled = kwargs.pop('enabled', True)
        music_on_hold = kwargs.pop('music_on_hold', None)
        super().__init__(**kwargs)
        if not self._queue:
            self._queue = Queue(
                # 'name' is set by the relationship foreign_key
                category='queue',
                enabled=enabled,
                musicclass=music_on_hold,
                options=options,
            )

    def merge_options_with_default_values(self, options):
        result = dict(DEFAULT_QUEUE_OPTIONS)
        for option in options:
            result[option[0]] = option[1]
        return [[key, value] for key, value in result.items()]

    @property
    def wait_time_destination(self):
        return self.queue_dialactions.get('qwaittime')

    @wait_time_destination.setter
    def wait_time_destination(self, destination):
        self._set_dialaction('qwaittime', destination)

    @property
    def wait_ratio_destination(self):
        return self.queue_dialactions.get('qwaitratio')

    @wait_ratio_destination.setter
    def wait_ratio_destination(self, destination):
        self._set_dialaction('qwaitratio', destination)

    @property
    def fallbacks(self):
        return self.queue_dialactions

    # Note: fallbacks[key] = Dialaction() doesn't pass in this method
    @fallbacks.setter
    def fallbacks(self, dialactions):
        for event in ('noanswer', 'busy', 'congestion', 'chanunavail'):
            if event not in dialactions:
                self.queue_dialactions.pop(event, None)

        for event, dialaction in dialactions.items():
            self._set_dialaction(event, dialaction)

    def _set_dialaction(self, event, dialaction):
        if dialaction is None:
            self.queue_dialactions.pop(event, None)
            return

        if event not in self.queue_dialactions:
            dialaction.event = event
            dialaction.category = 'queue'
            self.queue_dialactions[event] = dialaction

        self.queue_dialactions[event].action = dialaction.action
        self.queue_dialactions[event].actionarg1 = dialaction.actionarg1
        self.queue_dialactions[event].actionarg2 = dialaction.actionarg2

    def fix_extension(self):
        self.number = None
        self.context = None
        for extension in self.extensions:
            self.number = extension.exten
            self.context = extension.context
            return

    @hybrid_property
    def label(self):
        if self.displayname == '':
            return None
        return self.displayname

    @label.expression
    def label(cls):
        return func.nullif(cls.displayname, '')

    @label.setter
    def label(self, value):
        if value is None:
            self.displayname = ''
        else:
            self.displayname = value

    @hybrid_property
    def data_quality_bool(self):
        return self.data_quality == 1

    @data_quality_bool.setter
    def data_quality_bool(self, value):
        self.data_quality = int(value is True)

    @hybrid_property
    def ignore_forward_bool(self):
        return self.ignore_forward == 1

    @ignore_forward_bool.setter
    def ignore_forward_bool(self, value):
        self.ignore_forward = int(value is True)

    @hybrid_property
    def dtmf_hangup_callee_enabled(self):
        return self.hitting_callee == 1

    @dtmf_hangup_callee_enabled.setter
    def dtmf_hangup_callee_enabled(self, value):
        self.hitting_callee = int(value is True)

    @hybrid_property
    def dtmf_hangup_caller_enabled(self):
        return self.hitting_caller == 1

    @dtmf_hangup_caller_enabled.setter
    def dtmf_hangup_caller_enabled(self, value):
        self.hitting_caller = int(value is True)

    @hybrid_property
    def dtmf_transfer_callee_enabled(self):
        return self.transfer_user == 1

    @dtmf_transfer_callee_enabled.setter
    def dtmf_transfer_callee_enabled(self, value):
        self.transfer_user = int(value is True)

    @hybrid_property
    def dtmf_transfer_caller_enabled(self):
        return self.transfer_call == 1

    @dtmf_transfer_caller_enabled.setter
    def dtmf_transfer_caller_enabled(self, value):
        self.transfer_call = int(value is True)

    @hybrid_property
    def dtmf_record_callee_enabled(self):
        return self.write_caller == 1

    @dtmf_record_callee_enabled.setter
    def dtmf_record_callee_enabled(self, value):
        self.write_caller = int(value is True)

    @hybrid_property
    def dtmf_record_caller_enabled(self):
        return self.write_calling == 1

    @dtmf_record_caller_enabled.setter
    def dtmf_record_caller_enabled(self, value):
        self.write_calling = int(value is True)

    @hybrid_property
    def retry_on_timeout(self):
        return not self.retries == 1

    @retry_on_timeout.setter
    def retry_on_timeout(self, value):
        self.retries = int(value is False)

    @hybrid_property
    def ring_on_hold(self):
        return self.ring == 1

    @ring_on_hold.setter
    def ring_on_hold(self, value):
        self.ring = int(value is True)

    @hybrid_property
    def announce_hold_time_on_entry(self):
        return self.announce_holdtime == 1

    @announce_hold_time_on_entry.setter
    def announce_hold_time_on_entry(self, value):
        self.announce_holdtime = int(value is True)

    @hybrid_property
    def wait_time_threshold(self):
        return self.waittime

    @wait_time_threshold.setter
    def wait_time_threshold(self, value):
        self.waittime = value

    @hybrid_property
    def wait_ratio_threshold(self):
        return self.waitratio

    @wait_ratio_threshold.setter
    def wait_ratio_threshold(self, value):
        self.waitratio = value

    @hybrid_property
    def mark_answered_elsewhere_bool(self):
        return self.mark_answered_elsewhere == 1

    @mark_answered_elsewhere_bool.setter
    def mark_answered_elsewhere_bool(self, value):
        self.mark_answered_elsewhere = int(value is True)

    @hybrid_property
    def exten(self):
        for extension in self.extensions:
            return extension.exten
        return None

    @exten.expression
    def exten(cls):
        return (
            select([Extension.exten])
            .where(Extension.type == 'queue')
            .where(Extension.typeval == cast(cls.id, String))
            .as_scalar()
        )

----------------------------------------

File: alchemy/queuemember.py
Please review for update

# Copyright 2023 Accent Communications

import re

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.types import Enum, Integer, String

from accent_dao.helpers.db_manager import Base

interface_regex = re.compile(r'Local/(?P<exten>.*)@(?P<context>.*)')


class QueueMember(Base):
    __tablename__ = 'queuemember'
    __table_args__ = (
        PrimaryKeyConstraint('queue_name', 'interface'),
        UniqueConstraint(
            'queue_name',
            'channel',
            'interface',
            'usertype',
            'userid',
            'category',
            'position',
        ),
        Index('queuemember__idx__category', 'category'),
        Index('queuemember__idx__channel', 'channel'),
        Index('queuemember__idx__userid', 'userid'),
        Index('queuemember__idx__usertype', 'usertype'),
    )

    queue_name = Column(String(128))
    interface = Column(String(128))
    penalty = Column(Integer, nullable=False, server_default='0')
    commented = Column(Integer, nullable=False, server_default='0')
    usertype = Column(
        Enum('agent', 'user', name='queuemember_usertype', metadata=Base.metadata),
        nullable=False,
    )
    userid = Column(Integer, nullable=False)
    channel = Column(String(25), nullable=False)
    category = Column(
        Enum('queue', 'group', name='queue_category', metadata=Base.metadata),
        nullable=False,
    )
    position = Column(Integer, nullable=False, server_default='0')

    agent = relationship(
        'AgentFeatures',
        primaryjoin="""and_(QueueMember.usertype == 'agent',
                            QueueMember.userid == AgentFeatures.id)""",
        foreign_keys='QueueMember.userid',
    )

    user = relationship(
        'UserFeatures',
        primaryjoin="""and_(QueueMember.usertype == 'user',
                            QueueMember.userid == UserFeatures.id)""",
        foreign_keys='QueueMember.userid',
    )

    group = relationship(
        'GroupFeatures',
        primaryjoin="""and_(QueueMember.category == 'group',
                            QueueMember.queue_name == GroupFeatures.name)""",
        foreign_keys='QueueMember.queue_name',
    )
    users_from_call_pickup_group_interceptor_user_targets = association_proxy(
        'group', 'users_from_call_pickup_user_targets'
    )
    users_from_call_pickup_group_interceptor_group_targets = association_proxy(
        'group', 'users_from_call_pickup_group_targets'
    )

    queue = relationship(
        'QueueFeatures',
        primaryjoin='QueueMember.queue_name == QueueFeatures.name',
        foreign_keys='QueueMember.queue_name',
        viewonly=True,
    )

    def fix(self):
        if self.user:
            self._fix_user(self.user)
        elif self.agent:
            self._fix_agent(self.agent)
        else:
            self._fix_local()

    def _fix_user(self, user):
        if not user.lines:
            return

        main_line = user.lines[0]
        if main_line.endpoint_sip:
            self.channel = 'SIP'
            self.interface = f'PJSIP/{main_line.endpoint_sip.name}'

        elif main_line.endpoint_sccp:
            self.channel = 'SCCP'
            self.interface = f'{self.channel}/{main_line.endpoint_sccp.name}'

        elif main_line.endpoint_custom:
            self.channel = '**Unknown**'
            self.interface = main_line.endpoint_custom.interface

    def _fix_agent(self, agent):
        self.channel = 'Agent'
        self.interface = f'{self.channel}/{agent.number}'

    def _fix_local(self):
        self.channel = 'Local'
        self.interface = f'{self.channel}/{self.exten}@{self.context}'

    @hybrid_property
    def priority(self):
        return self.position

    @priority.setter
    def priority(self, value):
        self.position = value

    @property
    def exten(self):
        if hasattr(self, '_exten'):
            return self._exten

        match = re.search(interface_regex, self.interface or '')
        if match:
            return match.group('exten')

    @exten.setter
    def exten(self, value):
        self._exten = value

    @property
    def context(self):
        if hasattr(self, '_context'):
            return self._context

        match = re.search(interface_regex, self.interface or '')
        if match:
            return match.group('context')

    @context.setter
    def context(self, value):
        self._context = value

    @property
    def extension(self):
        return self

    @extension.setter
    def extension(self, extension):
        self.exten = extension.exten
        self.context = extension.context

----------------------------------------

File: alchemy/queueskill.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.types import Integer, String, Text

from accent_dao.helpers.db_manager import Base


class QueueSkill(Base):
    __tablename__ = 'queueskill'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('name', 'tenant_uuid'),
        Index('queueskill__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer, nullable=False)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(64), server_default='', nullable=False)
    description = Column(Text)

    agent_queue_skills = relationship(
        'AgentQueueSkill',
        primaryjoin='AgentQueueSkill.skillid == QueueSkill.id',
        foreign_keys='AgentQueueSkill.skillid',
        cascade='all, delete-orphan',
    )

----------------------------------------

File: alchemy/queueskillrule.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.schema import Column, ForeignKey, Index
from sqlalchemy.sql import case, func
from sqlalchemy.types import Integer, String, Text

from accent_dao.helpers.db_manager import Base


class QueueSkillRule(Base):
    __tablename__ = 'queueskillrule'
    __table_args__ = (Index('queueskillrule__idx__tenant_uuid', 'tenant_uuid'),)

    id = Column(Integer, primary_key=True)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(64), nullable=False)
    rule = Column(Text)

    @hybrid_property
    def rules(self):
        if not self.rule:
            return []
        return self.rule.split(';')

    @rules.expression
    def rules(cls):
        return case(
            [(cls.rule.is_(None), [])], else_=func.string_to_array(cls.rule, ';')
        )

    @rules.setter
    def rules(self, value):
        self.rule = ';'.join(value) if value else None

----------------------------------------

File: alchemy/resolvconf.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, PrimaryKeyConstraint, UniqueConstraint
from sqlalchemy.types import Integer, String, Text

from accent_dao.helpers.db_manager import Base


class Resolvconf(Base):

    __tablename__ = 'resolvconf'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('domain'),
    )

    id = Column(Integer, nullable=False)
    hostname = Column(String(63), nullable=False, server_default='accent')
    domain = Column(String(255), nullable=False, server_default='')
    nameserver1 = Column(String(255))
    nameserver2 = Column(String(255))
    nameserver3 = Column(String(255))
    search = Column(String(255))
    description = Column(Text)

----------------------------------------

File: alchemy/rightcall.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import case, cast, func, not_
from sqlalchemy.types import Boolean, Integer, String, Text

from accent_dao.helpers.db_manager import Base
from accent_dao.helpers.exception import InputError

from .rightcallexten import RightCallExten


class RightCall(Base):
    __tablename__ = 'rightcall'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('name', 'tenant_uuid'),
        Index('rightcall__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer, nullable=False)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(128), nullable=False, server_default='')
    passwd = Column(String(40), nullable=False, server_default='')
    authorization = Column(Integer, nullable=False, server_default='0')
    commented = Column(Integer, nullable=False, server_default='0')
    description = Column(Text)
    rightcallextens = relationship(RightCallExten, cascade="all, delete-orphan")

    rightcall_members = relationship(
        'RightCallMember',
        primaryjoin='RightCallMember.rightcallid == RightCall.id',
        foreign_keys='RightCallMember.rightcallid',
        cascade='all, delete-orphan',
        back_populates='rightcall',
    )

    rightcall_outcalls = relationship(
        'RightCallMember',
        primaryjoin="""and_(
            RightCallMember.rightcallid == RightCall.id,
            RightCallMember.type == 'outcall'
        )""",
        foreign_keys='RightCallMember.rightcallid',
        viewonly=True,
    )
    outcalls = association_proxy('rightcall_outcalls', 'outcall')

    rightcall_groups = relationship(
        'RightCallMember',
        primaryjoin="""and_(
            RightCallMember.rightcallid == RightCall.id,
            RightCallMember.type == 'group'
        )""",
        foreign_keys='RightCallMember.rightcallid',
        viewonly=True,
    )
    groups = association_proxy('rightcall_groups', 'group')

    rightcall_users = relationship(
        'RightCallMember',
        primaryjoin="""and_(
            RightCallMember.rightcallid == RightCall.id,
            RightCallMember.type == 'user'
        )""",
        foreign_keys='RightCallMember.rightcallid',
        viewonly=True,
    )
    users = association_proxy('rightcall_users', 'user')

    @hybrid_property
    def password(self):
        if self.passwd == '':
            return None
        return self.passwd

    @password.expression
    def password(cls):
        return func.nullif(cls.passwd, '')

    @password.setter
    def password(self, value):
        if value is None:
            self.passwd = ''
        else:
            self.passwd = value

    @hybrid_property
    def mode(self):
        if self.authorization == 1:
            return 'allow'
        else:
            return 'deny'

    @mode.expression
    def mode(cls):
        return case([(cls.authorization == 1, 'allow')], else_='deny')

    @mode.setter
    def mode(self, value):
        if value == 'allow':
            self.authorization = 1
        elif value == 'deny':
            self.authorization = 0
        else:
            raise InputError(
                f"cannot set mode to {value}. Only 'allow' or 'deny' are authorized"
            )

    @hybrid_property
    def enabled(self):
        return self.commented == 0

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False)

    @property
    def extensions(self):
        return [rightcallexten.exten for rightcallexten in self.rightcallextens]

    @extensions.setter
    def extensions(self, values):
        old_rightcallextens = {
            rightcallexten.exten: rightcallexten
            for rightcallexten in self.rightcallextens
        }
        self.rightcallextens = []
        for value in set(values):
            if value in old_rightcallextens:
                self.rightcallextens.append(old_rightcallextens[value])
            else:
                self.rightcallextens.append(
                    RightCallExten(rightcallid=self.id, exten=value)
                )

----------------------------------------

File: alchemy/rightcallexten.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, ForeignKey, PrimaryKeyConstraint, UniqueConstraint
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class RightCallExten(Base):
    __tablename__ = 'rightcallexten'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('rightcallid', 'exten'),
    )

    id = Column(Integer, nullable=False)
    rightcallid = Column(
        Integer,
        ForeignKey('rightcall.id', ondelete='CASCADE'),
        nullable=False,
        server_default='0',
    )
    exten = Column(String(40), nullable=False, server_default='')

----------------------------------------

File: alchemy/rightcallmember.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import case, cast
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class RightCallMember(Base):
    __tablename__ = 'rightcallmember'

    id = Column(Integer, nullable=False)
    rightcallid = Column(Integer, nullable=False, server_default='0')
    type = Column(String(64), nullable=False)
    typeval = Column(String(128), nullable=False, server_default='0')

    group = relationship(
        'GroupFeatures',
        primaryjoin="""and_(RightCallMember.type == 'group',
                            RightCallMember.typeval == cast(GroupFeatures.id, String))""",
        foreign_keys='RightCallMember.typeval',
        viewonly=True,
    )

    outcall = relationship(
        'Outcall',
        primaryjoin="""and_(RightCallMember.type == 'outcall',
                            RightCallMember.typeval == cast(Outcall.id, String))""",
        foreign_keys='RightCallMember.typeval',
        viewonly=True,
    )

    user = relationship(
        'UserFeatures',
        primaryjoin="""and_(RightCallMember.type == 'user',
                            RightCallMember.typeval == cast(UserFeatures.id, String))""",
        foreign_keys='RightCallMember.typeval',
        viewonly=True,
    )

    rightcall = relationship(
        'RightCall',
        primaryjoin='RightCall.id == RightCallMember.rightcallid',
        foreign_keys='RightCallMember.rightcallid',
        back_populates='rightcall_members',
    )

    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('rightcallid', 'type', 'typeval'),
        CheckConstraint(
            type.in_(['group', 'outcall', 'user']), name='rightcallmember_type_check'
        ),
    )

    @hybrid_property
    def call_permission_id(self):
        return self.rightcallid

    @call_permission_id.setter
    def call_permission_id(self, value):
        self.rightcallid = value

    @hybrid_property
    def user_id(self):
        if self.type == 'user':
            return int(self.typeval)
        return None

    @user_id.expression
    def user_id(cls):
        return case([(cls.type == 'user', cast(cls.typeval, Integer))], else_=None)

    @user_id.setter
    def user_id(self, value):
        self.type = 'user'
        self.typeval = str(value)
----------------------------------------

File: alchemy/sccpdevice.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class SCCPDevice(Base):

    __tablename__ = 'sccpdevice'

    id = Column(Integer, primary_key=True)
    name = Column(String(80), nullable=False)
    device = Column(String(80), nullable=False)
    line = Column(String(80), nullable=False, server_default='')

----------------------------------------

File: alchemy/sccpgeneralsettings.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class SCCPGeneralSettings(Base):

    __tablename__ = 'sccpgeneralsettings'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
    )

    id = Column(Integer)
    option_name = Column(String(80), nullable=False)
    option_value = Column(String(80), nullable=False)

----------------------------------------

File: alchemy/sccpline.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String, Text

from accent_dao.helpers.db_manager import Base
from accent_dao.helpers.exception import InputError

from . import enum


class SCCPLine(Base):
    __tablename__ = 'sccpline'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('sccpline__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(80), nullable=False)
    context = Column(String(79), nullable=False)
    cid_name = Column(String(80), nullable=False)
    cid_num = Column(String(80), nullable=False)
    disallow = Column(String(100))
    allow = Column(Text)
    protocol = Column(enum.trunk_protocol, nullable=False, server_default='sccp')
    commented = Column(Integer, nullable=False, server_default='0')

    line = relationship('LineFeatures', uselist=False, viewonly=True)

    @property
    def options(self):
        options = []
        if self.cid_name != "":
            options.append(["cid_name", self.cid_name])
        if self.cid_num != "":
            options.append(["cid_num", self.cid_num])

        if self.disallow is not None:
            options.append(["disallow", self.disallow])
        if self.allow is not None:
            options.append(["allow", self.allow])

        return options

    @options.setter
    def options(self, values):
        self.clear_options()
        self.set_options(values)

    def clear_options(self):
        self.allow = None
        self.disallow = None

    def set_options(self, values):
        for name, value in values:
            if name == "cid_name":
                self.cid_name = value
            elif name == "cid_num":
                self.cid_num = value
            elif name == "allow":
                self.allow = value
            elif name == "disallow":
                self.disallow = value
            else:
                raise InputError(f"Unknown SCCP options: {name}")

    def same_protocol(self, protocol, id):
        return protocol == 'sccp' and self.id == id

    def update_extension(self, extension):
        self.context = extension.context

    def update_caller_id(self, user, extension=None):
        name, user_num = user.extrapolate_caller_id(extension)
        self.cid_name = name or ''
        if extension:
            self.cid_num = extension.exten
        elif user_num:
            self.cid_num = user_num
        else:
            self.cid_num = ''

    def endpoint_protocol(self):
        return 'sccp'

----------------------------------------

File: alchemy/schedule.py
Please review for update

# Copyright 2023 Accent Communications

from accent import dialaction
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.sql import cast, not_
from sqlalchemy.sql.schema import ForeignKey
from sqlalchemy.types import Boolean, Integer, String, Text

from accent_dao.helpers.db_manager import Base, IntAsString

from . import enum


class Schedule(Base):
    __tablename__ = 'schedule'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('schedule__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer, nullable=False)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(255))
    timezone = Column(String(128))
    fallback_action = Column(
        enum.dialaction_action, nullable=False, server_default='none'
    )
    fallback_actionid = Column(IntAsString(255))
    fallback_actionargs = Column(String(255))
    description = Column(Text)
    commented = Column(Integer, nullable=False, server_default='0')

    periods = relationship(
        'ScheduleTime',
        primaryjoin='ScheduleTime.schedule_id == Schedule.id',
        foreign_keys='ScheduleTime.schedule_id',
        cascade='all, delete-orphan',
    )

    schedule_paths = relationship('SchedulePath', cascade='all, delete-orphan')

    schedule_incalls = relationship(
        'SchedulePath',
        primaryjoin="""and_(
            SchedulePath.schedule_id == Schedule.id,
            SchedulePath.path == 'incall'
        )""",
        viewonly=True,
    )
    incalls = association_proxy('schedule_incalls', 'incall')

    schedule_users = relationship(
        'SchedulePath',
        primaryjoin="""and_(
            SchedulePath.schedule_id == Schedule.id,
            SchedulePath.path == 'user'
        )""",
        viewonly=True,
    )
    users = association_proxy('schedule_users', 'user')

    schedule_groups = relationship(
        'SchedulePath',
        primaryjoin="""and_(
            SchedulePath.schedule_id == Schedule.id,
            SchedulePath.path == 'group'
        )""",
        viewonly=True,
    )
    groups = association_proxy('schedule_groups', 'group')

    schedule_outcalls = relationship(
        'SchedulePath',
        primaryjoin="""and_(
            SchedulePath.schedule_id == Schedule.id,
            SchedulePath.path == 'outcall'
        )""",
        viewonly=True,
    )
    outcalls = association_proxy('schedule_outcalls', 'outcall')

    schedule_queues = relationship(
        'SchedulePath',
        primaryjoin="""and_(
            SchedulePath.schedule_id == Schedule.id,
            SchedulePath.path == 'queue'
        )""",
        viewonly=True,
    )
    queues = association_proxy('schedule_queues', 'queue')

    # Begin definitions for fallback destination
    conference = relationship(
        'Conference',
        primaryjoin="""and_(
            Schedule.fallback_action == 'conference',
            Schedule.fallback_actionid == cast(Conference.id, String)
        )""",
        foreign_keys='Schedule.fallback_actionid',
        viewonly=True,
    )

    group = relationship(
        'GroupFeatures',
        primaryjoin="""and_(
            Schedule.fallback_action == 'group',
            Schedule.fallback_actionid == cast(GroupFeatures.id, String)
        )""",
        foreign_keys='Schedule.fallback_actionid',
        viewonly=True,
    )

    user = relationship(
        'UserFeatures',
        primaryjoin="""and_(
            Schedule.fallback_action == 'user',
            Schedule.fallback_actionid == cast(UserFeatures.id, String)
        )""",
        foreign_keys='Schedule.fallback_actionid',
        viewonly=True,
    )

    ivr = relationship(
        'IVR',
        primaryjoin="""and_(
            Schedule.fallback_action == 'ivr',
            Schedule.fallback_actionid == cast(IVR.id, String)
        )""",
        foreign_keys='Schedule.fallback_actionid',
        viewonly=True,
    )

    switchboard = relationship(
        'Switchboard',
        primaryjoin="""and_(
            Schedule.fallback_action == 'switchboard',
            Schedule.fallback_actionid == Switchboard.uuid
        )""",
        foreign_keys='Schedule.fallback_actionid',
        viewonly=True,
    )

    voicemail = relationship(
        'Voicemail',
        primaryjoin="""and_(
            Schedule.fallback_action == 'voicemail',
            Schedule.fallback_actionid == cast(Voicemail.id, String)
        )""",
        foreign_keys='Schedule.fallback_actionid',
        viewonly=True,
    )

    application = relationship(
        'Application',
        primaryjoin="""and_(
            Schedule.fallback_action == 'application:custom',
            Schedule.fallback_actionid == Application.uuid
        )""",
        foreign_keys='Schedule.fallback_actionid',
        viewonly=True,
    )

    queue = relationship(
        'QueueFeatures',
        primaryjoin="""and_(
            Schedule.fallback_action == 'queue',
            Schedule.fallback_actionid == cast(QueueFeatures.id, String)
        )""",
        foreign_keys='Schedule.fallback_actionid',
        viewonly=True,
    )
    # End definitions for fallback destination

    @property
    def open_periods(self):
        return self._get_periods('opened')

    @open_periods.setter
    def open_periods(self, value):
        self._set_periods('opened', value)

    @property
    def exceptional_periods(self):
        return self._get_periods('closed')

    @exceptional_periods.setter
    def exceptional_periods(self, value):
        self._set_periods('closed', value)

    def _get_periods(self, mode):
        return [period for period in self.periods if period.mode == mode]

    def _set_periods(self, mode, periods):
        self.periods = [period for period in self.periods if period.mode != mode]
        for period in periods:
            period.mode = mode
            self.periods.append(period)

    @property
    def closed_destination(self):
        return self

    @property
    def type(self):
        return dialaction.action_type(self.fallback_action)

    @type.setter
    def type(self, value):
        self.fallback_action = dialaction.action(type_=value, subtype=self.subtype)

    @property
    def subtype(self):
        return dialaction.action_subtype(self.fallback_action)

    @subtype.setter
    def subtype(self, value):
        self.fallback_action = dialaction.action(type_=self.type, subtype=value)

    @hybrid_property
    def actionarg1(self):
        if self.fallback_actionid == '':
            return None
        return self.fallback_actionid

    @actionarg1.setter
    def actionarg1(self, value):
        self.fallback_actionid = value

    @hybrid_property
    def actionarg2(self):
        if self.fallback_actionargs == '':
            return None
        return self.fallback_actionargs

    @actionarg2.setter
    def actionarg2(self, value):
        self.fallback_actionargs = value

    @hybrid_property
    def enabled(self):
        return self.commented == 0

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False)

----------------------------------------

File: alchemy/schedule_time.py
Please review for update

# Copyright 2023 Accent Communications

from accent import dialaction
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.types import Enum, Integer, String

from accent_dao.alchemy import enum
from accent_dao.helpers.db_manager import Base, IntAsString


class ScheduleTime(Base):
    __tablename__ = 'schedule_time'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('schedule_time__idx__scheduleid_commented', 'schedule_id', 'commented'),
    )

    id = Column(Integer)
    schedule_id = Column(Integer)
    mode = Column(
        Enum('opened', 'closed', name='schedule_time_mode', metadata=Base.metadata),
        nullable=False,
        server_default='opened',
    )
    hours = Column(String(512))
    weekdays = Column(String(512))
    monthdays = Column(String(512))
    months = Column(String(512))
    action = Column(enum.dialaction_action)
    actionid = Column(IntAsString(255))
    actionargs = Column(String(255))
    commented = Column(Integer, nullable=False, server_default='0')

    conference = relationship(
        'Conference',
        primaryjoin="""and_(
            ScheduleTime.action == 'conference',
            ScheduleTime.actionid == cast(Conference.id, String)
        )""",
        foreign_keys='ScheduleTime.actionid',
        viewonly=True,
    )

    group = relationship(
        'GroupFeatures',
        primaryjoin="""and_(
            ScheduleTime.action == 'group',
            ScheduleTime.actionid == cast(GroupFeatures.id, String)
        )""",
        foreign_keys='ScheduleTime.actionid',
        viewonly=True,
    )

    user = relationship(
        'UserFeatures',
        primaryjoin="""and_(
            ScheduleTime.action == 'user',
            ScheduleTime.actionid == cast(UserFeatures.id, String)
        )""",
        foreign_keys='ScheduleTime.actionid',
        viewonly=True,
    )

    ivr = relationship(
        'IVR',
        primaryjoin="""and_(
            ScheduleTime.action == 'ivr',
            ScheduleTime.actionid == cast(IVR.id, String)
        )""",
        foreign_keys='ScheduleTime.actionid',
        viewonly=True,
    )

    switchboard = relationship(
        'Switchboard',
        primaryjoin="""and_(
            ScheduleTime.action == 'switchboard',
            ScheduleTime.actionid == Switchboard.uuid
        )""",
        foreign_keys='ScheduleTime.actionid',
        viewonly=True,
    )

    voicemail = relationship(
        'Voicemail',
        primaryjoin="""and_(
            ScheduleTime.action == 'voicemail',
            ScheduleTime.actionid == cast(Voicemail.id, String)
        )""",
        foreign_keys='ScheduleTime.actionid',
        viewonly=True,
    )

    application = relationship(
        'Application',
        primaryjoin="""and_(
            ScheduleTime.action == 'application:custom',
            ScheduleTime.actionid == Application.uuid
        )""",
        foreign_keys='ScheduleTime.actionid',
        viewonly=True,
    )

    queue = relationship(
        'QueueFeatures',
        primaryjoin="""and_(
            ScheduleTime.action == 'queue',
            ScheduleTime.actionid == cast(QueueFeatures.id, String)
        )""",
        foreign_keys='ScheduleTime.actionid',
        viewonly=True,
    )

    @property
    def destination(self):
        return self

    @property
    def hours_start(self):
        return self.hours.split('-', 1)[0] if self.hours else None

    @hours_start.setter
    def hours_start(self, value):
        hours_start = value if value else ''
        hours_end = self.hours_end if self.hours_end else ''
        self._set_hours(hours_start, hours_end)

    @property
    def hours_end(self):
        hours = self.hours.split('-', 1) if self.hours else ''
        return hours[1] if len(hours) == 2 else None

    @hours_end.setter
    def hours_end(self, value):
        hours_start = self.hours_start if self.hours_start else ''
        hours_end = value if value else ''
        self._set_hours(hours_start, hours_end)

    def _set_hours(self, hours_start, hours_end):
        end_suffix = f'-{hours_end}' if hours_end else ''
        self.hours = f'{hours_start}{end_suffix}'

    @property
    def week_days(self):
        if not self.weekdays:
            return list(range(1, 8))
        return self._expand_range(self.weekdays)

    @week_days.setter
    def week_days(self, value):
        self.weekdays = self._convert_array_to_str(value)

    @property
    def month_days(self):
        if not self.monthdays:
            return list(range(1, 32))
        return self._expand_range(self.monthdays)

    @month_days.setter
    def month_days(self, value):
        self.monthdays = self._convert_array_to_str(value)

    @property
    def months_list(self):
        if not self.months:
            return list(range(1, 13))
        return self._expand_range(self.months)

    @months_list.setter
    def months_list(self, value):
        self.months = self._convert_array_to_str(value)

    def _expand_range(self, multi_range):
        if not multi_range:
            return multi_range

        result = []
        for item in multi_range.split(','):
            if '-' in item:
                start, end = map(int, item.split('-', 2))
                result += list(range(start, end + 1))
            else:
                result.append(int(item))
        return result

    def _convert_array_to_str(self, value):
        return ','.join(str(x) for x in value) if value else value

    @property
    def type(self):
        return dialaction.action_type(self.action)

    @type.setter
    def type(self, value):
        self.action = dialaction.action(type_=value, subtype=self.subtype)

    @property
    def subtype(self):
        return dialaction.action_subtype(self.action)

    @subtype.setter
    def subtype(self, value):
        self.action = dialaction.action(type_=self.type, subtype=value)

    @hybrid_property
    def actionarg1(self):
        return self.actionid

    @actionarg1.setter
    def actionarg1(self, value):
        self.actionid = value

    @hybrid_property
    def actionarg2(self):
        return self.actionargs

    @actionarg2.setter
    def actionarg2(self, value):
        self.actionargs = value

----------------------------------------

File: alchemy/schedulepath.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index, PrimaryKeyConstraint
from sqlalchemy.types import Integer

from accent_dao.helpers.db_manager import Base
from . import enum


class SchedulePath(Base):
    __tablename__ = 'schedule_path'
    __table_args__ = (
        PrimaryKeyConstraint('schedule_id', 'path', 'pathid'),
        Index('schedule_path_path', 'path', 'pathid'),
        Index('schedule_path__idx__schedule_id', 'schedule_id'),
    )

    schedule_id = Column(Integer, ForeignKey('schedule.id', ondelete='CASCADE'))
    path = Column(enum.schedule_path_type, nullable=False)
    pathid = Column(Integer, autoincrement=False)

    incall = relationship(
        'Incall',
        primaryjoin="""and_(SchedulePath.path == 'incall',
                            SchedulePath.pathid == Incall.id)""",
        foreign_keys='SchedulePath.pathid',
        viewonly=True,
    )
    group = relationship(
        'GroupFeatures',
        primaryjoin="""and_(SchedulePath.path == 'group',
                            SchedulePath.pathid == GroupFeatures.id)""",
        foreign_keys='SchedulePath.pathid',
        viewonly=True,
    )
    outcall = relationship(
        'Outcall',
        primaryjoin="""and_(SchedulePath.path == 'outcall',
                            SchedulePath.pathid == Outcall.id)""",
        foreign_keys='SchedulePath.pathid',
        viewonly=True,
    )
    queue = relationship(
        'QueueFeatures',
        primaryjoin="""and_(SchedulePath.path == 'queue',
                            SchedulePath.pathid == QueueFeatures.id)""",
        foreign_keys='SchedulePath.pathid',
        viewonly=True,
    )
    user = relationship(
        'UserFeatures',
        primaryjoin="""and_(SchedulePath.path == 'user',
                            SchedulePath.pathid == UserFeatures.id)""",
        foreign_keys='SchedulePath.pathid',
        viewonly=True,
    )
    schedule = relationship('Schedule')

----------------------------------------

File: alchemy/session.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String, Text

from accent_dao.helpers.db_manager import Base


class Session(Base):
    __tablename__ = 'session'
    __table_args__ = (
        PrimaryKeyConstraint('sessid'),
        Index('session__idx__expire', 'expire'),
        Index('session__idx__identifier', 'identifier'),
    )

    sessid = Column(String(32), nullable=False)
    start = Column(Integer, nullable=False)
    expire = Column(Integer, nullable=False)
    identifier = Column(String(255), nullable=False)
    data = Column(Text, nullable=False)

----------------------------------------

File: alchemy/stat_agent.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import func
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.sql import case
from sqlalchemy.types import Boolean, Integer, String

from accent_dao.helpers.db_manager import Base


class StatAgent(Base):
    __tablename__ = 'stat_agent'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('stat_agent__idx_name', 'name'),
        Index('stat_agent__idx_tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer)
    name = Column(String(128), nullable=False)
    tenant_uuid = Column(String(36), nullable=False)
    agent_id = Column(Integer)
    deleted = Column(Boolean, nullable=False, server_default='false')

    @hybrid_property
    def number(self):
        if self.name.startswith('Agent/'):
            return self.name.split('/')[-1]

    @number.expression
    def number(cls):
        return case(
            [(func.substr(cls.name, 0, 7) == 'Agent/', func.substr(cls.name, 7))],
            else_=None,
        )

----------------------------------------

File: alchemy/stat_agent_periodic.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.dialects.postgresql import INTERVAL
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index
from sqlalchemy.types import DateTime, Integer

from accent_dao.alchemy.stat_agent import StatAgent
from accent_dao.helpers.db_manager import Base


class StatAgentPeriodic(Base):
    __tablename__ = 'stat_agent_periodic'
    __table_args__ = (
        Index('stat_agent_periodic__idx__stat_agent_id', 'stat_agent_id'),
        Index('stat_agent_periodic__idx__time', 'time'),
    )

    id = Column(Integer, primary_key=True)
    time = Column(DateTime(timezone=True), nullable=False)
    login_time = Column(INTERVAL, nullable=False, server_default='0')
    pause_time = Column(INTERVAL, nullable=False, server_default='0')
    wrapup_time = Column(INTERVAL, nullable=False, server_default='0')
    stat_agent_id = Column(Integer, ForeignKey("stat_agent.id"))

    stat_agent = relationship(StatAgent, foreign_keys=stat_agent_id)

----------------------------------------

File: alchemy/stat_call_on_queue.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index
from sqlalchemy.types import DateTime, Enum, Integer, String

from accent_dao.alchemy.stat_agent import StatAgent
from accent_dao.alchemy.stat_queue import StatQueue
from accent_dao.helpers.db_manager import Base


class StatCallOnQueue(Base):
    __tablename__ = 'stat_call_on_queue'
    __table_args__ = (
        Index('stat_call_on_queue__idx_callid', 'callid'),
        Index('stat_call_on_queue__idx__stat_queue_id', 'stat_queue_id'),
        Index('stat_call_on_queue__idx__stat_agent_id', 'stat_agent_id'),
    )

    id = Column(Integer, primary_key=True)
    callid = Column(String(32), nullable=False)
    time = Column(DateTime(timezone=True), nullable=False)
    ringtime = Column(Integer, nullable=False, server_default='0')
    talktime = Column(Integer, nullable=False, server_default='0')
    waittime = Column(Integer, nullable=False, server_default='0')
    status = Column(
        Enum(
            'full',
            'closed',
            'joinempty',
            'leaveempty',
            'divert_ca_ratio',
            'divert_waittime',
            'answered',
            'abandoned',
            'timeout',
            name='call_exit_type',
            metadata=Base.metadata
        ),
        nullable=False,
    )
    stat_queue_id = Column(Integer, ForeignKey("stat_queue.id"))
    stat_agent_id = Column(Integer, ForeignKey("stat_agent.id"))

    stat_queue = relationship(StatQueue, foreign_keys=stat_queue_id)
    stat_agent = relationship(StatAgent, foreign_keys=stat_agent_id)

----------------------------------------

File: alchemy/stat_queue.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.types import Boolean, Integer, String

from accent_dao.helpers.db_manager import Base


class StatQueue(Base):
    __tablename__ = 'stat_queue'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('stat_queue__idx_name', 'name'),
        Index('stat_queue__idx_tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer)
    name = Column(String(128), nullable=False)
    tenant_uuid = Column(String(36), nullable=False)
    queue_id = Column(Integer)
    deleted = Column(Boolean, nullable=False, server_default='false')

----------------------------------------

File: alchemy/stat_queue_periodic.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index
from sqlalchemy.types import DateTime, Integer

from accent_dao.alchemy.stat_queue import StatQueue
from accent_dao.helpers.db_manager import Base


class StatQueuePeriodic(Base):
    __tablename__ = 'stat_queue_periodic'
    __table_args__ = (
        Index('stat_queue_periodic__idx__stat_queue_id', 'stat_queue_id'),
    )

    id = Column(Integer, primary_key=True)
    time = Column(DateTime(timezone=True), nullable=False)
    answered = Column(Integer, nullable=False, server_default='0')
    abandoned = Column(Integer, nullable=False, server_default='0')
    total = Column(Integer, nullable=False, server_default='0')
    full = Column(Integer, nullable=False, server_default='0')
    closed = Column(Integer, nullable=False, server_default='0')
    joinempty = Column(Integer, nullable=False, server_default='0')
    leaveempty = Column(Integer, nullable=False, server_default='0')
    divert_ca_ratio = Column(Integer, nullable=False, server_default='0')
    divert_waittime = Column(Integer, nullable=False, server_default='0')
    timeout = Column(Integer, nullable=False, server_default='0')
    stat_queue_id = Column(Integer, ForeignKey("stat_queue.id"))

    stat_queue = relationship(StatQueue, foreign_keys=stat_queue_id)

----------------------------------------

File: alchemy/stat_switchboard_queue.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKeyConstraint, Index, PrimaryKeyConstraint
from sqlalchemy.types import DateTime, Float, Integer

from accent_dao.alchemy.enum import stat_switchboard_endtype
from accent_dao.alchemy.queuefeatures import QueueFeatures
from accent_dao.helpers.db_manager import Base


class StatSwitchboardQueue(Base):
    __tablename__ = 'stat_switchboard_queue'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        ForeignKeyConstraint(
            ('queue_id',),
            ('queuefeatures.id',),
            ondelete='CASCADE'
        ),
        Index('stat_switchboard_queue__idx__queue_id', 'queue_id'),
        Index('stat_switchboard_queue__idx__time', 'time'),
    )

    id = Column(Integer, nullable=False)
    time = Column(DateTime, nullable=False)
    end_type = Column(stat_switchboard_endtype, nullable=False)
    wait_time = Column(Float, nullable=False)
    queue_id = Column(Integer, nullable=False)

    queue = relationship(QueueFeatures)

----------------------------------------

File: alchemy/staticiax.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.sql import cast, func, not_
from sqlalchemy.types import Boolean, Integer, String

from accent_dao.helpers.db_manager import Base


class StaticIAX(Base):
    __tablename__ = 'staticiax'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('staticiax__idx__category', 'category'),
    )

    id = Column(Integer, nullable=False)
    cat_metric = Column(Integer, nullable=False, server_default='0')
    var_metric = Column(Integer, nullable=False, server_default='0')
    commented = Column(Integer, nullable=False, server_default='0')
    filename = Column(String(128), nullable=False)
    category = Column(String(128), nullable=False)
    var_name = Column(String(128), nullable=False)
    var_val = Column(String(255))

    trunk = relationship('TrunkFeatures', viewonly=True, uselist=False)

    @hybrid_property
    def metric(self):
        if self.var_metric == 0:
            return None
        return self.var_metric + 1

    @metric.expression
    def metric(cls):
        return func.nullif(cls.var_metric, 0)

    @metric.setter
    def metric(self, value):
        if value is None:
            self.var_metric = 0
        else:
            self.var_metric = value + 1

    @hybrid_property
    def enabled(self):
        if self.commented is None:
            return None
        return self.commented == 0

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False)

----------------------------------------

File: alchemy/staticqueue.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String

from accent_dao.helpers.db_manager import Base


class StaticQueue(Base):
    __tablename__ = 'staticqueue'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('staticqueue__idx__category', 'category')
    )

    id = Column(Integer, nullable=False)
    cat_metric = Column(Integer, nullable=False, server_default='0')
    var_metric = Column(Integer, nullable=False, server_default='0')
    commented = Column(Integer, nullable=False, server_default='0')
    filename = Column(String(128), nullable=False)
    category = Column(String(128), nullable=False)
    var_name = Column(String(128), nullable=False)
    var_val = Column(String(128))

----------------------------------------

File: alchemy/staticvoicemail.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.types import Integer, String, Text

from accent_dao.helpers.db_manager import Base


class StaticVoicemail(Base):
    __tablename__ = 'staticvoicemail'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        Index('staticvoicemail__idx__category', 'category')
    )

    id = Column(Integer, nullable=False)
    cat_metric = Column(Integer, nullable=False, server_default='0')
    var_metric = Column(Integer, nullable=False, server_default='0')
    commented = Column(Integer, nullable=False, server_default='0')
    filename = Column(String(128), nullable=False)
    category = Column(String(128), nullable=False)
    var_name = Column(String(128), nullable=False)
    var_val = Column(Text)

----------------------------------------

File: alchemy/stats_conf.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text
from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint, UniqueConstraint
from sqlalchemy.types import Integer, SmallInteger, String, Text, Time

from accent_dao.helpers.db_manager import Base


class StatsConf(Base):
    __tablename__ = 'stats_conf'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('name'),
        Index('stats_conf__idx__disable', 'disable'),
    )

    id = Column(Integer, nullable=False)
    name = Column(String(64), nullable=False, server_default='')
    hour_start = Column(Time, nullable=False)
    hour_end = Column(Time, nullable=False)
    homepage = Column(Integer)
    timezone = Column(String(128), nullable=False, server_default='')
    default_delta = Column(String(16), nullable=False, server_default='0')

    monday = Column(SmallInteger, nullable=False, server_default=text('0'))
    tuesday = Column(SmallInteger, nullable=False, server_default=text('0'))
    wednesday = Column(SmallInteger, nullable=False, server_default=text('0'))
    thursday = Column(SmallInteger, nullable=False, server_default=text('0'))
    friday = Column(SmallInteger, nullable=False, server_default=text('0'))
    saturday = Column(SmallInteger, nullable=False, server_default=text('0'))
    sunday = Column(SmallInteger, nullable=False, server_default=text('0'))

    period1 = Column(String(16), nullable=False, server_default='0')
    period2 = Column(String(16), nullable=False, server_default='0')
    period3 = Column(String(16), nullable=False, server_default='0')
    period4 = Column(String(16), nullable=False, server_default='0')
    period5 = Column(String(16), nullable=False, server_default='0')

    dbegcache = Column(Integer, server_default='0')
    dendcache = Column(Integer, server_default='0')
    dgenercache = Column(Integer, server_default='0')
    dcreate = Column(Integer, server_default='0')
    dupdate = Column(Integer, server_default='0')
    disable = Column(SmallInteger, nullable=False, server_default=text('0'))

    description = Column(Text)

----------------------------------------

File: alchemy/stats_conf_accentuser.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, PrimaryKeyConstraint
from sqlalchemy.types import Integer

from accent_dao.helpers.db_manager import Base


class StatsConfAccentUser(Base):

    __tablename__ = 'stats_conf_accentuser'
    __table_args__ = (
        PrimaryKeyConstraint('stats_conf_id', 'user_id'),
    )

    stats_conf_id = Column(Integer, nullable=False, autoincrement=False)
    user_id = Column(Integer, nullable=False, autoincrement=False)

----------------------------------------

File: alchemy/stats_conf_agent.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, PrimaryKeyConstraint
from sqlalchemy.types import Integer

from accent_dao.helpers.db_manager import Base


class StatsConfAgent(Base):

    __tablename__ = 'stats_conf_agent'
    __table_args__ = (
        PrimaryKeyConstraint('stats_conf_id', 'agentfeatures_id'),
    )

    stats_conf_id = Column(Integer, nullable=False, autoincrement=False)
    agentfeatures_id = Column(Integer, nullable=False, autoincrement=False)

----------------------------------------

File: alchemy/stats_conf_queue.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text
from sqlalchemy.schema import Column, PrimaryKeyConstraint
from sqlalchemy.types import Integer, SmallInteger

from accent_dao.helpers.db_manager import Base


class StatsConfQueue(Base):

    __tablename__ = 'stats_conf_queue'
    __table_args__ = (
        PrimaryKeyConstraint('stats_conf_id', 'queuefeatures_id'),
    )

    stats_conf_id = Column(Integer, nullable=False, autoincrement=False)
    queuefeatures_id = Column(Integer, nullable=False, autoincrement=False)
    qos = Column(SmallInteger, nullable=False, server_default=text('0'))

----------------------------------------

File: alchemy/switchboard.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.orm import relationship
from sqlalchemy.orm.collections import attribute_mapped_collection
from sqlalchemy.schema import Column, Index, PrimaryKeyConstraint
from sqlalchemy.sql.schema import ForeignKey
from sqlalchemy.types import Integer, String

from accent_dao.alchemy.switchboard_member_user import SwitchboardMemberUser
from accent_dao.helpers.db_manager import Base
from accent_dao.helpers.uuid import new_uuid


class Switchboard(Base):
    __tablename__ = 'switchboard'
    __table_args__ = (
        PrimaryKeyConstraint('uuid'),
        Index('switchboard__idx__tenant_uuid', 'tenant_uuid'),
        Index('switchboard__idx__hold_moh_uuid', 'hold_moh_uuid'),
        Index('switchboard__idx__queue_moh_uuid', 'queue_moh_uuid'),
    )

    uuid = Column(String(38), nullable=False, default=new_uuid)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(128), nullable=False)
    hold_moh_uuid = Column(
        String(38),
        ForeignKey('moh.uuid', ondelete='SET NULL'),
    )
    queue_moh_uuid = Column(
        String(38),
        ForeignKey('moh.uuid', ondelete='SET NULL'),
    )
    timeout = Column(Integer)

    incall_dialactions = relationship(
        'Dialaction',
        primaryjoin="""and_(
            Dialaction.category == 'incall',
            Dialaction.action == 'switchboard',
            Dialaction.actionarg1 == Switchboard.uuid
        )""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )

    incalls = association_proxy('incall_dialactions', 'incall')

    switchboard_dialactions = relationship(
        'Dialaction',
        primaryjoin="""and_(Dialaction.category == 'switchboard',
                            Dialaction.categoryval == Switchboard.uuid)""",
        cascade='all, delete-orphan',
        collection_class=attribute_mapped_collection('event'),
        foreign_keys='Dialaction.categoryval',
    )

    _dialaction_actions = relationship(
        'Dialaction',
        primaryjoin="""and_(
            Dialaction.action == 'switchboard',
            Dialaction.actionarg1 == Switchboard.uuid
        )""",
        foreign_keys='Dialaction.actionarg1',
        cascade='all, delete-orphan',
    )

    switchboard_member_users = relationship(
        'SwitchboardMemberUser',
        primaryjoin="""SwitchboardMemberUser.switchboard_uuid == Switchboard.uuid""",
        cascade='all, delete-orphan',
    )

    user_members = association_proxy(
        'switchboard_member_users',
        'user',
        creator=lambda _user: SwitchboardMemberUser(user=_user),
    )

    _queue_moh = relationship(
        'MOH', primaryjoin='Switchboard.queue_moh_uuid == MOH.uuid'
    )
    _hold_moh = relationship('MOH', primaryjoin='Switchboard.hold_moh_uuid == MOH.uuid')

    @property
    def queue_music_on_hold(self):
        return self._queue_moh.name if self._queue_moh else None

    @property
    def waiting_room_music_on_hold(self):
        return self._hold_moh.name if self._hold_moh else None

    @property
    def fallbacks(self):
        return self.switchboard_dialactions

    # Note: fallbacks[key] = Dialaction() doesn't pass in this method
    @fallbacks.setter
    def fallbacks(self, dialactions):
        for event in list(self.switchboard_dialactions.keys()):
            if event not in dialactions:
                self.switchboard_dialactions.pop(event, None)

        for event, dialaction in dialactions.items():
            self._set_dialaction(event, dialaction)

    def _set_dialaction(self, event, dialaction):
        if dialaction is None:
            self.switchboard_dialactions.pop(event, None)
            return

        if event not in self.switchboard_dialactions:
            dialaction.event = event
            dialaction.category = 'switchboard'
            self.switchboard_dialactions[event] = dialaction

        self.switchboard_dialactions[event].action = dialaction.action
        self.switchboard_dialactions[event].actionarg1 = dialaction.actionarg1
        self.switchboard_dialactions[event].actionarg2 = dialaction.actionarg2

----------------------------------------

File: alchemy/switchboard_member_user.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index, PrimaryKeyConstraint
from sqlalchemy.types import String

from accent_dao.helpers.db_manager import Base


class SwitchboardMemberUser(Base):
    __tablename__ = 'switchboard_member_user'
    __table_args__ = (
        PrimaryKeyConstraint('switchboard_uuid', 'user_uuid'),
        Index('switchboard_member_user__idx__switchboard_uuid', 'switchboard_uuid'),
        Index('switchboard_member_user__idx__user_uuid', 'user_uuid'),
    )

    switchboard_uuid = Column(
        String(38),
        ForeignKey('switchboard.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    user_uuid = Column(
        String(38),
        ForeignKey('userfeatures.uuid', ondelete='CASCADE'),
        nullable=False,
    )

    switchboard = relationship('Switchboard')
    user = relationship('UserFeatures')

----------------------------------------

File: alchemy/tenant.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index, PrimaryKeyConstraint
from sqlalchemy.types import Boolean, String

from accent_dao.helpers.db_manager import Base


class Tenant(Base):
    __tablename__ = 'tenant'
    __table_args__ = (
        PrimaryKeyConstraint('uuid'),
        Index('tenant__idx__global_sip_template_uuid', 'global_sip_template_uuid'),
        Index('tenant__idx__webrtc_sip_template_uuid', 'webrtc_sip_template_uuid'),
        Index(
            'tenant__idx__registration_trunk_sip_template_uuid',
            'registration_trunk_sip_template_uuid',
        ),
        Index(
            'tenant__idx__meeting_guest_sip_template_uuid',
            'meeting_guest_sip_template_uuid',
        ),
        Index(
            'tenant__idx__twilio_trunk_sip_template_uuid',
            'twilio_trunk_sip_template_uuid',
        ),
    )

    uuid = Column(String(36), server_default=text('uuid_generate_v4()'))
    slug = Column(String(10))
    sip_templates_generated = Column(Boolean, nullable=False, server_default='false')
    global_sip_template_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey(
            'endpoint_sip.uuid',
            ondelete='SET NULL',
            # NOTE: FK must be named to avoid circular deps on DROP
            name='tenant_global_sip_template_uuid_fkey',
        ),
    )
    webrtc_sip_template_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey(
            'endpoint_sip.uuid',
            ondelete='SET NULL',
            # NOTE: FK must be named to avoid circular deps on DROP
            name='tenant_webrtc_sip_template_uuid_fkey',
        ),
    )
    registration_trunk_sip_template_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey(
            'endpoint_sip.uuid',
            ondelete='SET NULL',
            # NOTE: FK must be named to avoid circular deps on DROP
            name='tenant_registration_trunk_sip_template_uuid_fkey',
        ),
    )
    meeting_guest_sip_template_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey(
            'endpoint_sip.uuid',
            ondelete='SET NULL',
            # NOTE: FK must be named to avoid circular deps on DROP
            name='tenant_meeting_guest_sip_template_uuid_fkey',
        ),
    )
    twilio_trunk_sip_template_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey(
            'endpoint_sip.uuid',
            ondelete='SET NULL',
            # NOTE: FK must be named to avoid circular deps on DROP
            name='tenant_twilio_trunk_sip_template_uuid_fkey',
        ),
    )
    country = Column(String(2), nullable=True)

    global_sip_template = relationship(
        'EndpointSIP',
        uselist=False,
        primaryjoin='EndpointSIP.uuid == Tenant.global_sip_template_uuid',
        viewonly=True,
    )
    webrtc_sip_template = relationship(
        'EndpointSIP',
        uselist=False,
        primaryjoin='EndpointSIP.uuid == Tenant.webrtc_sip_template_uuid',
        viewonly=True,
    )
    registration_trunk_sip_template = relationship(
        'EndpointSIP',
        uselist=False,
        primaryjoin='EndpointSIP.uuid == Tenant.registration_trunk_sip_template_uuid',
        viewonly=True,
    )
    meeting_guest_sip_template = relationship(
        'EndpointSIP',
        uselist=False,
        primaryjoin='EndpointSIP.uuid == Tenant.meeting_guest_sip_template_uuid',
        viewonly=True,
    )

----------------------------------------

File: alchemy/trunkfeatures.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    CheckConstraint,
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
)
from sqlalchemy.sql import case, select
from sqlalchemy.types import (
    Boolean,
    Integer,
    String,
    Text,
)

from accent_dao.helpers.db_manager import Base

from .endpoint_sip import EndpointSIP
from .outcalltrunk import OutcallTrunk
from .usercustom import UserCustom
from .useriax import UserIAX


class TrunkFeatures(Base):
    __tablename__ = 'trunkfeatures'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        CheckConstraint(
            '''
            ( CASE WHEN endpoint_sip_uuid IS NULL THEN 0 ELSE 1 END
            + CASE WHEN endpoint_iax_id IS NULL THEN 0 ELSE 1 END
            + CASE WHEN endpoint_custom_id IS NULL THEN 0 ELSE 1 END
            ) <= 1
            ''',
            name='trunkfeatures_endpoints_check',
        ),
        CheckConstraint(
            '''
            (
                register_iax_id IS NULL
            ) OR (
                register_iax_id IS NOT NULL AND
                endpoint_sip_uuid IS NULL AND
                endpoint_custom_id IS NULL
            )
            ''',
            name='trunkfeatures_endpoint_register_check',
        ),
        Index('trunkfeatures__idx__tenant_uuid', 'tenant_uuid'),
        Index('trunkfeatures__idx__endpoint_sip_uuid', 'endpoint_sip_uuid'),
        Index('trunkfeatures__idx__endpoint_iax_id', 'endpoint_iax_id'),
        Index('trunkfeatures__idx__endpoint_custom_id', 'endpoint_custom_id'),
        Index('trunkfeatures__idx__register_iax_id', 'register_iax_id'),
        Index('trunkfeatures__idx__registercommented', 'registercommented'),
    )

    id = Column(Integer, nullable=False)
    tenant_uuid = Column(
        String(36), ForeignKey('tenant.uuid', ondelete='CASCADE'), nullable=False
    )
    endpoint_sip_uuid = Column(
        UUID(as_uuid=True),
        ForeignKey('endpoint_sip.uuid', ondelete='SET NULL'),
    )
    endpoint_iax_id = Column(Integer, ForeignKey('useriax.id', ondelete='SET NULL'))
    endpoint_custom_id = Column(
        Integer, ForeignKey('usercustom.id', ondelete='SET NULL')
    )
    register_iax_id = Column(Integer, ForeignKey('staticiax.id', ondelete='SET NULL'))
    registercommented = Column(Integer, nullable=False, server_default='0')
    description = Column(Text)
    context = Column(String(79))
    outgoing_caller_id_format = Column(
        Text,
        CheckConstraint("outgoing_caller_id_format in ('+E164', 'E164', 'national')"),
        nullable=False,
        server_default='+E164',
    )
    twilio_incoming = Column(Boolean, nullable=False, server_default='False')

    endpoint_sip = relationship('EndpointSIP', viewonly=True)
    endpoint_iax = relationship('UserIAX', viewonly=True)
    endpoint_custom = relationship('UserCustom', viewonly=True)

    context_rel = relationship(
        'Context',
        primaryjoin='TrunkFeatures.context == Context.name',
        foreign_keys='TrunkFeatures.context',
        viewonly=True,
    )

    outcall_trunks = relationship(
        'OutcallTrunk',
        cascade='all, delete-orphan',
        back_populates='trunk',
    )

    outcalls = association_proxy(
        'outcall_trunks',
        'outcall',
        creator=lambda _outcall: OutcallTrunk(outcall=_outcall),
    )

    register_iax = relationship('StaticIAX', viewonly=True)

    @property
    def protocol(self):
        if self.endpoint_sip_uuid:
            return 'sip'
        elif self.endpoint_iax_id:
            return 'iax'
        elif self.endpoint_custom_id:
            return 'custom'

        if self.register_iax_id:
            return 'iax'

    @hybrid_property
    def name(self):
        if self.endpoint_sip and self.endpoint_sip.name not in ("", None):
            return self.endpoint_sip.name
        elif self.endpoint_iax and self.endpoint_iax.name not in ("", None):
            return self.endpoint_iax.name
        elif self.endpoint_custom and self.endpoint_custom.interface not in ("", None):
            return self.endpoint_custom.interface
        return None

    @name.expression
    def name(cls):
        endpoint_sip_query = (
            select([EndpointSIP.name])
            .where(EndpointSIP.uuid == cls.endpoint_sip_uuid)
            .as_scalar()
        )
        endpoint_iax_query = (
            select([UserIAX.name])
            .where(UserIAX.id == cls.endpoint_iax_id)
            .as_scalar()
        )  # fmt: skip
        endpoint_custom_query = (
            select([UserCustom.interface])
            .where(UserCustom.id == cls.endpoint_custom_id)
            .as_scalar()
        )
        return case(
            [
                (cls.endpoint_sip_uuid.isnot(None), endpoint_sip_query),
                (cls.endpoint_iax_id.isnot(None), endpoint_iax_query),
                (cls.endpoint_custom_id.isnot(None), endpoint_custom_query),
            ],
            else_=None,
        )

    @hybrid_property
    def label(self):
        if self.endpoint_sip and self.endpoint_sip.label not in ("", None):
            return self.endpoint_sip.label
        return None

    @label.expression
    def label(cls):
        endpoint_sip_query = (
            select([EndpointSIP.label])
            .where(EndpointSIP.uuid == cls.endpoint_sip_uuid)
            .as_scalar()
        )
        return case(
            [
                (cls.endpoint_sip_uuid.isnot(None), endpoint_sip_query),
            ],
            else_=None,
        )

----------------------------------------

File: alchemy/user_external_app.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.schema import Column, ForeignKey
from sqlalchemy.types import JSON, String, Text

from accent_dao.helpers.db_manager import Base


class UserExternalApp(Base):
    __tablename__ = 'user_external_app'

    name = Column(Text, primary_key=True)
    user_uuid = Column(
        String(38),
        ForeignKey('userfeatures.uuid', ondelete='CASCADE'),
        primary_key=True,
    )
    label = Column(Text)
    configuration = Column(JSON(none_as_null=True))

----------------------------------------

File: alchemy/user_line.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey, Index, PrimaryKeyConstraint
from sqlalchemy.types import Boolean, Integer

from accent_dao.helpers.db_manager import Base


class UserLine(Base):
    __tablename__ = 'user_line'
    __table_args__ = (
        PrimaryKeyConstraint('user_id', 'line_id'),
        Index('user_line__idx__user_id', 'user_id'),
        Index('user_line__idx__line_id', 'line_id'),
    )

    user_id = Column(
        Integer, ForeignKey('userfeatures.id', ondelete='CASCADE'), nullable=False
    )
    line_id = Column(
        Integer, ForeignKey('linefeatures.id', ondelete='CASCADE'), nullable=False
    )
    main_user = Column(Boolean, nullable=False)
    main_line = Column(Boolean, nullable=False)

    linefeatures = relationship("LineFeatures")
    userfeatures = relationship("UserFeatures")

    main_user_rel = relationship(
        "UserFeatures",
        primaryjoin="""and_(UserLine.user_id == UserFeatures.id,
                            UserLine.main_user == True)""",
    )

    main_line_rel = relationship(
        "LineFeatures",
        primaryjoin="""and_(UserLine.line_id == LineFeatures.id,
                            UserLine.main_line == True)""",
    )

    user = relationship('UserFeatures', back_populates='user_lines')

    line = relationship('LineFeatures', back_populates='user_lines')

----------------------------------------

File: alchemy/usercustom.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import cast, func, not_
from sqlalchemy.types import Boolean, Enum, Integer, String

from accent_dao.helpers.db_manager import Base

from . import enum


class UserCustom(Base):
    __tablename__ = 'usercustom'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('interface', 'intfsuffix', 'category'),
        Index('usercustom__idx__category', 'category'),
        Index('usercustom__idx__context', 'context'),
        Index('usercustom__idx__name', 'name'),
        Index('usercustom__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer, nullable=False)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(40))
    context = Column(String(79))
    interface = Column(String(128), nullable=False)
    intfsuffix = Column(String(32), nullable=False, server_default='')
    commented = Column(Integer, nullable=False, server_default='0')
    protocol = Column(enum.trunk_protocol, nullable=False, server_default='custom')
    category = Column(
        Enum('user', 'trunk', name='usercustom_category', metadata=Base.metadata),
        nullable=False,
    )

    line = relationship('LineFeatures', uselist=False, viewonly=True)
    trunk = relationship('TrunkFeatures', uselist=False, viewonly=True)

    @hybrid_property
    def enabled(self):
        return not bool(self.commented)

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        if value is None:
            self.commented = None
        else:
            self.commented = int(value is False)

    def endpoint_protocol(self):
        return 'custom'

    def same_protocol(self, protocol, protocolid):
        return protocol == 'custom' and self.id == int(protocolid)

    @hybrid_property
    def interface_suffix(self):
        if self.intfsuffix == '':
            return None
        return self.intfsuffix

    @interface_suffix.expression
    def interface_suffix(cls):
        return func.nullif(cls.intfsuffix, '')

    @interface_suffix.setter
    def interface_suffix(self, value):
        if value is None:
            self.intfsuffix = ''
        else:
            self.intfsuffix = value

----------------------------------------

File: alchemy/userfeatures.py
Please review for update

# Copyright 2023 Accent Communications

import datetime
import re

from sqlalchemy import text
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.ext.orderinglist import ordering_list
from sqlalchemy.orm import column_property, relationship
from sqlalchemy.orm.collections import attribute_mapped_collection
from sqlalchemy.orm.properties import ColumnProperty
from sqlalchemy.schema import (
    Column,
    ForeignKey,
    ForeignKeyConstraint,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import cast, func, not_
from sqlalchemy.types import (
    Boolean,
    DateTime,
    Integer,
    String,
    Text,
)

from accent_dao.helpers.db_manager import Base
from accent_dao.helpers.uuid import new_uuid

from . import enum
from .func_key_template import FuncKeyTemplate
from .queuemember import QueueMember
from .schedulepath import SchedulePath
from .user_line import UserLine


class EmailComparator(ColumnProperty.Comparator):
    def __eq__(self, other):
        return func.lower(self.__clause_element__()) == func.lower(other)


caller_id_regex = re.compile(
    r'''
    "                      #name start
    (?P<name>[^"]+)        #inside ""
    "                      #name end
    \s*                    #space between name and number
    (
    <                      #number start
    (?P<num>\+?[\dA-Z]+)   #inside <>
    >                      #number end
    )?                     #number is optional
    ''',
    re.VERBOSE,
)


def ordering_main_line(index, collection):
    return True if index == 0 else False


class UserFeatures(Base):
    __tablename__ = 'userfeatures'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        ForeignKeyConstraint(
            ('voicemailid',),
            ('voicemail.uniqueid',),
        ),
        ForeignKeyConstraint(
            ('tenant_uuid',),
            ('tenant.uuid',),
            ondelete='CASCADE',
        ),
        UniqueConstraint('func_key_private_template_id'),
        UniqueConstraint('uuid', name='userfeatures_uuid'),
        UniqueConstraint('email', name='userfeatures_email'),
        Index('userfeatures__idx__agentid', 'agentid'),
        Index('userfeatures__idx__firstname', 'firstname'),
        Index('userfeatures__idx__lastname', 'lastname'),
        Index('userfeatures__idx__loginclient', 'loginclient'),
        Index('userfeatures__idx__musiconhold', 'musiconhold'),
        Index('userfeatures__idx__uuid', 'uuid'),
        Index('userfeatures__idx__tenant_uuid', 'tenant_uuid'),
        Index('userfeatures__idx__voicemailid', 'voicemailid'),
        Index('userfeatures__idx__func_key_template_id', 'func_key_template_id'),
        Index(
            'userfeatures__idx__func_key_private_template_id',
            'func_key_private_template_id',
        ),
    )

    id = Column(Integer, nullable=False)
    uuid = Column(String(38), nullable=False, default=new_uuid)
    firstname = Column(String(128), nullable=False, server_default='')
    email = column_property(Column(String(254)), comparator_factory=EmailComparator)
    voicemailid = Column(Integer)
    agentid = Column(Integer)
    pictureid = Column(Integer)
    tenant_uuid = Column(String(36), nullable=False)
    callerid = Column(String(160))
    ringseconds = Column(Integer, nullable=False, server_default='30')
    simultcalls = Column(Integer, nullable=False, server_default='5')
    enableclient = Column(Integer, nullable=False, server_default='0')
    loginclient = Column(String(254), nullable=False, server_default='')
    passwdclient = Column(String(64), nullable=False, server_default='')
    enablehint = Column(Integer, nullable=False, server_default='1')
    enablevoicemail = Column(Integer, nullable=False, server_default='0')
    enablexfer = Column(Integer, nullable=False, server_default='0')
    dtmf_hangup = Column(Integer, nullable=False, server_default='0')
    enableonlinerec = Column(Integer, nullable=False, server_default='0')
    call_record_outgoing_external_enabled = Column(
        Boolean, nullable=False, server_default='false'
    )
    call_record_outgoing_internal_enabled = Column(
        Boolean, nullable=False, server_default='false'
    )
    call_record_incoming_external_enabled = Column(
        Boolean, nullable=False, server_default='false'
    )
    call_record_incoming_internal_enabled = Column(
        Boolean, nullable=False, server_default='false'
    )
    incallfilter = Column(Integer, nullable=False, server_default='0')
    enablednd = Column(Integer, nullable=False, server_default='0')
    enableunc = Column(Integer, nullable=False, server_default='0')
    destunc = Column(String(128), nullable=False, server_default='')
    enablerna = Column(Integer, nullable=False, server_default='0')
    destrna = Column(String(128), nullable=False, server_default='')
    enablebusy = Column(Integer, nullable=False, server_default='0')
    destbusy = Column(String(128), nullable=False, server_default='')
    musiconhold = Column(String(128), nullable=False, server_default='')
    outcallerid = Column(String(80), nullable=False, server_default='')
    mobilephonenumber = Column(String(128), nullable=False, server_default='')
    bsfilter = Column(enum.generic_bsfilter, nullable=False, server_default='no')
    preprocess_subroutine = Column(String(79))
    timezone = Column(String(128))
    language = Column(String(20))
    ringintern = Column(String(64))
    ringextern = Column(String(64))
    ringgroup = Column(String(64))
    ringforward = Column(String(64))
    rightcallcode = Column(String(16))
    commented = Column(Integer, nullable=False, server_default='0')
    func_key_template_id = Column(
        Integer, ForeignKey('func_key_template.id', ondelete="SET NULL")
    )
    func_key_private_template_id = Column(
        Integer, ForeignKey('func_key_template.id'), nullable=False
    )
    subscription_type = Column(Integer, nullable=False, server_default='0')
    created_at = Column(
        DateTime,
        default=datetime.datetime.utcnow,
        server_default=text("(now() at time zone 'utc')"),
    )

    webi_lastname = Column('lastname', String(128), nullable=False, server_default='')
    webi_userfield = Column('userfield', String(128), nullable=False, server_default='')
    webi_description = Column('description', Text, nullable=False, default='')

    func_key_template = relationship(FuncKeyTemplate, foreign_keys=func_key_template_id)
    func_key_template_private = relationship(
        FuncKeyTemplate, foreign_keys=func_key_private_template_id
    )

    main_line_rel = relationship(
        "UserLine",
        primaryjoin="""and_(
            UserFeatures.id == UserLine.user_id,
            UserLine.main_line == True
        )""",
    )
    agent = relationship(
        "AgentFeatures",
        primaryjoin="AgentFeatures.id == UserFeatures.agentid",
        foreign_keys='UserFeatures.agentid',
        viewonly=True,
    )

    voicemail = relationship("Voicemail", back_populates="users")

    user_lines = relationship(
        'UserLine',
        order_by='desc(UserLine.main_line)',
        collection_class=ordering_list('main_line', ordering_func=ordering_main_line),
        cascade='all, delete-orphan',
        back_populates='user',
    )
    lines = association_proxy(
        'user_lines',
        'line',
        creator=lambda _line: UserLine(line=_line, main_user=False),
    )

    incall_dialactions = relationship(
        'Dialaction',
        primaryjoin="""and_(
            Dialaction.category == 'incall',
            Dialaction.action == 'user',
            Dialaction.actionarg1 == cast(UserFeatures.id, String)
        )""",
        foreign_keys='Dialaction.actionarg1',
        viewonly=True,
    )
    incalls = association_proxy('incall_dialactions', 'incall')

    user_dialactions = relationship(
        'Dialaction',
        primaryjoin="""and_(
            Dialaction.category == 'user',
            Dialaction.categoryval == cast(UserFeatures.id, String)
        )""",
        cascade='all, delete-orphan',
        collection_class=attribute_mapped_collection('event'),
        foreign_keys='Dialaction.categoryval',
    )

    group_members = relationship(
        'QueueMember',
        primaryjoin="""and_(
            QueueMember.category == 'group',
            QueueMember.usertype == 'user',
            QueueMember.userid == UserFeatures.id
        )""",
        foreign_keys='QueueMember.userid',
        cascade='all, delete-orphan',
    )
    groups = association_proxy(
        'group_members',
        'group',
        creator=lambda _group: QueueMember(
            category='group', usertype='user', group=_group
        ),
    )

    queue_members = relationship(
        'QueueMember',
        primaryjoin="""and_(
            QueueMember.category == 'queue',
            QueueMember.usertype == 'user',
            QueueMember.userid == UserFeatures.id
        )""",
        foreign_keys='QueueMember.userid',
        cascade='all, delete-orphan',
    )
    queues = association_proxy('queue_members', 'queue')

    paging_users = relationship('PagingUser', cascade='all, delete-orphan')

    switchboard_member_users = relationship(
        'SwitchboardMemberUser', cascade='all, delete-orphan'
    )
    switchboards = association_proxy('switchboard_member_users', 'switchboard')

    _dialaction_actions = relationship(
        'Dialaction',
        primaryjoin="""and_(
            Dialaction.action == 'user',
            Dialaction.actionarg1 == cast(UserFeatures.id, String),
        )""",
        foreign_keys='Dialaction.actionarg1',
        cascade='all, delete-orphan',
    )

    schedule_paths = relationship(
        'SchedulePath',
        primaryjoin="""and_(
            SchedulePath.path == 'user',
            SchedulePath.pathid == UserFeatures.id
        )""",
        foreign_keys='SchedulePath.pathid',
        cascade='all, delete-orphan',
    )
    schedules = association_proxy(
        'schedule_paths',
        'schedule',
        creator=lambda _schedule: SchedulePath(
            path='user', schedule_id=_schedule.id, schedule=_schedule
        ),
    )

    call_filter_recipients = relationship(
        'Callfiltermember',
        primaryjoin="""and_(
            Callfiltermember.type == 'user',
            Callfiltermember.bstype == 'boss',
            Callfiltermember.typeval == cast(UserFeatures.id, String)
        )""",
        foreign_keys='Callfiltermember.typeval',
        cascade='delete, delete-orphan',
    )
    call_filter_surrogates = relationship(
        'Callfiltermember',
        primaryjoin="""and_(
            Callfiltermember.type == 'user',
            Callfiltermember.bstype == 'secretary',
            Callfiltermember.typeval == cast(UserFeatures.id, String)
        )""",
        foreign_keys='Callfiltermember.typeval',
        cascade='delete, delete-orphan',
    )

    call_pickup_interceptors = relationship(
        'PickupMember',
        primaryjoin="""and_(
            PickupMember.category == 'member',
            PickupMember.membertype == 'user',
            PickupMember.memberid == UserFeatures.id
        )""",
        foreign_keys='PickupMember.memberid',
        cascade='delete, delete-orphan',
    )
    call_pickup_targets = relationship(
        'PickupMember',
        primaryjoin="""and_(
            PickupMember.category == 'pickup',
            PickupMember.membertype == 'user',
            PickupMember.memberid == UserFeatures.id
        )""",
        foreign_keys='PickupMember.memberid',
        cascade='delete, delete-orphan',
    )

    rightcall_members = relationship(
        'RightCallMember',
        primaryjoin="""and_(
            RightCallMember.type == 'user',
            RightCallMember.typeval == cast(UserFeatures.id, String)
        )""",
        foreign_keys='RightCallMember.typeval',
        cascade='all, delete-orphan',
    )

    call_permissions = association_proxy('rightcall_members', 'rightcall')

    call_pickup_interceptor_pickups = relationship(
        'Pickup',
        primaryjoin="""and_(
            PickupMember.category == 'member',
            PickupMember.membertype == 'user',
            PickupMember.memberid == UserFeatures.id
        )""",
        secondary="pickupmember",
        secondaryjoin="Pickup.id == pickupmember.c.pickupid",
        foreign_keys='PickupMember.pickupid,PickupMember.memberid',
        viewonly=True,
    )

    users_from_call_pickup_user_targets = association_proxy(
        'call_pickup_interceptor_pickups', 'user_targets'
    )
    users_from_call_pickup_group_targets = association_proxy(
        'call_pickup_interceptor_pickups', 'users_from_group_targets'
    )
    users_from_call_pickup_group_interceptors_user_targets = association_proxy(
        'group_members', 'users_from_call_pickup_group_interceptor_user_targets'
    )
    users_from_call_pickup_group_interceptors_group_targets = association_proxy(
        'group_members', 'users_from_call_pickup_group_interceptor_group_targets'
    )

    func_keys = relationship('FuncKeyDestUser', cascade='all, delete-orphan')
    tenant = relationship('Tenant')

    def extrapolate_caller_id(self, extension=None):
        default_num = extension.exten if extension else None
        user_match = caller_id_regex.match(self.callerid)
        name = user_match.group('name')
        num = user_match.group('num')
        return name, (num or default_num)

    def fill_caller_id(self):
        if self.caller_id is None:
            self.caller_id = f'"{self.fullname}"'

    @property
    def fallbacks(self):
        return self.user_dialactions

    @fallbacks.setter
    def fallbacks(self, dialactions):
        for event in list(self.user_dialactions.keys()):
            if event not in dialactions:
                self.user_dialactions.pop(event, None)

        for event, dialaction in dialactions.items():
            if dialaction is None:
                self.user_dialactions.pop(event, None)
                continue

            if event not in self.user_dialactions:
                dialaction.category = 'user'
                dialaction.event = event
                self.user_dialactions[event] = dialaction

            self.user_dialactions[event].action = dialaction.action
            self.user_dialactions[event].actionarg1 = dialaction.actionarg1
            self.user_dialactions[event].actionarg2 = dialaction.actionarg2

    @hybrid_property
    def fullname(self):
        name = self.firstname
        if self.lastname:
            name += f" {self.lastname}"
        return name

    @fullname.expression
    def fullname(cls):
        return func.trim(cls.firstname + " " + cls.webi_lastname)

    @hybrid_property
    def username(self):
        if self.loginclient == '':
            return None
        return self.loginclient

    @username.expression
    def username(cls):
        return func.nullif(cls.loginclient, '')

    @username.setter
    def username(self, value):
        if value is None:
            self.loginclient = ''
        else:
            self.loginclient = value

    @hybrid_property
    def password(self):
        if self.passwdclient == '':
            return None
        return self.passwdclient

    @password.expression
    def password(cls):
        return func.nullif(cls.passwdclient, '')

    @password.setter
    def password(self, value):
        if value is None:
            self.passwdclient = ''
        else:
            self.passwdclient = value

    @hybrid_property
    def agent_id(self):
        return self.agentid

    @agent_id.setter
    def agent_id(self, value):
        self.agentid = value

    @hybrid_property
    def caller_id(self):
        if self.callerid == '':
            return None
        return self.callerid

    @caller_id.expression
    def caller_id(cls):
        return func.nullif(cls.callerid, '')

    @caller_id.setter
    def caller_id(self, value):
        if value is None:
            self.callerid = ''
        else:
            self.callerid = value

    @hybrid_property
    def outgoing_caller_id(self):
        if self.outcallerid == '':
            return None
        return self.outcallerid

    @outgoing_caller_id.expression
    def outgoing_caller_id(cls):
        return func.nullif(cls.outcallerid, '')

    @outgoing_caller_id.setter
    def outgoing_caller_id(self, value):
        if value is None:
            self.outcallerid = ''
        else:
            self.outcallerid = value

    @hybrid_property
    def music_on_hold(self):
        if self.musiconhold == '':
            return None
        return self.musiconhold

    @music_on_hold.expression
    def music_on_hold(cls):
        return func.nullif(cls.musiconhold, '')

    @music_on_hold.setter
    def music_on_hold(self, value):
        if value is None:
            self.musiconhold = ''
        else:
            self.musiconhold = value

    @hybrid_property
    def mobile_phone_number(self):
        if self.mobilephonenumber == '':
            return None
        return self.mobilephonenumber

    @mobile_phone_number.expression
    def mobile_phone_number(cls):
        return func.nullif(cls.mobilephonenumber, '')

    @mobile_phone_number.setter
    def mobile_phone_number(self, value):
        if value is None:
            self.mobilephonenumber = ''
        else:
            self.mobilephonenumber = value

    @hybrid_property
    def voicemail_id(self):
        return self.voicemailid

    @voicemail_id.setter
    def voicemail_id(self, value):
        self.voicemailid = value

    @hybrid_property
    def userfield(self):
        if self.webi_userfield == '':
            return None
        return self.webi_userfield

    @userfield.expression
    def userfield(cls):
        return func.nullif(cls.webi_userfield, '')

    @userfield.setter
    def userfield(self, value):
        if value is None:
            self.webi_userfield = ''
        else:
            self.webi_userfield = value

    @hybrid_property
    def lastname(self):
        if self.webi_lastname == '':
            return None
        return self.webi_lastname

    @lastname.expression
    def lastname(cls):
        return func.nullif(cls.webi_lastname, '')

    @lastname.setter
    def lastname(self, value):
        if value is None:
            self.webi_lastname = ''
        else:
            self.webi_lastname = value

    @hybrid_property
    def description(self):
        if self.webi_description == '':
            return None
        return self.webi_description

    @description.expression
    def description(cls):
        return func.nullif(cls.webi_description, '')

    @description.setter
    def description(self, value):
        if value is None:
            self.webi_description = ''
        else:
            self.webi_description = value

    @hybrid_property
    def template_id(self):
        return self.func_key_template_id

    @template_id.setter
    def template_id(self, value):
        self.func_key_template_id = value

    @hybrid_property
    def private_template_id(self):
        return self.func_key_private_template_id

    @private_template_id.setter
    def private_template_id(self, value):
        self.func_key_private_template_id = value

    @hybrid_property
    def incallfilter_enabled(self):
        return self.incallfilter == 1

    @incallfilter_enabled.setter
    def incallfilter_enabled(self, value):
        self.incallfilter = int(value == 1) if value is not None else None

    @hybrid_property
    def dnd_enabled(self):
        return self.enablednd == 1

    @dnd_enabled.setter
    def dnd_enabled(self, value):
        self.enablednd = int(value == 1) if value is not None else None

    @hybrid_property
    def supervision_enabled(self):
        if self.enablehint is None:
            return None
        return self.enablehint == 1

    @supervision_enabled.setter
    def supervision_enabled(self, value):
        self.enablehint = int(value == 1) if value is not None else None

    @hybrid_property
    def call_transfer_enabled(self):
        if self.enablexfer is None:
            return None
        return self.enablexfer == 1

    @call_transfer_enabled.setter
    def call_transfer_enabled(self, value):
        self.enablexfer = int(value == 1) if value is not None else None

    @hybrid_property
    def dtmf_hangup_enabled(self):
        if self.dtmf_hangup is None:
            return None
        return self.dtmf_hangup == 1

    @dtmf_hangup_enabled.setter
    def dtmf_hangup_enabled(self, value):
        self.dtmf_hangup = int(value == 1) if value is not None else None

    @hybrid_property
    def online_call_record_enabled(self):
        if self.enableonlinerec is None:
            return None
        return self.enableonlinerec == 1

    @online_call_record_enabled.setter
    def online_call_record_enabled(self, value):
        self.enableonlinerec = int(value == 1) if value is not None else None

    @hybrid_property
    def ring_seconds(self):
        return self.ringseconds

    @ring_seconds.setter
    def ring_seconds(self, value):
        self.ringseconds = value

    @hybrid_property
    def simultaneous_calls(self):
        return self.simultcalls

    @simultaneous_calls.setter
    def simultaneous_calls(self, value):
        self.simultcalls = value

    @hybrid_property
    def cti_enabled(self):
        if self.enableclient is None:
            return None
        return self.enableclient == 1

    @cti_enabled.setter
    def cti_enabled(self, value):
        self.enableclient = int(value == 1) if value is not None else None

    @hybrid_property
    def busy_enabled(self):
        if self.enablebusy is None:
            return None
        return self.enablebusy == 1

    @busy_enabled.setter
    def busy_enabled(self, value):
        self.enablebusy = int(value == 1) if value is not None else None

    @hybrid_property
    def busy_destination(self):
        if self.destbusy == '':
            return None
        return self.destbusy

    @busy_destination.expression
    def busy_destination(cls):
        return func.nullif(cls.destbusy, '')

    @busy_destination.setter
    def busy_destination(self, value):
        if value is None:
            self.destbusy = ''
        else:
            self.destbusy = value

    @hybrid_property
    def noanswer_enabled(self):
        if self.enablerna is None:
            return None
        return self.enablerna == 1

    @noanswer_enabled.setter
    def noanswer_enabled(self, value):
        self.enablerna = int(value == 1) if value is not None else None

    @hybrid_property
    def noanswer_destination(self):
        if self.destrna == '':
            return None
        return self.destrna

    @noanswer_destination.expression
    def noanswer_destination(cls):
        return func.nullif(cls.destrna, '')

    @noanswer_destination.setter
    def noanswer_destination(self, value):
        if value is None:
            self.destrna = ''
        else:
            self.destrna = value

    @hybrid_property
    def unconditional_enabled(self):
        if self.enableunc is None:
            return None
        return self.enableunc == 1

    @unconditional_enabled.setter
    def unconditional_enabled(self, value):
        self.enableunc = int(value == 1) if value is not None else None

    @hybrid_property
    def unconditional_destination(self):
        if self.destunc == '':
            return None
        return self.destunc

    @unconditional_destination.expression
    def unconditional_destination(cls):
        return func.nullif(cls.destunc, '')

    @unconditional_destination.setter
    def unconditional_destination(self, value):
        if value is None:
            self.destunc = ''
        else:
            self.destunc = value

    @hybrid_property
    def enabled(self):
        if self.commented is None:
            return None
        return self.commented == 0

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False) if value is not None else None

    @hybrid_property
    def call_permission_password(self):
        if self.rightcallcode == '':
            return None
        return self.rightcallcode

    @call_permission_password.expression
    def call_permission_password(cls):
        return func.nullif(cls.rightcallcode, '')

    @call_permission_password.setter
    def call_permission_password(self, value):
        if value == '':
            self.rightcallcode = None
        else:
            self.rightcallcode = value

    @property
    def forwards(self):
        return self

    @property
    def services(self):
        return self

    @property
    def country(self):
        return self.tenant.country

----------------------------------------

File: alchemy/useriax.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.dialects.postgresql import ARRAY
from sqlalchemy.orm import relationship
from sqlalchemy.schema import (
    Column,
    ForeignKey,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.types import Enum, Integer, String, Text

from accent_dao.helpers.asterisk import AsteriskOptionsMixin
from accent_dao.helpers.db_manager import Base

from . import enum


class UserIAX(Base, AsteriskOptionsMixin):
    EXCLUDE_OPTIONS = {  # noqa: RUF012
        'id',
        'commented',
        'options',
        'tenant_uuid',
    }
    EXCLUDE_OPTIONS_CONFD = {  # noqa: RUF012
        'name',
        'type',
        'host',
        'context',
        'category',
        'protocol',
    }
    AST_TRUE_INTEGER_COLUMNS = {  # noqa: RUF012
        'trunk',
        'adsi',
        'jitterbuffer',
        'forcejitterbuffer',
        'sendani',
        'qualifysmoothing',
        'immediate',
        'keyrotate',
    }

    __tablename__ = 'useriax'
    __table_args__ = (
        PrimaryKeyConstraint('id'),
        UniqueConstraint('name'),
        Index('useriax__idx__category', 'category'),
        Index('useriax__idx__mailbox', 'mailbox'),
        Index('useriax__idx__tenant_uuid', 'tenant_uuid'),
    )

    id = Column(Integer, nullable=False)
    tenant_uuid = Column(
        String(36),
        ForeignKey('tenant.uuid', ondelete='CASCADE'),
        nullable=False,
    )
    name = Column(String(40), nullable=False)
    type = Column(
        Enum('friend', 'peer', 'user', name='useriax_type', metadata=Base.metadata),
        nullable=False,
    )
    username = Column(String(80))
    secret = Column(String(80), nullable=False, server_default='')
    dbsecret = Column(String(255), nullable=False, server_default='')
    context = Column(String(79))
    language = Column(String(20))
    accountcode = Column(String(20))
    amaflags = Column(
        Enum(
            'default',
            'omit',
            'billing',
            'documentation',
            name='useriax_amaflags',
            metadata=Base.metadata,
        ),
        server_default='default',
    )
    mailbox = Column(String(80))
    callerid = Column(String(160))
    fullname = Column(String(80))
    cid_number = Column(String(80))
    trunk = Column(Integer, nullable=False, server_default='0')
    auth = Column(
        Enum(
            'plaintext',
            'md5',
            'rsa',
            'plaintext,md5',
            'plaintext,rsa',
            'md5,rsa',
            'plaintext,md5,rsa',
            name='useriax_auth',
            metadata=Base.metadata,
        ),
        nullable=False,
        server_default='plaintext,md5',
    )
    encryption = Column(
        Enum('no', 'yes', 'aes128', name='useriax_encryption', metadata=Base.metadata)
    )
    forceencryption = Column(
        Enum('no', 'yes', 'aes128', name='useriax_encryption', metadata=Base.metadata)
    )
    maxauthreq = Column(Integer)
    inkeys = Column(String(80))
    outkey = Column(String(80))
    adsi = Column(Integer)
    transfer = Column(
        Enum('no', 'yes', 'mediaonly', name='useriax_transfer', metadata=Base.metadata)
    )
    codecpriority = Column(
        Enum(
            'disabled',
            'host',
            'caller',
            'reqonly',
            name='useriax_codecpriority',
            metadata=Base.metadata,
        )
    )
    jitterbuffer = Column(Integer)
    forcejitterbuffer = Column(Integer)
    sendani = Column(Integer, nullable=False, server_default='0')
    qualify = Column(String(4), nullable=False, server_default='no')
    qualifysmoothing = Column(Integer, nullable=False, server_default='0')
    qualifyfreqok = Column(Integer, nullable=False, server_default='60000')
    qualifyfreqnotok = Column(Integer, nullable=False, server_default='10000')
    timezone = Column(String(80))
    disallow = Column(String(100))
    allow = Column(Text)
    mohinterpret = Column(String(80))
    mohsuggest = Column(String(80))
    deny = Column(String(31))
    permit = Column(String(31))
    defaultip = Column(String(255))
    sourceaddress = Column(String(255))
    setvar = Column(String(100), nullable=False, server_default='')
    host = Column(String(255), nullable=False, server_default='dynamic')
    port = Column(Integer)
    mask = Column(String(15))
    regexten = Column(String(80))
    peercontext = Column(String(80))
    immediate = Column(Integer)
    keyrotate = Column(Integer)
    parkinglot = Column(Integer)
    protocol = Column(enum.trunk_protocol, nullable=False, server_default='iax')
    category = Column(
        Enum('user', 'trunk', name='useriax_category', metadata=Base.metadata),
        nullable=False,
    )
    commented = Column(Integer, nullable=False, server_default='0')
    requirecalltoken = Column(String(4), nullable=False, server_default='no')
    _options = Column(
        "options",
        ARRAY(String, dimensions=2),
        nullable=False,
        default=list,
        server_default='{}',
    )

    trunk_rel = relationship('TrunkFeatures', uselist=False, viewonly=True)

    def endpoint_protocol(self):
        return 'iax'

    def same_protocol(self, protocol, id):
        return protocol == 'iax' and self.id == id


----------------------------------------

File: alchemy/voicemail.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import Boolean, ForeignKeyConstraint, sql
from sqlalchemy.dialects.postgresql import ARRAY
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship
from sqlalchemy.orm.attributes import get_history
from sqlalchemy.schema import (
    Column,
    Index,
    PrimaryKeyConstraint,
    UniqueConstraint,
)
from sqlalchemy.sql import (
    cast,
    not_,
)
from sqlalchemy.types import (
    Integer,
    String,
)

from accent_dao.helpers.db_manager import Base

from .context import Context


class Voicemail(Base):
    __tablename__ = 'voicemail'
    __table_args__ = (
        PrimaryKeyConstraint('uniqueid'),
        UniqueConstraint('mailbox', 'context'),
        Index('voicemail__idx__context', 'context'),
        ForeignKeyConstraint(
            ('context',),
            ('context.name',),
            ondelete='CASCADE',
        ),
    )

    uniqueid = Column(Integer)
    context = Column(String(79), nullable=False)
    mailbox = Column(String(40), nullable=False)
    password = Column(String(80))
    fullname = Column(String(80), nullable=False, server_default='')
    email = Column(String(80))
    pager = Column(String(80))
    language = Column(String(20))
    tz = Column(String(80))
    attach = Column(Integer)
    deletevoicemail = Column(Integer, nullable=False, server_default='0')
    maxmsg = Column(Integer)
    skipcheckpass = Column(Integer, nullable=False, server_default='0')
    options = Column(ARRAY(String, dimensions=2), nullable=False, server_default='{}')
    commented = Column(Integer, nullable=False, server_default='0')

    users = relationship('UserFeatures', back_populates='voicemail')

    dialaction_actions = relationship(
        'Dialaction',
        primaryjoin="""and_(Dialaction.action == 'voicemail',
                            Dialaction.actionarg1 == cast(Voicemail.id, String))""",
        foreign_keys='Dialaction.actionarg1',
        cascade='all, delete-orphan',
    )

    context_rel = relationship(
        'Context',
        primaryjoin='Voicemail.context == Context.name',
        foreign_keys='Voicemail.context',
        viewonly=True,
    )

    def get_old_number_context(self):
        number_history = get_history(self, 'mailbox')
        context_history = get_history(self, 'context')

        old_number = self.number
        if number_history[2]:
            old_number = number_history[2][0]

        old_context = self.context
        if context_history[2]:
            old_context = context_history[2][0]

        return old_number, old_context

    @hybrid_property
    def id(self):
        return self.uniqueid

    @id.setter
    def id(self, value):
        self.uniqueid = value

    @hybrid_property
    def name(self):
        return self.fullname

    @name.setter
    def name(self, value):
        self.fullname = value

    @hybrid_property
    def number(self):
        return self.mailbox

    @number.setter
    def number(self, value):
        self.mailbox = value

    @hybrid_property
    def timezone(self):
        return self.tz

    @timezone.setter
    def timezone(self, value):
        self.tz = value

    @hybrid_property
    def max_messages(self):
        return self.maxmsg

    @max_messages.setter
    def max_messages(self, value):
        self.maxmsg = value

    @hybrid_property
    def attach_audio(self):
        if self.attach is None:
            return None
        return bool(self.attach)

    @attach_audio.setter
    def attach_audio(self, value):
        self.attach = int(value) if value is not None else None

    @hybrid_property
    def delete_messages(self):
        return bool(self.deletevoicemail)

    @delete_messages.setter
    def delete_messages(self, value):
        self.deletevoicemail = int(value)

    @hybrid_property
    def ask_password(self):
        return not bool(self.skipcheckpass)

    @ask_password.expression
    def ask_password(cls):
        return sql.not_(sql.cast(cls.skipcheckpass, Boolean))

    @ask_password.setter
    def ask_password(self, value):
        self.skipcheckpass = int(not value)

    @hybrid_property
    def enabled(self):
        if self.commented is None:
            return None
        return self.commented == 0

    @enabled.expression
    def enabled(cls):
        return not_(cast(cls.commented, Boolean))

    @enabled.setter
    def enabled(self, value):
        self.commented = int(value is False) if value is not None else None

    @hybrid_property
    def tenant_uuid(self):
        return self.context_rel.tenant_uuid

    @tenant_uuid.expression
    def tenant_uuid(cls):
        return (
            sql.select([Context.tenant_uuid])
            .where(
                Context.name == cls.context,
            )
            .label('tenant_uuid')
        )

----------------------------------------

File: asterisk_conf_dao.py
Please review for update

# Copyright 2023 Accent Communications

from __future__ import annotations

from collections import defaultdict
from typing import NamedTuple

from sqlalchemy import bindparam
from sqlalchemy.ext import baked
from sqlalchemy.orm import joinedload
from sqlalchemy.sql.expression import (
    and_,
    cast,
    func,
    literal,
    or_,
    true,
)
from sqlalchemy.types import Integer

from accent_dao.alchemy.agentfeatures import AgentFeatures
from accent_dao.alchemy.agentqueueskill import AgentQueueSkill
from accent_dao.alchemy.context import Context
from accent_dao.alchemy.contextinclude import ContextInclude
from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.feature_extension import FeatureExtension
from accent_dao.alchemy.features import Features
from accent_dao.alchemy.func_key_dest_custom import FuncKeyDestCustom
from accent_dao.alchemy.func_key_mapping import FuncKeyMapping
from accent_dao.alchemy.groupfeatures import GroupFeatures
from accent_dao.alchemy.iaxcallnumberlimits import IAXCallNumberLimits
from accent_dao.alchemy.line_extension import LineExtension
from accent_dao.alchemy.linefeatures import LineFeatures
from accent_dao.alchemy.meeting import Meeting
from accent_dao.alchemy.pickup import Pickup
from accent_dao.alchemy.pickupmember import PickupMember
from accent_dao.alchemy.queue import Queue
from accent_dao.alchemy.queuefeatures import QueueFeatures
from accent_dao.alchemy.queuemember import QueueMember
from accent_dao.alchemy.queueskill import QueueSkill
from accent_dao.alchemy.queueskillrule import QueueSkillRule
from accent_dao.alchemy.sccpdevice import SCCPDevice
from accent_dao.alchemy.sccpgeneralsettings import SCCPGeneralSettings
from accent_dao.alchemy.sccpline import SCCPLine
from accent_dao.alchemy.staticiax import StaticIAX
from accent_dao.alchemy.staticqueue import StaticQueue
from accent_dao.alchemy.staticvoicemail import StaticVoicemail
from accent_dao.alchemy.trunkfeatures import TrunkFeatures
from accent_dao.alchemy.user_line import UserLine
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.alchemy.useriax import UserIAX
from accent_dao.alchemy.voicemail import Voicemail
from accent_dao.helpers.db_manager import daosession


class Member(NamedTuple):
    interface: str
    penalty: str
    name: str
    state_interface: str


@daosession
def find_sccp_general_settings(session):
    rows = session.query(SCCPGeneralSettings).all()

    voicemail_consult_exten = (
        session.query(
            literal('vmexten').label('option_name'),
            FeatureExtension.exten.label('option_value'),
        )
        .filter(
            and_(
                FeatureExtension.feature == 'vmusermsg',
            )
        )
        .first()
    )

    res = [
        {
            'option_name': row.option_name,
            'option_value': row.option_value,
        }
        for row in rows
    ]

    res.append(
        {
            'option_name': voicemail_consult_exten.option_name,
            'option_value': voicemail_consult_exten.option_value,
        }
    )

    return res


@daosession
def find_sccp_line_settings(session):
    sccp_pickup_members = find_pickup_members('sccp')

    def line_config(*args):
        (
            endpoint_sccp_id,
            tenant_uuid,
            name,
            cid_name,
            cid_num,
            allow,
            disallow,
            language,
            user_id,
            context,
            number,
            uuid,
            enable_online_recording,
        ) = args

        line = {
            'id': endpoint_sccp_id,
            'name': name,
            'cid_name': cid_name,
            'cid_num': cid_num,
            'user_id': user_id,
            'number': number,
            'context': context,
            'language': language,
            'uuid': uuid,
            'tenant_uuid': tenant_uuid,
            'enable_online_recording': enable_online_recording,
        }

        if allow:
            line['allow'] = allow
        if disallow:
            line['disallow'] = disallow

        line.update(sccp_pickup_members.get(endpoint_sccp_id, {}))

        return line

    rows = (
        session.query(
            SCCPLine.id,
            SCCPLine.tenant_uuid,
            SCCPLine.name,
            SCCPLine.cid_name,
            SCCPLine.cid_num,
            SCCPLine.allow,
            SCCPLine.disallow,
            UserFeatures.language,
            UserLine.user_id,
            LineFeatures.context,
            Extension.exten,
            UserFeatures.uuid,
            UserFeatures.enableonlinerec,
        )
        .join(
            LineFeatures,
            and_(
                LineFeatures.endpoint_sccp_id == SCCPLine.id,
            ),
        )
        .join(
            UserLine,
            UserLine.line_id == LineFeatures.id,
        )
        .join(
            UserFeatures,
            and_(
                UserFeatures.id == UserLine.user_id,
                UserLine.main_user.is_(True),
            ),
        )
        .join(
            LineExtension,
            and_(
                LineFeatures.id == LineExtension.line_id,
                LineExtension.main_extension.is_(True),
            ),
        )
        .join(
            Extension,
            LineExtension.extension_id == Extension.id,
        )
        .filter(LineFeatures.commented == 0)
        .all()
    )

    for row in rows:
        yield line_config(*row)


@daosession
def find_sccp_device_settings(session):
    query = (
        session.query(
            SCCPDevice,
            Voicemail.mailbox,
        )
        .outerjoin(
            SCCPLine,
            SCCPLine.name == SCCPDevice.line,
        )
        .outerjoin(
            LineFeatures,
            and_(
                LineFeatures.endpoint_sccp_id == SCCPLine.id,
            ),
        )
        .outerjoin(
            UserLine,
            and_(
                UserLine.line_id == LineFeatures.id,
                UserLine.main_user.is_(True),
            ),
        )
        .outerjoin(
            UserFeatures,
            UserFeatures.id == UserLine.user_id,
        )
        .outerjoin(
            Voicemail,
            Voicemail.uniqueid == UserFeatures.voicemailid,
        )
    )

    devices = []
    for row in query:
        device = row.SCCPDevice.todict()
        device['voicemail'] = row.mailbox
        devices.append(device)

    return devices


@daosession
def find_sccp_speeddial_settings(session):
    invalid_chars = '\n\r\t;'
    query = (
        session.query(
            FuncKeyMapping.position.label('fknum'),
            func.translate(FuncKeyMapping.label, invalid_chars, '').label('label'),
            cast(FuncKeyMapping.blf, Integer).label('supervision'),
            func.translate(FuncKeyDestCustom.exten, invalid_chars, '').label('exten'),
            UserFeatures.id.label('user_id'),
            SCCPDevice.device.label('device'),
        )
        .join(
            UserFeatures,
            FuncKeyMapping.template_id == UserFeatures.func_key_private_template_id,
        )
        .join(
            FuncKeyDestCustom,
            FuncKeyDestCustom.func_key_id == FuncKeyMapping.func_key_id,
        )
        .join(
            UserLine,
            and_(
                UserLine.user_id == UserFeatures.id,
                UserLine.main_user.is_(True),
            ),
        )
        .join(
            LineFeatures,
            UserLine.line_id == LineFeatures.id,
        )
        .join(
            SCCPLine,
            and_(
                LineFeatures.endpoint_sccp_id == SCCPLine.id,
            ),
        )
        .join(
            SCCPDevice,
            SCCPLine.name == SCCPDevice.line,
        )
        .filter(LineFeatures.commented == 0)
    )

    return [
        {
            'exten': row.exten,
            'fknum': row.fknum,
            'label': row.label,
            'supervision': row.supervision,
            'user_id': row.user_id,
            'device': row.device,
        }
        for row in query
    ]


@daosession
def find_features_settings(session):
    rows = (
        session.query(
            Features.category,
            Features.var_name,
            Features.var_val,
        )
        .filter(
            and_(
                Features.commented == 0,
                or_(
                    Features.category == 'general',
                    Features.category == 'featuremap',
                    Features.category == 'applicationmap',
                ),
            )
        )
        .all()
    )

    general_options = []
    featuremap_options = []
    applicationmap_options = []
    for row in rows:
        option = (row.var_name, row.var_val)
        if row.category == 'general':
            general_options.append(option)
        elif row.category == 'applicationmap':
            applicationmap_options.append(option)
        elif row.category == 'featuremap':
            featuremap_options.append(option)
            if row.var_name == 'disconnect':
                option = ('atxferabort', row.var_val)
                general_options.append(option)

    return {
        'general_options': general_options,
        'featuremap_options': featuremap_options,
        'applicationmap_options': applicationmap_options,
    }


@daosession
def find_exten_conferences_settings(session, context_name):
    rows = (
        session.query(Extension.exten)
        .filter(
            and_(
                Extension.type == 'conference',
                Extension.context == context_name,
                Extension.commented == 0,
            )
        )
        .order_by('exten')
        .all()
    )
    return [{'exten': row[0]} for row in rows]


@daosession
def find_exten_accentfeatures_setting(session):
    rows = (
        session.query(FeatureExtension)
        .filter(
            FeatureExtension.enabled == true(),
        )
        .order_by('exten')
        .all()
    )

    return [row.todict() for row in rows]


@daosession
def find_extenfeatures_settings(session, features):
    query = (
        session.query(FeatureExtension)
        .filter(
            and_(
                FeatureExtension.feature.in_(features),
            )
        )
        .order_by('exten')
    )

    return query.all()


exten_settings_bakery = baked.bakery()
exten_settings_query = exten_settings_bakery(
    lambda s: s.query(
        Extension,
    )
    .outerjoin(
        LineExtension,
        Extension.id == LineExtension.extension_id,
    )
    .outerjoin(
        LineFeatures,
        LineFeatures.id == LineExtension.line_id,
    )
    .filter(
        and_(
            Extension.commented == 0,
            Extension.typeval != '0',
            Extension.type != 'parking',
            or_(
                LineExtension.line_id.is_(None),
                LineFeatures.commented == 0,
            ),
        )
    )
    .order_by('exten')
)
exten_settings_query += lambda q: q.filter(Extension.context == bindparam('context'))


@daosession
def find_exten_settings(session, context_name):
    rows = exten_settings_query(session).params(context=context_name).all()
    return [
        dict(tenant_uuid=row.context_rel.tenant_uuid, **row.todict()) for row in rows
    ]


@daosession
def find_context_settings(session):
    rows = session.query(Context).filter(Context.commented == 0).order_by('name').all()

    return [row.todict() for row in rows]


context_include_bakery = baked.bakery()
context_include_query = context_include_bakery(
    lambda s: s.query(ContextInclude).order_by('priority')
)
context_include_query += lambda q: q.filter(
    ContextInclude.context == bindparam('context')
)


@daosession
def find_contextincludes_settings(session, context_name):
    rows = context_include_query(session).params(context=context_name).all()
    return [row.todict() for row in rows]


@daosession
def find_voicemail_activated(session):
    rows = session.query(Voicemail).filter(Voicemail.commented == 0).all()

    return [row.todict() for row in rows]


@daosession
def find_voicemail_general_settings(session):
    rows = session.query(StaticVoicemail).filter(StaticVoicemail.commented == 0).all()

    res = []
    for row in rows:
        res.append(
            {
                'category': row.category,
                'var_name': row.var_name,
                'var_val': row.var_val,
            }
        )

    return res


class _SIPEndpointResolver:
    def __init__(self, endpoint_config, parents):
        self._endpoint_config = endpoint_config
        self._base_config = self._endpoint_to_dict(self._endpoint_config)
        self._parents = parents
        self.template = endpoint_config.template

        self._body = None

        self._aor_section = None
        self._auth_section = None
        self._endpoint_section = None
        self._identify_section = None
        self._outbound_auth_section = None
        self._registration_section = None
        self._registration_outbound_auth_section = None

    def get_aor_section(self):
        return self._get_section('aor')

    def get_auth_section(self):
        return self._get_section('auth')

    def get_endpoint_section(self):
        return self._get_section('endpoint')

    def get_identify_section(self):
        return self._get_section('identify')

    def get_outbound_auth_section(self):
        return self._get_section('outbound_auth')

    def get_registration_section(self):
        return self._get_section('registration')

    def get_registration_outbound_auth_section(self):
        return self._get_section('registration_outbound_auth')

    def _get_section(self, name):
        field_name = f'_{name}_section'
        if getattr(self, field_name) is None:
            build_method_name = f'_build_{name}_section'
            build_method = getattr(self, build_method_name)
            section = build_method()
            setattr(self, field_name, section)
        return getattr(self, field_name)

    def resolve(self):
        if self._body is None:
            self._body = self._canonicalize_config(
                {
                    'uuid': self._endpoint_config.uuid,
                    'name': self._endpoint_config.name,
                    'label': self._endpoint_config.label,
                    'template': self._endpoint_config.template,
                    'asterisk_id': self._endpoint_config.asterisk_id,
                    'aor_section_options': self.get_aor_section(),
                    'auth_section_options': self.get_auth_section(),
                    'endpoint_section_options': self.get_endpoint_section(),
                    'identify_section_options': self.get_identify_section(),
                    'outbound_auth_section_options': self.get_outbound_auth_section(),
                    'registration_section_options': self.get_registration_section(),
                    'registration_outbound_auth_section_options': self.get_registration_outbound_auth_section(),
                }
            )

        return self._body

    def _add_parent_options(self, section_name, options=None):
        options = options or []
        for parent in self._iterover_parents():
            method_name = f'get_{section_name}_section'
            method = getattr(parent, method_name)
            for option in method():
                options.append(option)

        field_name = f'{section_name}_section_options'
        for option in self._base_config.get(field_name, []):
            options.append(option)

        return options

    def _build_aor_section(self):
        options = self._add_parent_options('aor')
        if options:
            options.append(('type', 'aor'))
        return options

    def _build_auth_section(self):
        options = self._add_parent_options('auth')
        if options:
            options.append(('type', 'auth'))
        return options

    def _build_endpoint_section(self):
        options = self._default_endpoint_section()
        options = self._add_parent_options('endpoint', options)

        if self._endpoint_config.transport_uuid:
            options.append(('transport', self._endpoint_config.transport.name))

        original_caller_id = None
        for key, value in options:
            if key == 'callerid':
                original_caller_id = value
        if original_caller_id:
            options.append(('set_var', f'ACCENT_ORIGINAL_CALLER_ID={original_caller_id}'))

        aor_options = self.get_aor_section()
        if aor_options:
            options.append(('aors', self._endpoint_config.name))

        auth_options = self.get_auth_section()
        if auth_options:
            options.append(('auth', self._endpoint_config.name))

        if options:
            options.append(('type', 'endpoint'))

            if self.get_outbound_auth_section():
                options.append(
                    ('outbound_auth', f'outbound_auth_{self._endpoint_config.name}')
                )

        return options

    def _build_identify_section(self):
        options = self._add_parent_options('identify')
        if options:
            options.append(('type', 'identify'))
            options.append(('endpoint', self._endpoint_config.name))
        return options

    def _build_outbound_auth_section(self):
        options = self._add_parent_options('outbound_auth')
        if options:
            options.append(('type', 'auth'))
        return options

    def _build_registration_section(self):
        options = self._add_parent_options('registration')
        if options:
            options.append(('type', 'registration'))
            options.append(('endpoint', self._endpoint_config.name))
            if self.get_registration_outbound_auth_section():
                options.append(
                    ('outbound_auth', f'auth_reg_{self._endpoint_config.name}')
                )
        return options

    def _build_registration_outbound_auth_section(self):
        options = self._add_parent_options('registration_outbound_auth')
        if options:
            options.append(('type', 'auth'))
        return options

    def _default_endpoint_section(self):
        return [
            ('set_var', f'__ACCENT_TENANT_UUID={self._endpoint_config.tenant_uuid}'),
        ]

    def _iterover_parents(self):
        for template in self._endpoint_config.templates:
            yield self._parents[template.uuid]

    @staticmethod
    def _canonicalize_config(config):
        sections = [
            'aor_section_options',
            'auth_section_options',
            'endpoint_section_options',
            'registration_section_options',
            'identify_section_options',
            'registration_outbound_auth_section_options',
            'outbound_auth_section_options',
        ]
        repeatable_options = [
            'set_var',
            'match',
        ]

        for section in sections:
            accumulator = {}
            repeated_options = []
            for key, value in config.get(section, []):
                if key in repeatable_options:
                    if [key, value] not in repeated_options:
                        repeated_options.append([key, value])
                else:
                    accumulator[key] = value
            config[section] = list(accumulator.items()) + repeated_options

        return config

    @staticmethod
    def _endpoint_to_dict(endpoint):
        return {
            'uuid': endpoint.uuid,
            'name': endpoint.name,
            'label': endpoint.label,
            'aor_section_options': list(endpoint.aor_section_options),
            'auth_section_options': list(endpoint.auth_section_options),
            'endpoint_section_options': list(endpoint.endpoint_section_options),
            'registration_section_options': list(endpoint.registration_section_options),
            'registration_outbound_auth_section_options': list(
                endpoint.registration_outbound_auth_section_options
            ),
            'identify_section_options': list(endpoint.identify_section_options),
            'outbound_auth_section_options': list(
                endpoint.outbound_auth_section_options
            ),
            'template': endpoint.template,
            'asterisk_id': endpoint.asterisk_id,
        }


class _EndpointSIPMeetingResolver(_SIPEndpointResolver):
    def __init__(self, meeting, parents):
        super().__init__(meeting.guest_endpoint_sip, parents)
        self._meeting = meeting

    def _default_endpoint_section(self):
        return super()._default_endpoint_section() + [
            ('set_var', 'ACCENT_CHANNEL_DIRECTION=from-accent'),
            ('set_var', f'ACCENT_MEETING_UUID={self._meeting.uuid}'),
            ('set_var', f'ACCENT_MEETING_NAME={self._meeting.name}'),
        ]


class _EndpointSIPTrunkResolver(_SIPEndpointResolver):
    def __init__(self, trunk, parents):
        super().__init__(trunk.endpoint_sip, parents)
        self._trunk = trunk

    def _default_endpoint_section(self):
        options = super()._default_endpoint_section()

        if self._trunk.context:
            options.append(('context', self._trunk.context))

        return options


class _EndpointSIPLineResolver(_SIPEndpointResolver):
    def __init__(self, line, parents, pickup_members):
        super().__init__(line.endpoint_sip, parents)
        self._line = line
        self._pickup_members = pickup_members

    def _add_mailboxes(self, options):
        mailboxes = []
        for user in self._line.users:
            if user.voicemail:
                mailboxes.append(f'{user.voicemail.number}@{user.voicemail.context}')
        if mailboxes:
            options.append(('mailboxes', ','.join(mailboxes)))
        return options

    def _build_aor_section(self):
        options = super()._build_aor_section()
        options = self._add_mailboxes(options)

        if options:
            options.append(('type', 'aor'))

        return options

    def _default_endpoint_section(self):
        options = super()._default_endpoint_section() + [
            ('set_var', 'ACCENT_CHANNEL_DIRECTION=from-accent'),
            ('set_var', f'ACCENT_LINE_ID={self._line.id}'),
        ]

        context_name = self._line.context
        if self._line.application_uuid:
            outgoing_context = f'stasis-accent-app-{self._line.application_uuid}'
        elif context_name:
            outgoing_context = context_name
        else:
            outgoing_context = None

        if outgoing_context:
            options.append(('context', outgoing_context))
        if context_name:
            options.append(('set_var', f'TRANSFER_CONTEXT={context_name}'))

        for user in self._line.users:
            options.append(('set_var', f'ACCENT_USERID={user.id}'))  # Deprecated in 24.01
            options.append(('set_var', f'ACCENT_USERID={user.id}'))
            options.append(
                ('set_var', f'ACCENT_USERUUID={user.uuid}')
            )  # Deprecated in 24.01
            options.append(('set_var', f'ACCENT_USERUUID={user.uuid}'))
            if user.enableonlinerec:
                options.append(('set_var', 'DYNAMIC_FEATURES=togglerecord'))

        if self._line.extensions:
            for extension in self._line.extensions:
                options.append(
                    ('set_var', f'PICKUPMARK={extension.exten}%{extension.context}')
                )
                break

        pickup_groups = self._pickup_members.get(self._endpoint_config.uuid, {})
        named_pickup_groups = ','.join(
            str(id) for id in pickup_groups.get('pickupgroup', [])
        )
        if named_pickup_groups:
            options.append(('named_pickup_group', named_pickup_groups))

        named_call_groups = ','.join(
            str(id) for id in pickup_groups.get('callgroup', [])
        )
        if named_call_groups:
            options.append(('named_call_group', named_call_groups))

        options = self._add_mailboxes(options)

        return options


def merge_endpoints_and_template(items, Klass, endpoint_field, *args):
    resolved_configs = {}

    def add_endpoint_configuration(endpoint, item=None):
        for parent in endpoint.templates:
            if parent.uuid in resolved_configs:
                continue
            add_endpoint_configuration(parent)

        if item:
            endpoint_config = Klass(item, resolved_configs, *args)
        else:
            endpoint_config = _SIPEndpointResolver(endpoint, resolved_configs)

        resolved_configs[endpoint.uuid] = endpoint_config

    for item in items:
        add_endpoint_configuration(getattr(item, endpoint_field), item)

    endpoint_configs = (
        endpoint_config
        for endpoint_config in resolved_configs.values()
        if not endpoint_config.template
    )
    return [endpoint_config.resolve() for endpoint_config in endpoint_configs]


@daosession
def find_sip_meeting_guests_settings(session):
    query = (
        session.query(
            Meeting,
        )
        .options(
            joinedload('guest_endpoint_sip')
            .joinedload('template_relations')
            .joinedload('parent'),
        )
        .options(
            joinedload('guest_endpoint_sip').joinedload('_aor_section'),
        )
        .options(
            joinedload('guest_endpoint_sip').joinedload('_auth_section'),
        )
        .options(
            joinedload('guest_endpoint_sip').joinedload('_endpoint_section'),
        )
        .options(
            joinedload('guest_endpoint_sip').joinedload('_registration_section'),
        )
        .options(
            joinedload('guest_endpoint_sip').joinedload(
                '_registration_outbound_auth_section'
            ),
        )
        .options(
            joinedload('guest_endpoint_sip').joinedload('_identify_section'),
        )
        .options(
            joinedload('guest_endpoint_sip').joinedload('_outbound_auth_section'),
        )
        .options(
            joinedload('guest_endpoint_sip').joinedload('transport'),
        )
        .filter(Meeting.guest_endpoint_sip_uuid.isnot(None))
    )

    return merge_endpoints_and_template(
        query.all(), _EndpointSIPMeetingResolver, 'guest_endpoint_sip'
    )


@daosession
def find_sip_user_settings(session):
    pickup_members = find_pickup_members('sip')
    query = (
        session.query(
            LineFeatures,
        )
        .options(
            joinedload('endpoint_sip')
            .joinedload('template_relations')
            .joinedload('parent'),
        )
        .options(
            joinedload('endpoint_sip').joinedload('_aor_section'),
        )
        .options(
            joinedload('endpoint_sip').joinedload('_auth_section'),
        )
        .options(
            joinedload('endpoint_sip').joinedload('_endpoint_section'),
        )
        .options(
            joinedload('endpoint_sip').joinedload('_registration_section'),
        )
        .options(
            joinedload('endpoint_sip').joinedload(
                '_registration_outbound_auth_section'
            ),
        )
        .options(
            joinedload('endpoint_sip').joinedload('_identify_section'),
        )
        .options(
            joinedload('endpoint_sip').joinedload('_outbound_auth_section'),
        )
        .options(
            joinedload('endpoint_sip').joinedload('transport'),
        )
        .options(
            joinedload('user_lines').joinedload('user').joinedload('voicemail'),
        )
        .options(
            joinedload('line_extensions').joinedload('extension'),
        )
        .filter(
            LineFeatures.endpoint_sip_uuid.isnot(None),
        )
    )

    return merge_endpoints_and_template(
        query.all(), _EndpointSIPLineResolver, 'endpoint_sip', pickup_members
    )


@daosession
def find_sip_trunk_settings(session):
    query = (
        session.query(
            TrunkFeatures,
        )
        .options(
            joinedload('endpoint_sip')
            .joinedload('template_relations')
            .joinedload('parent'),
        )
        .options(
            joinedload('endpoint_sip').joinedload('_aor_section'),
        )
        .options(
            joinedload('endpoint_sip').joinedload('_auth_section'),
        )
        .options(
            joinedload('endpoint_sip').joinedload('_endpoint_section'),
        )
        .options(
            joinedload('endpoint_sip').joinedload('_registration_section'),
        )
        .options(
            joinedload('endpoint_sip').joinedload(
                '_registration_outbound_auth_section'
            ),
        )
        .options(
            joinedload('endpoint_sip').joinedload('_identify_section'),
        )
        .options(
            joinedload('endpoint_sip').joinedload('_outbound_auth_section'),
        )
        .options(
            joinedload('endpoint_sip').joinedload('transport'),
        )
        .filter(
            TrunkFeatures.endpoint_sip_uuid.isnot(None),
        )
    )

    return merge_endpoints_and_template(
        query.all(), _EndpointSIPTrunkResolver, 'endpoint_sip'
    )


@daosession
def find_pickup_members(session, protocol):
    '''
    Returns a map:
    {endpoint_id: {pickupgroup: set([pickupgroup_id, ...]),
                   callgroup: set([pickupgroup_id, ...])},
     ...,
    }
    '''
    group_map = {
        'member': 'pickupgroup',
        'pickup': 'callgroup',
    }

    res = defaultdict(lambda: defaultdict(set))

    def _add_member(m):
        if protocol == 'sip':
            res_base = res[m.endpoint_sip_uuid]
        elif protocol == 'sccp':
            res_base = res[m.endpoint_sccp_id]
        elif protocol == 'custom':
            res_base = res[m.endpoint_custom_id]
        return res_base[group_map[m.category]].add(m.id)

    add_member = _add_member

    base_query = (
        session.query(
            PickupMember.category,
            Pickup.id,
            LineFeatures.endpoint_sip_uuid,
            LineFeatures.endpoint_sccp_id,
            LineFeatures.endpoint_custom_id,
        )
        .join(
            Pickup,
            Pickup.id == PickupMember.pickupid,
        )
        .filter(Pickup.commented == 0)
    )

    if protocol == 'sip':
        base_query = base_query.filter(LineFeatures.endpoint_sip_uuid.isnot(None))
    elif protocol == 'sccp':
        base_query = base_query.filter(LineFeatures.endpoint_sccp_id.isnot(None))
    elif protocol == 'custom':
        base_query = base_query.filter(LineFeatures.endpoint_custom_id.isnot(None))

    users = (
        base_query.join(
            UserLine,
            UserLine.user_id == PickupMember.memberid,
        )
        .join(
            LineFeatures,
            LineFeatures.id == UserLine.line_id,
        )
        .filter(
            PickupMember.membertype == 'user',
        )
    )

    groups = (
        base_query.join(
            GroupFeatures,
            GroupFeatures.id == PickupMember.memberid,
        )
        .join(
            QueueMember,
            QueueMember.queue_name == GroupFeatures.name,
        )
        .join(
            UserLine,
            UserLine.user_id == QueueMember.userid,
        )
        .join(
            LineFeatures,
            LineFeatures.id == UserLine.line_id,
        )
        .filter(
            and_(
                PickupMember.membertype == 'group',
                QueueMember.usertype == 'user',
                UserLine.main_user == True,  # noqa
                UserLine.main_line == True,  # noqa
            )
        )
    )

    queues = (
        base_query.join(
            QueueFeatures,
            QueueFeatures.id == PickupMember.memberid,
        )
        .join(
            QueueMember,
            QueueMember.queue_name == QueueFeatures.name,
        )
        .join(
            UserLine,
            UserLine.user_id == QueueMember.userid,
        )
        .join(
            LineFeatures,
            LineFeatures.id == UserLine.line_id,
        )
        .filter(
            and_(
                PickupMember.membertype == 'queue',
                QueueMember.usertype == 'user',
                UserLine.main_user == True,  # noqa
                UserLine.main_line == True,  # noqa
            )
        )
    )

    for member in users.union(groups.union(queues)).all():
        add_member(member)

    return res


@daosession
def find_iax_general_settings(session):
    rows = session.query(StaticIAX).filter(StaticIAX.commented == 0).all()

    res = []
    for row in rows:
        res.append(
            {
                'var_name': row.var_name,
                'var_val': row.var_val,
            }
        )

    return res


@daosession
def find_iax_trunk_settings(session):
    rows = (
        session.query(UserIAX)
        .filter(
            and_(
                UserIAX.commented == 0,
                UserIAX.category == 'trunk',
            )
        )
        .all()
    )

    return rows


@daosession
def find_iax_calllimits_settings(session):
    rows = session.query(IAXCallNumberLimits).all()

    return [row.todict() for row in rows]


@daosession
def find_queue_general_settings(session):
    rows = (
        session.query(StaticQueue)
        .filter(
            and_(
                StaticQueue.commented == 0,
                StaticQueue.category == 'general',
            )
        )
        .all()
    )

    return [row.todict() for row in rows]


@daosession
def find_queue_settings(session):
    rows = (
        session.query(Queue)
        .options(joinedload('groupfeatures'))
        .options(joinedload('queuefeatures'))
        .filter(Queue.commented == 0)
        .all()
    )

    result = []
    for row in rows:
        row_as_dict = row.todict()
        row_as_dict['label'] = row.label
        result.append(row_as_dict)
    return result


@daosession
def find_queue_skillrule_settings(session):
    rows = session.query(QueueSkillRule).all()

    return [row.todict() for row in rows]


@daosession
def find_queue_members_settings(session, queue_name):
    user_members = (
        session.query(
            QueueMember.category,
            QueueMember.penalty,
            QueueMember.position,
            QueueMember.interface,
            UserFeatures.uuid,
        )
        .outerjoin(UserFeatures, QueueMember.userid == UserFeatures.id)
        .filter(
            and_(
                QueueMember.commented == 0,
                QueueMember.queue_name == queue_name,
                QueueMember.usertype == 'user',
            )
        )
        .order_by(QueueMember.position)
        .all()
    )

    def is_user(row):
        return row.uuid is not None

    res = []
    for row in user_members:
        if is_user(row):
            member = Member(
                interface=f'Local/{row.uuid}@usersharedlines',
                penalty=str(row.penalty),
                name='',
                state_interface=f'hint:{row.uuid}@usersharedlines',
            )
        else:
            member = Member(
                interface=row.interface,
                penalty=str(row.penalty),
                name='',
                state_interface='',
            )
        res.append(member)
    return res


@daosession
def find_agent_queue_skills_settings(session):
    rows = (
        session.query(
            AgentFeatures.id,
            QueueSkill.name,
            AgentQueueSkill.weight,
        )
        .filter(
            and_(
                AgentQueueSkill.agentid == AgentFeatures.id,
                AgentQueueSkill.skillid == QueueSkill.id,
            )
        )
        .order_by(AgentFeatures.id)
        .all()
    )

    res = []
    for id_, name, weight in rows:
        res.append(
            {
                'id': id_,
                'name': name,
                'weight': weight,
            }
        )

    return res

----------------------------------------

File: callfilter_dao.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql.expression import and_, cast, func
from sqlalchemy.types import Integer

from accent_dao.alchemy.callfilter import Callfilter
from accent_dao.alchemy.callfiltermember import Callfiltermember
from accent_dao.alchemy.extension import Extension as ExtensionSchema
from accent_dao.alchemy.line_extension import LineExtension
from accent_dao.alchemy.user_line import UserLine
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.helpers.db_manager import daosession


@daosession
def does_secretary_filter_boss(session, boss_user_id, secretary_user_id):
    subquery = (
        session.query(Callfiltermember.callfilterid)
        .filter(Callfiltermember.bstype == 'boss')
        .filter(Callfiltermember.typeval == str(boss_user_id))
        .subquery()
    )

    query = (
        session.query(Callfiltermember.id)
        .filter(Callfiltermember.typeval == str(secretary_user_id))
        .filter(Callfiltermember.bstype == 'secretary')
        .filter(Callfiltermember.callfilterid.in_(subquery))
    )

    return query.count()


@daosession
def get(session, callfilter_id):
    return (
        session.query(Callfilter, Callfiltermember)
        .join((Callfiltermember, Callfilter.id == Callfiltermember.callfilterid))
        .filter(Callfilter.id == callfilter_id)
        .all()
    )


@daosession
def get_secretaries_id_by_context(session, context):
    return (
        session.query(Callfiltermember.id)
        .join(
            UserLine,
            and_(
                UserLine.user_id == cast(Callfiltermember.typeval, Integer),
                UserLine.main_user == True,  # noqa
                UserLine.main_line == True,  # noqa
            ),
        )
        .join(
            LineExtension,
            and_(
                UserLine.line_id == LineExtension.line_id,
                LineExtension.main_extension == True,  # noqa
            ),
        )
        .join(
            ExtensionSchema,
            and_(
                ExtensionSchema.context == context,
                LineExtension.extension_id == ExtensionSchema.id,
            ),
        )
        .filter(
            and_(
                Callfiltermember.type == 'user', Callfiltermember.bstype == 'secretary'
            )
        )
        .all()
    )


@daosession
def get_secretaries_by_callfiltermember_id(session, callfiltermember_id):
    return (
        session.query(Callfiltermember, UserFeatures.ringseconds)
        .join((Callfilter, Callfilter.id == Callfiltermember.callfilterid))
        .join(
            (UserFeatures, UserFeatures.id == cast(Callfiltermember.typeval, Integer))
        )
        .filter(
            and_(
                Callfilter.id == callfiltermember_id,
                Callfiltermember.bstype == 'secretary',
            )
        )
        .order_by(Callfiltermember.priority.asc())
        .all()
    )


@daosession
def get_by_callfiltermember_id(session, callfiltermember_id):
    return (
        session.query(Callfiltermember)
        .filter(Callfiltermember.id == callfiltermember_id)
        .first()
    )


@daosession
def find_boss(session, boss_id):
    return (
        session.query(Callfiltermember)
        .filter(
            and_(
                Callfiltermember.typeval == str(boss_id),
                Callfiltermember.bstype == 'boss',
            )
        )
        .first()
    )


@daosession
def find(session, call_filter_id):
    return session.query(Callfilter).filter(Callfilter.id == call_filter_id).first()


@daosession
def is_activated_by_callfilter_id(session, callfilter_id):
    return (
        session.query(func.count(Callfiltermember.active))
        .join((Callfilter, Callfilter.id == Callfiltermember.callfilterid))
        .filter(
            and_(
                Callfiltermember.callfilterid == callfilter_id,
                Callfiltermember.bstype == 'secretary',
                Callfiltermember.active == 1,
            )
        )
        .first()[0]
    )


@daosession
def update_callfiltermember_state(session, callfiltermember_id, new_state):
    data_dict = {'active': int(new_state)}
    session.query(Callfiltermember).filter(
        Callfiltermember.id == callfiltermember_id
    ).update(data_dict)

----------------------------------------

File: context_dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.context import Context
from accent_dao.helpers.db_manager import daosession


@daosession
def get(session, context_name):
    return session.query(Context).filter(Context.name == context_name).first()

----------------------------------------

File: converters/__init__.py
Please review for update


----------------------------------------

File: converters/database_converter.py
Please review for update

# Copyright 2023 Accent Communications


class DatabaseConverter:
    def __init__(self, mapping, schema, model):
        self.schema = schema
        self.model = model

        model_mapping = {value: key for key, value in mapping.items()}

        self.db_mapping = mapping
        self.model_mapping = model_mapping

    def to_model(self, db_row):
        db_columns = self._extract_columns(db_row, self.db_mapping.keys())
        model_columns = self._remap_columns(db_columns, self.db_mapping)
        return self.model(**model_columns)

    def to_source(self, model):
        model_columns = self._extract_columns(model, self.model_mapping.keys())
        db_columns = self._remap_columns(model_columns, self.model_mapping)
        return self.schema(**db_columns)

    def update_model(self, model, db_row):
        db_columns = self._extract_columns(db_row, self.db_mapping.keys())
        model_columns = self._remap_columns(db_columns, self.db_mapping)
        self._update_object(model_columns, model)

    def update_source(self, db_row, model):
        model_columns = self._extract_columns(model, self.model_mapping.keys())
        db_columns = self._remap_columns(model_columns, self.model_mapping)
        self._update_object(db_columns, db_row)

    def _extract_columns(self, source_object, columns):
        extracted_values = {}
        for column_name in columns:
            if not hasattr(source_object, column_name):
                raise ValueError(
                    f'column {column_name} does not exist in object {type(source_object)}'
                )
            extracted_values[column_name] = getattr(source_object, column_name)
        return extracted_values

    def _remap_columns(self, columns, mapping):
        mapped_columns = {}
        for column_name, value in columns.items():
            key = mapping[column_name]
            mapped_columns[key] = value
        return mapped_columns

    def _update_object(self, values, destination):
        for key, value in values.items():
            setattr(destination, key, value)
----------------------------------------

File: helpers/__init__.py
Please review for update


----------------------------------------

File: helpers/asterisk.py
Please review for update

# Copyright 2023 Accent Communications
from collections.abc import Iterable

from accent_dao.helpers import errors

# taken from the definition of the "ast_true" function in Asterisk source code
_TRUTH_VALUES = [
    'yes',
    'true',
    'y',
    't',
    '1',
    'on',
]


def convert_ast_true_to_int(value):
    return int(value in _TRUTH_VALUES)


def convert_int_to_ast_true(value):
    if value:
        return 'yes'
    return 'no'


class AsteriskOptionsMixin:
    EXCLUDE_OPTIONS = set()
    EXCLUDE_OPTIONS_CONFD = set()
    AST_TRUE_INTEGER_COLUMNS = set()

    @property
    def options(self):
        return self.all_options(self.EXCLUDE_OPTIONS_CONFD)

    def all_options(self, exclude=None):
        native_options = list(self.native_options(exclude))
        return native_options + self._options

    def native_options(self, exclude=None):
        for column in self.native_option_names(exclude):
            value = self.native_option(column)
            if value is not None:
                yield [column, value]

    def native_option(self, column_name):
        value = getattr(self, self._attribute(column_name), None)
        if value is not None and value != "":
            if column_name in self.AST_TRUE_INTEGER_COLUMNS:
                return convert_int_to_ast_true(value)
            else:
                return str(value)
        return None

    @options.setter
    def options(self, options):
        option_names = self.native_option_names(self.EXCLUDE_OPTIONS_CONFD)
        self.reset_options()
        self.set_options(option_names, options)

    def reset_options(self):
        self.reset_extra_options()
        self.reset_native_options()

    def reset_extra_options(self):
        self._options = []

    def reset_native_options(self):
        defaults = self.option_defaults()
        for column in self.native_option_names(self.EXCLUDE_OPTIONS_CONFD):
            value = defaults.get(column, None)
            setattr(self, self._attribute(column), value)

    def set_options(self, option_names, options):
        self.validate_options(options)
        for option in options:
            self.validate_option(option)
            column, value = option
            if column in option_names:
                self.set_native_option(column, value)
            else:
                self.add_extra_option(column, value)

    def validate_options(self, options):
        if not isinstance(options, Iterable):
            raise errors.wrong_type('options', 'list of pair of strings')

    def validate_option(self, option):
        if not isinstance(option, Iterable):
            raise errors.wrong_type('options', 'list of pair of strings')
        if not len(option) == 2:
            raise errors.wrong_type('options', 'list of pair of strings')
        for i in option:
            if not isinstance(i, str):
                raise errors.wrong_type('options', f"value '{i}' is not a string")

    def set_native_option(self, column, value):
        if column in self.AST_TRUE_INTEGER_COLUMNS:
            value = convert_ast_true_to_int(value)
        setattr(self, self._attribute(column), value)

    def add_extra_option(self, name, value):
        self._options.append([name, value])

    def native_option_names(self, exclude=None):
        exclude = set(exclude or []).union(self.EXCLUDE_OPTIONS)
        return {column.name for column in self.__table__.columns} - exclude

    def option_defaults(self):
        defaults = {}
        for column in self.__table__.columns:
            if column.server_default:
                defaults[column.name] = column.server_default.arg
        return defaults

    def _attribute(self, column_name):
        return column_name.replace("-", "_")

----------------------------------------

File: helpers/cel_exception.py
Please review for update

# Copyright 2023 Accent Communications


class CELException(Exception):
    pass


class MissingCELEventException(CELException):
    pass

----------------------------------------

File: helpers/datetime.py
Please review for update

# Copyright 2023 Accent Communications
from datetime import datetime, timezone


def utcnow_with_tzinfo() -> datetime:
    return datetime.now(timezone.utc)

----------------------------------------

File: helpers/db_manager.py
Please review for update

# Copyright 2023 Accent Communications

import logging
from functools import wraps

from accent.config_helper import ConfigParser, ErrorHandler
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import scoped_session, sessionmaker
from sqlalchemy.types import String, TypeDecorator

DEFAULT_DB_URI = (
    'postgresql://asterisk:password123@localhost/asterisk?application_name=accent-dao'
)
DEFAULT_POOL_SIZE = 16

logger = logging.getLogger(__name__)
Session = scoped_session(sessionmaker())


class BaseMixin:
    def __repr__(self):
        attrs = {
            col.name: getattr(self, col.name)
            for col in self.__table__.columns
            if col.primary_key
        }
        attrs_fmt = ", ".join(f"{k}={v}" for k, v in attrs.items())
        return f"{self.__class__.__name__}({attrs_fmt})"


Base = declarative_base(cls=BaseMixin)


# http://docs.sqlalchemy.org/en/rel_0_9/_modules/examples/join_conditions/cast.html
class IntAsString(TypeDecorator):
    """Coerce integer->string type.

    This is needed only if the relationship() from
    string to int is writable, as SQLAlchemy will copy
    the int parent values into the string attribute
    on the child during a flush.

    """

    impl = String

    def process_bind_param(self, value, dialect):
        if value is not None:
            value = str(value)
        return value


class UUIDAsString(TypeDecorator):
    impl = String

    def process_bind_param(self, value, dialect):
        if value is not None:
            value = str(value)
        return value


def todict(self, exclude=None):
    exclude = exclude or []
    d = {}
    for c in self.__table__.columns:
        name = c.name.replace('-', '_')
        if name not in exclude:
            value = getattr(self, name)
            d[c.name] = value

    return d


Base.todict = todict


def daosession(func):
    @wraps(func)
    def wrapped(*args, **kwargs):
        session = Session()
        return func(session, *args, **kwargs)

    return wrapped


def init_db(db_uri, pool_size=DEFAULT_POOL_SIZE):
    engine = create_engine(db_uri, pool_size=pool_size, pool_pre_ping=True)
    Session.configure(bind=engine)
    Base.metadata.bind = engine


def init_db_from_config(config=None):
    config = config or default_config()
    url = config.get('db_uri', DEFAULT_DB_URI)
    try:
        pool_size = config['rest_api']['max_threads']
    except KeyError:
        pool_size = DEFAULT_POOL_SIZE
    init_db(url, pool_size=pool_size)


def default_config():
    config = {
        'config_file': '/etc/accent-dao/config.yml',
        'extra_config_files': '/etc/accent-dao/conf.d',
    }
    config_parser = ConfigParser(ErrorHandler())
    return config_parser.read_config_file_hierarchy(config)

----------------------------------------

File: helpers/db_utils.py
Please review for update

# Copyright 2023 Accent Communications

from contextlib import contextmanager

from accent_dao.helpers import db_manager
from accent_dao.helpers.db_manager import daosession


@contextmanager
def flush_session(session):
    try:
        yield
        session.flush()
    except Exception:
        session.rollback()
        raise


@daosession
def get_dao_session(session):
    return session


@contextmanager
def session_scope(read_only=False):
    session = db_manager.Session()
    try:
        yield session
        if not read_only:
            session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        db_manager.Session.remove()

----------------------------------------

File: helpers/db_views.py
Please review for update

# Copyright 2023 Accent Communications
from __future__ import annotations

from collections.abc import Callable

from sqlalchemy import Table, text
from sqlalchemy.event import contains, listens_for
from sqlalchemy.exc import InvalidRequestError
from sqlalchemy.orm.unitofwork import UOWTransaction
from sqlalchemy_utils.view import refresh_materialized_view

from .db_manager import Base, Session


class MaterializedView(Base):
    """
    Materialized View base class

    Used to tell SQLAlchemy to construct a materialized view.

    Usage:

    Assign the '__table__' attribute using the create_materialized_view function
    """

    __abstract__ = True
    __view_dependencies__: tuple[type[Base], ...] = tuple()
    _view_dependencies_handler: Callable[[Session, str, bool], None] | None

    def __init_subclass__(cls) -> None:
        if not isinstance(getattr(cls, '__table__', None), Table):
            raise InvalidRequestError(
                f"Class '{cls}' '__table__' attribute must be created with 'create_materialized_view'"
            )
        super().__init_subclass__()

        if targets := cls.__view_dependencies__:

            @listens_for(Session, 'after_flush')
            def _before_session_commit_handler(
                session: Session, flush_context: UOWTransaction
            ) -> None:
                for obj in session.dirty | session.new | session.deleted:
                    if isinstance(obj, targets):
                        # Cannot call `refresh_materialized_view` as it will try to flush again.
                        session.execute(
                            text(
                                f'REFRESH MATERIALIZED VIEW CONCURRENTLY {cls.__table__.fullname}'
                            )
                        )
                        return

            cls._view_dependencies_handler = staticmethod(
                _before_session_commit_handler
            )
        else:
            cls._view_dependencies_handler = None

    @classmethod
    @property
    def autorefresh(cls) -> bool:
        if handler := cls._view_dependencies_handler:
            return contains(Session, 'after_flush', handler)
        return False

    @classmethod
    def refresh(cls, concurrently: bool = True) -> None:
        refresh_materialized_view(Session(), cls.__table__.fullname, concurrently)

----------------------------------------

File: helpers/errors.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.exception import InputError, NotFoundError, ResourceError


def format_error(category, error, metadata=None):
    metadata = metadata or {}
    template = "{category} - {error} {metadata}"
    message = template.format(
        category=category, error=error, metadata=_format_metadata(metadata)
    )
    return message.strip()


def _format_metadata(metadata):
    if len(metadata) == 0:
        return ''
    return f"({str(metadata).strip('{}')})"


def _format_list(elements):
    return ', '.join(elements)


class FormattedError:
    def __init__(self, exception, error_template):
        self.exception = exception
        self.error_template = error_template

    def __call__(self, *args, **metadata):
        message = self._format_message(args, metadata)
        error = self.exception(message, metadata)
        return error

    def _format_message(self, args, metadata):
        error = self.error_template.format(*args)
        message = format_error(self.exception.prefix, error, metadata)
        return message


def missing(*params):
    template = "missing parameters: {params}"
    message = template.format(params=_format_list(params))
    error = format_error('Input Error', message)
    return InputError(error)


def unknown(*params):
    template = "unknown parameters: {params}"
    message = template.format(params=_format_list(params))
    error = format_error('Input Error', message)
    return InputError(error)


def invalid_choice(field, choices, **metadata):
    template = "'{field}' must be one of ({choices})"
    message = template.format(field=field, choices=_format_list(choices))
    error = format_error('Input Error', message, metadata)
    return InputError(error)


minimum_length = FormattedError(
    InputError, "field '{}': must have a minimum length of {}"
)
invalid_direction = FormattedError(InputError, "direction: must be 'asc' or 'desc'")
invalid_ordering = FormattedError(InputError, "order: column '{}' was not found")
wrong_type = FormattedError(InputError, "field '{}': wrong type. Should be a {}")
outside_context_range = FormattedError(
    InputError, "Extension '{}' is outside of range for context '{}'"
)
outside_park_range = FormattedError(
    InputError, "Parking position '{}' is outside of range"
)
outside_range = FormattedError(InputError, "{} is outside of range")
invalid_func_key_type = FormattedError(InputError, "FuncKey type '{}' does not exist")
invalid_destination_type = FormattedError(
    InputError, "FuncKey destination type '{}' does not exist"
)
param_not_found = FormattedError(InputError, "field '{}': {} was not found")
invalid_query_parameter = FormattedError(
    InputError, "parameter '{}': '{}' is not valid"
)
invalid_view = FormattedError(InputError, "view '{}' does not exist")
ivr_exten_used = FormattedError(InputError, "exten '{}' used in more than one choice")
invalid_exten_pattern = FormattedError(InputError, "exten '{}' cannot be a pattern")
moh_custom_no_app = FormattedError(InputError, "custom mode must have an application")

not_found = FormattedError(NotFoundError, "{} was not found")

resource_exists = FormattedError(ResourceError, "{} already exists")
resource_associated = FormattedError(ResourceError, "{} is associated with a {}")
resource_not_associated = FormattedError(ResourceError, "{} is not associated with {}")
missing_association = FormattedError(ResourceError, "{} must be associated with a {}")
forward_destination_null = FormattedError(
    ResourceError, "Forward must be disabled to remove destination"
)
unhandled_context_type = FormattedError(
    ResourceError, "ContextType '{}' cannot be associated"
)
secondary_users = FormattedError(
    ResourceError, "There are secondary users associated to the line"
)
not_permitted = FormattedError(ResourceError, "Operation not permitted. {}")
different_tenants = FormattedError(ResourceError, "different tenants")
quota_exceeded = FormattedError(ResourceError, "Quota for {} exceeded. Maximum: {}")
extension_conflict = FormattedError(
    ResourceError, "{} is already used for a destination or parking slot"
)

----------------------------------------

File: helpers/exception.py
Please review for update

# Copyright 2023 Accent Communications

class ServiceError(ValueError):
    template = "{prefix} - {message} {metadata}"
    prefix = "Error"

    def __init__(self, message=None, metadata=None):
        super().__init__(message)
        self.metadata = metadata


class InputError(ServiceError):
    prefix = "Input Error"


class ResourceError(ServiceError):
    prefix = "Resource Error"


class NotFoundError(ServiceError):
    prefix = "Resource Not Found"

----------------------------------------

File: helpers/generators.py
Please review for update

# Copyright 2023 Accent Communications

import random
import string

ALPHANUMERIC_POOL = string.ascii_lowercase + string.digits


def find_unused_hash(already_exists_predicate):
    while True:
        data = generate_hash()
        if not already_exists_predicate(data):
            return data


def generate_hash(length=8):
    return ''.join(random.choice(ALPHANUMERIC_POOL) for _ in range(length))

----------------------------------------

File: helpers/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text

from accent_dao.helpers import errors
from accent_dao.resources.utils.search import SearchResult


class BasePersistor:
    def create(self, model):
        self.session.add(model)
        self.session.flush()
        return model

    def delete(self, model):
        self.session.delete(model)
        self.session.flush()

    def edit(self, model):
        self.persist(model)

    def find_by(self, criteria):
        query = self._find_query(criteria)
        return query.first()

    def find_all_by(self, criteria):
        query = self._find_query(criteria)
        return query.all()

    def get_by(self, criteria):
        model = self.find_by(criteria)
        if not model:
            resource_name = self._search_table.__mapper__.class_.__name__
            raise errors.not_found(resource_name, **criteria)
        return model

    def persist(self, model):
        self.session.add(model)
        self.session.flush()
        self.session.expire(model)

    def search(self, parameters):
        query = self._search_query()
        query = self._filter_tenant_uuid(query)
        rows, total = self.search_system.search_from_query(query, parameters)
        return SearchResult(total, rows)

    def _find_query(self, criteria):
        raise NotImplementedError()

    def _filter_tenant_uuid(self, query):
        if self.tenant_uuids is None:
            return query

        if not self.tenant_uuids:
            return query.filter(text('false'))

        return query.filter(self._search_table.tenant_uuid.in_(self.tenant_uuids))

----------------------------------------

File: helpers/sequence_utils.py
Please review for update


from collections.abc import Callable, Iterable
from typing import TypeVar

T = TypeVar('T')

Predicate = Callable[[T], bool]


def split_by(seq: Iterable[T], pred: Predicate[T]) -> tuple[list[T], list[T]]:
    approved = []
    rejected = []
    for x in seq:
        if pred(x):
            approved.append(x)
        else:
            rejected.append(x)

    return approved, rejected

----------------------------------------

File: helpers/uuid.py
Please review for update

# Copyright 2023 Accent Communications

from uuid import uuid4


def new_uuid():
    return str(uuid4())

----------------------------------------

File: line_dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.extension import Extension as ExtensionTable
from accent_dao.alchemy.line_extension import LineExtension
from accent_dao.alchemy.linefeatures import LineFeatures
from accent_dao.alchemy.user_line import UserLine
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.helpers.db_manager import daosession


@daosession
def get_interface_from_exten_and_context(session, extension, context):
    res = (
        session.query(
            LineFeatures.endpoint_sip_uuid,
            LineFeatures.endpoint_sccp_id,
            LineFeatures.endpoint_custom_id,
            LineFeatures.name,
            UserLine.main_line,
        )
        .join(LineExtension, LineExtension.line_id == LineFeatures.id)
        .join(ExtensionTable, LineExtension.extension_id == ExtensionTable.id)
        .outerjoin(UserLine, UserLine.line_id == LineFeatures.id)
        .filter(ExtensionTable.exten == extension)
        .filter(ExtensionTable.context == context)
    )

    interface = None
    for row in res.all():
        interface = _format_interface(row)
        if row.main_line:
            return interface

    if not interface:
        raise LookupError(f'no line with extension {extension} and context {context}')

    return interface


@daosession
def get_interface_from_line_id(session, line_id):
    query = session.query(
        LineFeatures.endpoint_sip_uuid,
        LineFeatures.endpoint_sccp_id,
        LineFeatures.endpoint_custom_id,
        LineFeatures.name,
    ).filter(LineFeatures.id == line_id)

    line_row = query.first()

    if not line_row:
        raise LookupError(f'no line with id {line_id}')

    return _format_interface(line_row)


@daosession
def get_main_extension_context_from_line_id(session, line_id):
    query = (
        session.query(ExtensionTable.exten, ExtensionTable.context)
        .join(LineExtension, LineExtension.extension_id == ExtensionTable.id)
        .filter(LineExtension.line_id == line_id)
        .filter(LineExtension.main_extension.is_(True))
    )

    line_row = query.first()
    return line_row


@daosession
def is_line_owned_by_user(session, user_uuid, line_id):
    query = (
        session.query(UserLine)
        .join(UserFeatures)
        .filter(UserLine.line_id == line_id)
        .filter(UserFeatures.uuid == user_uuid)
    )

    user_line_row = query.first()
    return user_line_row is not None


def _format_interface(row):
    if row.endpoint_sip_uuid:
        return f'PJSIP/{row.name}'
    elif row.endpoint_sccp_id:
        return f'SCCP/{row.name}'
    elif row.endpoint_custom_id:
        return row.name

----------------------------------------

File: phone_access_dao.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql.expression import and_

from accent_dao.alchemy.accessfeatures import AccessFeatures
from accent_dao.helpers.db_manager import daosession


@daosession
def get_authorized_subnets(session):
    rows = (
        session.query(AccessFeatures.host)
        .filter(
            and_(AccessFeatures.feature == 'phonebook', AccessFeatures.commented == 0)
        )
        .all()
    )
    return [row.host for row in rows]

----------------------------------------

File: queue_dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.queuefeatures import QueueFeatures
from accent_dao.helpers.db_manager import daosession


@daosession
def get(session, queue_id, tenant_uuids=None):
    query = session.query(QueueFeatures).filter(QueueFeatures.id == queue_id)

    if tenant_uuids is not None:
        query = query.filter(QueueFeatures.tenant_uuid.in_(tenant_uuids))

    result = query.first()
    if result is None:
        raise LookupError('No such queue')
    else:
        return result

----------------------------------------

File: queue_log_dao.py
Please review for update

# Copyright 2023 Accent Communications

from datetime import timedelta

from sqlalchemy import between, distinct, func, literal_column
from sqlalchemy.sql import text
from sqlalchemy.sql.expression import and_, or_
from sqlalchemy.sql.functions import min

from accent_dao.alchemy.queue_log import QueueLog
from accent_dao.helpers.db_manager import daosession

_STR_TIME_FMT = "%Y-%m-%d %H:%M:%S.%f%z"


def get_wrapup_times(session, start, end, interval):
    before_start = start - timedelta(minutes=2)
    wrapup_times_query = '''\
SELECT
    queue_log.time AS start,
    (queue_log.time + (queue_log.data1 || ' seconds')::INTERVAL) AS end,
    stat_agent.id AS agent_id
FROM
    queue_log
INNER JOIN
    stat_agent ON stat_agent.name = queue_log.agent
WHERE
  queue_log.event = 'WRAPUPSTART'
AND
  queue_log.time BETWEEN :start AND :end
'''

    periods = list(_enumerate_periods(start, end, interval))
    formatted_start = before_start.strftime('%Y-%m-%d %H:%M:%S%z')
    formatted_end = end.strftime('%Y-%m-%d %H:%M:%S%z')

    rows = (
        session.query(
            literal_column('start'), literal_column('end'), literal_column('agent_id')
        )
        .from_statement(text(wrapup_times_query))
        .params(start=formatted_start, end=formatted_end)
    )

    results = {}
    for row in rows.all():
        agent_id, wstart, wend = row.agent_id, row.start, row.end

        starting_period = _find_including_period(periods, wstart)
        ending_period = _find_including_period(periods, wend)

        if starting_period and starting_period not in results:
            results[starting_period] = {}
        if ending_period and ending_period not in results:
            results[ending_period] = {}

        if starting_period is not None:
            range_end = starting_period + interval
            wend_in_start = wend if wend < range_end else range_end
            time_in_period = wend_in_start - wstart
            if agent_id not in results[starting_period]:
                results[starting_period][agent_id] = {
                    'wrapup_time': timedelta(seconds=0)
                }
            results[starting_period][agent_id]['wrapup_time'] += time_in_period

        if ending_period == starting_period:
            continue

        time_in_period = wend - ending_period
        if agent_id not in results[ending_period]:
            results[ending_period][agent_id] = {'wrapup_time': timedelta(seconds=0)}
        results[ending_period][agent_id]['wrapup_time'] += time_in_period

    return results


def _find_including_period(periods, t):
    match = None
    for period in periods:
        if t > period:
            match = period
    return match


def _enumerate_periods(start, end, interval):
    tmp = start
    while tmp <= end:
        yield tmp
        tmp += interval


def _get_ended_call(session, start_str, end, queue_log_event, stat_event):
    pairs = []
    enter_queue_event = None

    higher_boundary = end + timedelta(days=1)
    end_str = higher_boundary.strftime(_STR_TIME_FMT)

    queue_logs = (
        session.query(
            QueueLog.event,
            QueueLog.callid,
            QueueLog.queuename,
            QueueLog.data3,
            QueueLog.time,
        )
        .filter(
            and_(
                QueueLog.time >= start_str,
                QueueLog.time < end_str,
                or_(QueueLog.event == 'ENTERQUEUE', QueueLog.event == queue_log_event),
            )
        )
        .order_by(QueueLog.callid, QueueLog.time)
    )

    to_skip = None
    for queue_log in queue_logs.all():
        # The first matched entry of a pair should be an ENTERQUEUE
        if enter_queue_event is None and queue_log.event != 'ENTERQUEUE':
            continue

        # When a callid reaches the end of the range, skip all other queue_log for this callid
        if to_skip and queue_log.callid == to_skip:
            continue

        if queue_log.event == 'ENTERQUEUE':
            # The ENTERQUEUE happenned after the range, skip this callid
            if queue_log.time > end:
                to_skip = queue_log.callid
                continue

            # Found a ENTERQUEUE
            enter_queue_event = queue_log
            continue

        # Only ended calls can reach this line
        end_event = queue_log

        # Does it have a matching ENTERQUEUE?
        if end_event.callid != enter_queue_event.callid:
            continue

        pairs.append((enter_queue_event, end_event))

    for enter_queue, end_event in pairs:
        # NOTE: data3 should be a valid waittime integer value as per asterisk doc,
        # but was observed missing(empty string) in the wild
        try:
            waittime = int(end_event.data3)
        except (TypeError, ValueError):
            logger.error(
                "(callid=%s) Invalid waittime: %s", end_event.callid, end_event.data3
            )
            waittime = None

        yield {
            'callid': enter_queue.callid,
            'queue_name': enter_queue.queuename,
            'time': enter_queue.time,
            'event': stat_event,
            'talktime': 0,
            'waittime': waittime,
        }


def get_queue_abandoned_call(session, start, end):
    start_str = start.strftime(_STR_TIME_FMT)
    return _get_ended_call(session, start_str, end, 'ABANDON', 'abandoned')


def get_queue_timeout_call(session, start, end):
    start_str = start.strftime(_STR_TIME_FMT)
    return _get_ended_call(session, start_str, end, 'EXITWITHTIMEOUT', 'timeout')


def get_first_time(session):
    res = session.query(min(QueueLog.time)).first()[0]
    if res is None:
        raise LookupError('Table is empty')
    return res


def get_queue_names_in_range(session, start, end):
    start = start.strftime(_STR_TIME_FMT)
    end = end.strftime(_STR_TIME_FMT)

    return [
        r[0]
        for r in (
            session.query(distinct(QueueLog.queuename)).filter(
                between(QueueLog.time, start, end)
            )
        )
    ]


@daosession
def delete_event_by_queue_between(session, event, qname, start, end):
    session.query(QueueLog).filter(
        and_(
            QueueLog.event == event,
            QueueLog.queuename == qname,
            between(QueueLog.time, start, end),
        )
    ).delete(synchronize_session='fetch')


@daosession
def delete_event_between(session, start, end):
    session.query(QueueLog).filter(and_(between(QueueLog.time, start, end))).delete(
        synchronize_session='fetch'
    )


@daosession
def insert_entry(
    session, time, callid, queue, agent, event, d1='', d2='', d3='', d4='', d5=''
):
    entry = QueueLog(
        time=time,
        callid=callid,
        queuename=queue,
        agent=agent,
        event=event,
        data1=d1,
        data2=d2,
        data3=d3,
        data4=d4,
        data5=d5,
    )
    session.add(entry)


def hours_with_calls(session, start, end):
    start = start.strftime(_STR_TIME_FMT)
    end = end.strftime(_STR_TIME_FMT)

    hours = session.query(
        distinct(func.date_trunc('hour', QueueLog.time)).label('time')
    ).filter(between(QueueLog.time, start, end))

    for hour in hours.all():
        yield hour.time


@daosession
def get_last_callid_with_event_for_agent(session, event, agent):
    row = (
        session.query(QueueLog.callid)
        .filter(and_(QueueLog.agent == agent, QueueLog.event == event))
        .order_by(QueueLog.time.desc())
        .first()
    )

    return row.callid

----------------------------------------

File: queue_member_dao.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import func

from accent_dao.alchemy.queuemember import QueueMember
from accent_dao.helpers.db_manager import daosession
from accent_dao.helpers.db_utils import flush_session


@daosession
def add_agent_to_queue(session, agent_id, agent_number, queue_name):
    next_position = _get_next_position_for_queue(session, queue_name)
    queue_member = QueueMember()
    queue_member.queue_name = queue_name
    queue_member.interface = f'Agent/{agent_number}'
    queue_member.usertype = 'agent'
    queue_member.userid = agent_id
    queue_member.channel = 'Agent'
    queue_member.category = 'queue'
    queue_member.position = next_position

    with flush_session(session):
        session.add(queue_member)


@daosession
def remove_agent_from_queue(session, agent_id, queue_name):
    (
        session.query(QueueMember)
        .filter(QueueMember.queue_name == queue_name)
        .filter(QueueMember.usertype == 'agent')
        .filter(QueueMember.userid == agent_id)
        .delete()
    )


def _get_next_position_for_queue(session, queue_name):
    result = (
        session.query(func.max(QueueMember.position).label('max'))
        .filter(QueueMember.queue_name == queue_name)
        .first()
    )
    last_position = result.max
    if last_position is None:
        return 0
    else:
        return last_position + 1

----------------------------------------

File: stat_agent_dao.py
Please review for update

# Copyright 2023 Accent Communications

from collections import namedtuple

from sqlalchemy import distinct
from sqlalchemy.sql.expression import or_

from accent_dao.alchemy.stat_agent import StatAgent

AgentKey = namedtuple('AgentKey', ['name', 'tenant_uuid'])


def insert_missing_agents(session, confd_agents):
    confd_agents_by_key = {
        AgentKey(f'Agent/{agent["number"]}', agent['tenant_uuid']): agent
        for agent in confd_agents
    }
    _mark_recreated_agents_with_same_number_as_deleted(session, confd_agents_by_key)
    _mark_non_confd_agents_as_deleted(session, confd_agents_by_key)
    _create_missing_agents(session, confd_agents_by_key)
    _rename_deleted_agents_with_duplicate_name(session, confd_agents_by_key)


def _mark_recreated_agents_with_same_number_as_deleted(session, confd_agents_by_key):
    db_agent_query = session.query(StatAgent).filter(StatAgent.deleted.is_(False))
    db_agents_by_name = {
        AgentKey(agent.name, agent.tenant_uuid): agent for agent in db_agent_query.all()
    }

    existing_in_confd = set(list(confd_agents_by_key.keys()))
    existing_in_stat_agent = set(list(db_agents_by_name.keys()))

    not_missing_agents = existing_in_confd.intersection(existing_in_stat_agent)
    for agent_key in not_missing_agents:
        confd_agent = confd_agents_by_key[agent_key]
        db_agent = db_agents_by_name[agent_key]
        if db_agent.agent_id != confd_agent['id']:
            db_agent.deleted = True
            session.flush()


def _mark_non_confd_agents_as_deleted(session, confd_agents_by_key):
    active_agent_ids = {agent['id'] for agent in confd_agents_by_key.values()}
    all_agent_ids = {r[0] for r in session.query(distinct(StatAgent.agent_id))}
    deleted_agents = [
        agent for agent in list(all_agent_ids - active_agent_ids) if agent
    ]
    (
        session.query(StatAgent)
        .filter(
            or_(
                StatAgent.agent_id.in_(deleted_agents),
                StatAgent.agent_id.is_(None),
            )
        )
        .update({'deleted': True}, synchronize_session=False)
    )
    session.flush()


def _create_missing_agents(session, confd_agents_by_key):
    new_agent_keys = set(confd_agents_by_key.keys())
    db_agent_query = session.query(StatAgent).filter(StatAgent.deleted.is_(False))
    old_agent_keys = {
        AgentKey(agent.name, agent.tenant_uuid) for agent in db_agent_query.all()
    }
    missing_agents = list(new_agent_keys - old_agent_keys)
    for agent_key in missing_agents:
        agent = confd_agents_by_key[agent_key]
        new_agent = StatAgent()
        new_agent.name = agent_key.name
        new_agent.tenant_uuid = agent['tenant_uuid']
        new_agent.agent_id = agent['id']
        new_agent.deleted = False
        session.add(new_agent)
        session.flush()


def _rename_deleted_agents_with_duplicate_name(session, confd_agents_by_key):
    db_agent_query = session.query(StatAgent).filter(StatAgent.deleted.is_(True))
    for agent in db_agent_query.all():
        if AgentKey(agent.name, agent.tenant_uuid) in confd_agents_by_key:
            agent.name = _find_next_available_name(
                session, agent.name, agent.tenant_uuid
            )
            session.flush()


def _find_next_available_name(session, name, tenant_uuid):
    query = session.query(StatAgent).filter(
        StatAgent.name == name,
        StatAgent.tenant_uuid == tenant_uuid,
    )
    if query.first():
        next_name = f'{name}_'
        return _find_next_available_name(session, next_name, tenant_uuid)
    return name


def clean_table(session):
    session.query(StatAgent).delete()

----------------------------------------

File: stat_agent_periodic_dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.stat_agent_periodic import StatAgentPeriodic


def insert_stats(session, period_stats, period_start):
    for agent_id, times in period_stats.items():
        entry = StatAgentPeriodic(
            time=period_start,
            login_time=times['login_time'] if 'login_time' in times else '00:00:00',
            pause_time=times['pause_time'] if 'pause_time' in times else '00:00:00',
            wrapup_time=times['wrapup_time'] if 'wrapup_time' in times else '00:00:00',
            stat_agent_id=agent_id,
        )

        session.add(entry)


def clean_table(session):
    session.query(StatAgentPeriodic).delete()


def remove_after(session, date):
    session.query(StatAgentPeriodic).filter(StatAgentPeriodic.time >= date).delete()

----------------------------------------

File: stat_call_on_queue_dao.py
Please review for update

# Copyright 2023 Accent Communications

from datetime import timedelta

from sqlalchemy import between, func, literal, literal_column
from sqlalchemy.sql import text
from sqlalchemy.sql.expression import cast, extract
from sqlalchemy.types import Integer

from accent_dao import stat_queue_dao
from accent_dao.alchemy.stat_call_on_queue import StatCallOnQueue


def _add_call(session, callid, time, queue_name, event, waittime=None):
    queue_id = int(stat_queue_dao.id_from_name(queue_name))
    call_on_queue = StatCallOnQueue()
    call_on_queue.time = time
    call_on_queue.callid = callid
    call_on_queue.stat_queue_id = queue_id
    call_on_queue.status = event
    if waittime:
        call_on_queue.waittime = waittime

    session.add(call_on_queue)
    session.flush()


def add_abandoned_call(dao_sess, callid, time, queue_name, waittime):
    _add_call(dao_sess, callid, time, queue_name, 'abandoned', waittime)


def add_full_call(dao_sess, callid, time, queue_name):
    _add_call(dao_sess, callid, time, queue_name, 'full')


def add_joinempty_call(dao_sess, callid, time, queue_name):
    _add_call(dao_sess, callid, time, queue_name, 'joinempty')


def add_leaveempty_call(dao_sess, callid, time, queue_name, waittime):
    _add_call(dao_sess, callid, time, queue_name, 'leaveempty', waittime)


def add_closed_call(dao_sess, callid, time, queue_name):
    _add_call(dao_sess, callid, time, queue_name, 'closed')


def add_timeout_call(dao_sess, callid, time, queue_name, waittime):
    _add_call(dao_sess, callid, time, queue_name, 'timeout', waittime)


def get_periodic_stats_quarter_hour(session, start, end):
    quarter_hour_step = func.date_trunc(literal('hour'), StatCallOnQueue.time) + (
        cast(extract('minute', StatCallOnQueue.time), Integer) / 15
    ) * timedelta(minutes=15)
    return _get_periodic_stat_by_step(session, start, end, quarter_hour_step)


def get_periodic_stats_hour(session, start, end):
    one_hour_step = func.date_trunc(literal('hour'), StatCallOnQueue.time)
    return _get_periodic_stat_by_step(session, start, end, one_hour_step)


def _get_periodic_stat_by_step(session, start, end, step):
    stats = {}

    rows = (
        session.query(
            step.label('the_time'),
            StatCallOnQueue.stat_queue_id,
            StatCallOnQueue.status,
            func.count(StatCallOnQueue.status),
        )
        .group_by('the_time', StatCallOnQueue.stat_queue_id, StatCallOnQueue.status)
        .filter(between(StatCallOnQueue.time, start, end))
    )

    for period, queue_id, status, number in rows.all():
        if period not in stats:
            stats[period] = {}
        if queue_id not in stats[period]:
            stats[period][queue_id] = {'total': 0}
        stats[period][queue_id][status] = number
        stats[period][queue_id]['total'] += number

    return stats


def clean_table(session):
    session.query(StatCallOnQueue).delete()


def remove_after(session, date):
    session.query(StatCallOnQueue).filter(StatCallOnQueue.time >= date).delete()


def find_all_callid_between_date(session, start_date, end_date):
    sql = '''\
      select foo.callid, foo.end from (
        select callid,
               time::TIMESTAMP + (talktime || ' seconds')::INTERVAL
                               + (ringtime || ' seconds')::INTERVAL
                               + (waittime || ' seconds')::INTERVAL AS end
         from stat_call_on_queue) as foo
       where foo.end between :start_date and :end_date
    '''
    rows = (
        session.query(literal_column('callid'))
        .from_statement(text(sql))
        .params(start_date=start_date, end_date=end_date)
    )

    return [row[0] for row in rows]


def remove_callids(session, callids):
    if not callids:
        return

    session.query(StatCallOnQueue).filter(StatCallOnQueue.callid.in_(callids)).delete(
        synchronize_session='fetch'
    )

----------------------------------------

File: stat_dao.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql import literal_column, text

_STR_TIME_FMT = "%Y-%m-%d %H:%M:%S.%f%z"

FILL_ANSWERED_CALL_ON_QUEUE_QUERY = text(
    '''\n
INSERT INTO stat_call_on_queue (callid, "time", talktime, waittime, stat_queue_id, stat_agent_id, status)
(
    WITH
    call_entries AS (
        SELECT
            callid, queuename, agent, time, event, data1, data2, data3, data4, data5
        FROM
            queue_log
        WHERE
            time BETWEEN :start AND :end
    ),
    call_start AS (
        SELECT
            callid, queuename, time
        FROM
            call_entries
        WHERE
            event = 'ENTERQUEUE'
    ),
    call_end AS (
        SELECT
            callid, queuename, agent, time,
            CASE
                WHEN event IN ('COMPLETEAGENT', 'COMPLETECALLER')
                    THEN CAST (data2 AS INTEGER)
                WHEN event IN ('BLINDTRANSFER', 'TRANSFER')
                    THEN CAST (data4 AS INTEGER)
                WHEN event = 'ATTENDEDTRANSFER' and data1 IN ('BRIDGE', 'APP')
                    THEN CAST (data4 AS INTEGER)
                WHEN event = 'ATTENDEDTRANSFER' and data1 = 'LINK'
                    THEN CAST (split_part(data5, '|', 1) AS INTEGER)
            END as talktime,
            CASE
                WHEN event IN ('COMPLETEAGENT', 'COMPLETECALLER')
                    THEN CAST (data1 AS INTEGER)
                WHEN event IN ('BLINDTRANSFER', 'TRANSFER')
                    THEN CAST (data3 AS INTEGER)
                WHEN event = 'ATTENDEDTRANSFER' and data1 IN ('BRIDGE', 'APP')
                    THEN CAST (data3 AS INTEGER)
                WHEN event = 'ATTENDEDTRANSFER' and data1 = 'LINK'
                    THEN CAST (data4 AS INTEGER)
            END as waittime
        FROM
            call_entries
        WHERE
            event IN ('COMPLETEAGENT', 'COMPLETECALLER', 'ATTENDEDTRANSFER', 'BLINDTRANSFER', 'TRANSFER')
    ),
    completed_calls AS (
        SELECT
            call_end.callid,
            call_end.queuename,
            call_end.agent,
            call_start.time,
            call_end.talktime,
            call_end.waittime
        FROM
            call_end
            INNER JOIN call_start
                ON call_end.callid = call_start.callid
                AND call_end.queuename = call_start.queuename
    ),
    partial_calls AS (
        SELECT
            call_end.callid,
            call_end.queuename,
            call_end.agent,
            call_end.time
                - (call_end.talktime || ' seconds')::INTERVAL
                - (call_end.waittime || ' seconds')::INTERVAL
            AS time,
            call_end.talktime,
            call_end.waittime
        FROM
            call_end
            LEFT OUTER JOIN call_start
                ON call_end.callid = call_start.callid
                AND call_end.queuename = call_start.queuename
        WHERE
            call_start.callid IS NULL
    ),
    all_calls AS (
        SELECT * FROM completed_calls
        UNION
        SELECT * FROM partial_calls
    )

    SELECT
        all_calls.callid,
        all_calls.time,
        all_calls.talktime,
        all_calls.waittime,
        stat_queue.id as stat_queue_id,
        stat_agent.id as stat_agent_id,
        'answered' AS status
    FROM
        all_calls
    LEFT JOIN
        stat_queue ON all_calls.queuename = stat_queue.name
    LEFT JOIN
        stat_agent ON all_calls.agent = stat_agent.name AND stat_agent.tenant_uuid = stat_queue.tenant_uuid
    ORDER BY
        all_calls.time
)
'''
)


def fill_simple_calls(session, start, end):
    _run_sql_function_returning_void(
        session,
        start,
        end,
        'SELECT 1 AS place_holder FROM fill_simple_calls(:start, :end)',
    )


def fill_answered_calls(session, start, end):
    params = {
        'start': start.strftime(_STR_TIME_FMT),
        'end': end.strftime(_STR_TIME_FMT),
    }

    session.execute(FILL_ANSWERED_CALL_ON_QUEUE_QUERY, params)


def fill_leaveempty_calls(session, start, end):
    _run_sql_function_returning_void(
        session,
        start,
        end,
        'SELECT 1 AS place_holder FROM fill_leaveempty_calls(:start, :end)',
    )


def _run_sql_function_returning_void(session, start, end, function):
    start = start.strftime(_STR_TIME_FMT)
    end = end.strftime(_STR_TIME_FMT)

    (
        session.query(literal_column('place_holder'))
        .from_statement(text(function))
        .params(start=start, end=end)
        .first()
    )


def get_pause_intervals_in_range(session, start, end):
    pause_in_range = '''\
SELECT stat_agent.id AS agent,
       MIN(pauseall) AS pauseall,
       unpauseall
  FROM (
    SELECT agent, time AS pauseall,
      (
        SELECT time
        FROM queue_log
        WHERE event = 'UNPAUSEALL' AND
          agent = pause_all.agent AND
          time > pause_all.time
        ORDER BY time ASC limit 1
      ) AS unpauseall
    FROM queue_log AS pause_all
    WHERE event = 'PAUSEALL'
    AND time >= :start
    ORDER BY agent, time DESC
  ) AS pauseall, stat_agent
  WHERE stat_agent.name = agent
  GROUP BY stat_agent.id, unpauseall
'''

    start = start.strftime(_STR_TIME_FMT)
    end = end.strftime(_STR_TIME_FMT)

    rows = (
        session.query(
            literal_column('agent'),
            literal_column('pauseall'),
            literal_column('unpauseall'),
        )
        .from_statement(text(pause_in_range))
        .params(start=start, end=end)
    )

    results = {}

    for row in rows.all():
        agent_id = row.agent
        if agent_id not in results:
            results[agent_id] = []

        results[agent_id].append((row.pauseall, row.unpauseall))

    return results


def get_login_intervals_in_range(session, start, end):
    completed_logins = _get_completed_logins(session, start, end)
    ongoing_logins = _get_ongoing_logins(session, start, end)

    results = _merge_agent_statistics(
        completed_logins,
        ongoing_logins,
    )

    unique_result = {}

    for agent, logins in results.items():
        logins = _pick_longest_with_same_end(logins)
        unique_result[agent] = sorted(list(set(logins)))

    return unique_result


def _merge_agent_statistics(*args):
    result = {}

    for stat in args:
        for agent, logins in stat.items():
            if agent not in result:
                result[agent] = logins
            else:
                result[agent].extend(logins)

    for agent, logins in result.items():
        filtered_logins = _filter_overlap(logins)
        result[agent] = filtered_logins

    return result


def _filter_overlap(items):
    starts = []
    ends = []
    result = []
    stack = []

    for item in items:
        starts.append(item[0])
        ends.append(item[1])

    starts = sorted(starts)
    ends = sorted(ends)

    starts.reverse()
    ends.reverse()

    while starts or ends:
        if starts and ends and starts[-1] < ends[-1]:
            start = starts.pop()
            stack.append(start)
        else:
            end = ends.pop()
            start = stack.pop()
            if not stack:
                result.append((start, end))

    return result


def _pick_longest_with_same_end(logins):
    """
    Workaround a bug in chan_agent.so where an agent could log multiple times
    """
    end_time_map = {}
    for start, end in logins:
        if end not in end_time_map:
            end_time_map[end] = []
        end_time_map[end].append(start)

    res = []
    for end, starts in end_time_map.items():
        res.append((min(starts), end))

    return res


def _get_completed_logins(session, start, end):
    completed_logins_query = '''\
WITH agent_logins AS (
SELECT
    agent,
    context.tenant_uuid as tenant_uuid,
    time AS logout_timestamp,
    time - (data2 || ' seconds')::INTERVAL AS login_timestamp
FROM
    queue_log
JOIN context ON split_part(queue_log.data1, '@', 2) = context.name
WHERE
    event = 'AGENTCALLBACKLOGOFF'
    AND data1 <> ''
    AND data2::INTEGER > 0
    AND time > :start
    AND time <= :end
)

SELECT
    agent_logins.login_timestamp,
    agent_logins.logout_timestamp,
    stat_agent.id AS agent
FROM
    stat_agent
    INNER JOIN agent_logins
        ON agent_logins.agent = stat_agent.name AND agent_logins.tenant_uuid = stat_agent.tenant_uuid
ORDER BY
    agent_logins.agent, agent_logins.logout_timestamp
'''

    formatted_start = start.strftime(_STR_TIME_FMT)
    formatted_end = end.strftime(_STR_TIME_FMT)

    rows = (
        session.query(
            literal_column('agent'),
            literal_column('login_timestamp'),
            literal_column('logout_timestamp'),
        )
        .from_statement(text(completed_logins_query))
        .params(start=formatted_start, end=formatted_end)
    )

    results = {}

    for row in rows.all():
        if row.agent not in results:
            results[row.agent] = []
        login = row.login_timestamp if row.login_timestamp > start else start
        logout = row.logout_timestamp if row.logout_timestamp < end else end
        results[row.agent].append((login, logout))

    return results


def _get_ongoing_logins(session, start, end):
    last_logins, last_logouts = _get_last_logins_and_logouts(session, start, end)

    def filter_ended_logins(logins, logouts):
        filtered_logins = {}
        for agent, login in logins.items():
            if not login:
                continue

            logout = logouts[agent]
            if not logout or logout < login:
                filtered_logins[agent] = login if login > start else start

        return filtered_logins

    filtered_logins = filter_ended_logins(last_logins, last_logouts)

    results = {}

    for agent, login in filtered_logins.items():
        if agent not in results:
            results[agent] = []
        results[agent].append((login, end))

    return results


def _get_last_logins_and_logouts(session, start, end):
    query = '''\
SELECT
  stat_agent.id AS agent,
  MAX(case when event = 'AGENTCALLBACKLOGIN' then time end) AS login,
  MAX(case when event = 'AGENTCALLBACKLOGOFF' then time end) AS logout
FROM
  stat_agent
JOIN
  queue_log ON queue_log.agent = stat_agent.name
WHERE
  event LIKE 'AGENTCALLBACKLOG%'
GROUP BY
  stat_agent.id
HAVING
  MAX(case when event = 'AGENTCALLBACKLOGIN' then time end) < :end
'''

    start = start.strftime(_STR_TIME_FMT)
    end = end.strftime(_STR_TIME_FMT)

    rows = (
        session.query(
            literal_column('agent'),
            literal_column('login'),
            literal_column('logout'),
        )
        .from_statement(text(query))
        .params(start=start, end=end)
    )

    agent_last_logins = {}
    agent_last_logouts = {}

    for row in rows:
        agent = row.agent
        agent_last_logins[agent] = row.login
        agent_last_logouts[agent] = row.logout

    return agent_last_logins, agent_last_logouts

----------------------------------------

File: stat_queue_dao.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import distinct
from sqlalchemy.sql.expression import or_

from accent_dao.alchemy.stat_queue import StatQueue
from accent_dao.helpers.db_manager import daosession


@daosession
def _get(session, queue_id):
    return session.query(StatQueue).filter(StatQueue.id == queue_id)[0]


@daosession
def id_from_name(session, queue_name):
    res = session.query(StatQueue).filter(StatQueue.name == queue_name)
    if res.count() == 0:
        raise LookupError('No such queue')
    return res[0].id


def insert_if_missing(session, queuelog_queues, confd_queues, master_tenant):
    confd_queues_by_name = {queue['name']: queue for queue in confd_queues}
    _mark_recreated_queues_with_same_name_as_deleted(session, confd_queues_by_name)
    _mark_non_confd_queues_as_deleted(session, confd_queues)
    _create_missing_queues(
        session, queuelog_queues, confd_queues_by_name, master_tenant
    )
    _rename_deleted_queues_with_duplicate_name(session, confd_queues_by_name)


def _mark_recreated_queues_with_same_name_as_deleted(session, confd_queues_by_name):
    db_queue_query = session.query(StatQueue).filter(StatQueue.deleted.is_(False))
    db_queues_by_name = {queue.name: queue for queue in db_queue_query.all()}

    confd_queue_names = set(list(confd_queues_by_name.keys()))
    db_queue_names = set(list(db_queues_by_name.keys()))

    not_missing_queues = confd_queue_names.intersection(db_queue_names)
    for queue_name in not_missing_queues:
        confd_queue = confd_queues_by_name[queue_name]
        db_queue = db_queues_by_name[queue_name]
        if db_queue.queue_id != confd_queue['id']:
            db_queue.deleted = True
            session.flush()


def _mark_non_confd_queues_as_deleted(session, confd_queues):
    active_queue_ids = {queue['id'] for queue in confd_queues}
    all_queue_ids = {r[0] for r in session.query(distinct(StatQueue.queue_id))}
    deleted_queues = [
        queue for queue in list(all_queue_ids - active_queue_ids) if queue
    ]
    (
        session.query(StatQueue)
        .filter(
            or_(
                StatQueue.queue_id.in_(deleted_queues),
                StatQueue.queue_id.is_(None),
            )
        )
        .update({'deleted': True}, synchronize_session=False)
    )
    session.flush()


def _create_missing_queues(
    session, queuelog_queues, confd_queues_by_name, master_tenant
):
    new_queue_names = set(confd_queues_by_name.keys())
    db_queue_query = session.query(StatQueue).filter(StatQueue.deleted.is_(False))
    old_queue_names = {queue.name for queue in db_queue_query.all()}
    missing_queues = list(new_queue_names - old_queue_names)
    for queue_name in missing_queues:
        queue = confd_queues_by_name[queue_name]
        new_queue = StatQueue()
        new_queue.name = queue_name
        new_queue.tenant_uuid = queue['tenant_uuid']
        new_queue.queue_id = queue['id']
        new_queue.deleted = False
        session.add(new_queue)
        session.flush()

    db_queue_query = session.query(StatQueue).filter(StatQueue.deleted.is_(True))
    old_queue_names = {queue.name for queue in db_queue_query.all()}
    missing_queues = list(set(queuelog_queues) - old_queue_names - new_queue_names)
    for queue_name in missing_queues:
        new_queue = StatQueue()
        new_queue.name = queue_name
        new_queue.tenant_uuid = master_tenant
        new_queue.deleted = True
        session.add(new_queue)
        session.flush()


def _rename_deleted_queues_with_duplicate_name(session, confd_queues_by_name):
    db_queue_query = session.query(StatQueue).filter(StatQueue.deleted.is_(True))
    for queue in db_queue_query.all():
        if queue.name in confd_queues_by_name:
            queue.name = _find_next_available_name(session, queue.name)
            session.flush()


def _find_next_available_name(session, name):
    query = session.query(StatQueue).filter(StatQueue.name == name)
    if query.first():
        next_name = f'{name}_'
        return _find_next_available_name(session, next_name)
    return name


def clean_table(session):
    session.query(StatQueue).delete()

----------------------------------------

File: stat_queue_periodic_dao.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql.functions import max

from accent_dao.alchemy.stat_queue_periodic import StatQueuePeriodic


def insert_stats(session, stats, period_start):
    for queue_id, queue_stats in stats.items():
        entry = StatQueuePeriodic()
        entry.time = period_start
        entry.abandoned = queue_stats.get('abandoned', 0)
        entry.answered = queue_stats.get('answered', 0)
        entry.full = queue_stats.get('full', 0)
        entry.joinempty = queue_stats.get('joinempty', 0)
        entry.leaveempty = queue_stats.get('leaveempty', 0)
        entry.closed = queue_stats.get('closed', 0)
        entry.timeout = queue_stats.get('timeout', 0)
        entry.divert_ca_ratio = queue_stats.get('divert_ca_ratio', 0)
        entry.divert_waittime = queue_stats.get('divert_waittime', 0)
        entry.total = queue_stats['total']
        entry.stat_queue_id = queue_id

        session.add(entry)


def get_most_recent_time(session):
    res = session.query(max(StatQueuePeriodic.time)).first()[0]
    if res is None:
        raise LookupError('Table is empty')
    return res


def clean_table(session):
    session.query(StatQueuePeriodic).delete()


def remove_after(session, date):
    session.query(StatQueuePeriodic).filter(StatQueuePeriodic.time >= date).delete()

----------------------------------------

File: tenant_dao.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.exc import IntegrityError

from accent_dao.alchemy.tenant import Tenant
from accent_dao.helpers.db_manager import daosession


@daosession
def find_or_create_tenant(session, tenant_uuid):
    tenant = session.query(Tenant).get(tenant_uuid)

    if tenant:
        return tenant

    tenant = Tenant(uuid=tenant_uuid)

    session.begin_nested()
    try:
        session.add(tenant)
        session.commit()
    except IntegrityError:
        session.rollback()
        tenant = session.query(Tenant).get(tenant_uuid)
    return tenant


@daosession
def find(session):
    return session.query(Tenant).first()

----------------------------------------

File: user_dao.py
Please review for update

# Copyright 2023 Accent Communications

import logging

from sqlalchemy import and_

from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.line_extension import LineExtension
from accent_dao.alchemy.linefeatures import LineFeatures
from accent_dao.alchemy.user_line import UserLine
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.helpers.db_manager import daosession

logger = logging.getLogger(__name__)


@daosession
def get(session, user_id):
    if isinstance(user_id, int):
        result = session.query(UserFeatures).filter(UserFeatures.id == user_id).first()
    else:
        result = session.query(UserFeatures).filter(UserFeatures.uuid == user_id).first()
    if result is None:
        raise LookupError()
    return result


@daosession
def get_user_by_agent_id(session, agent_id):
    result = session.query(UserFeatures).filter(UserFeatures.agent_id == agent_id).first()
    if not result:
        raise LookupError()
    return result


@daosession
def get_user_by_number_context(session, exten, context):
    user = (session.query(UserFeatures)
            .join(Extension, and_(Extension.context == context,
                                  Extension.exten == exten,
                                  Extension.commented == 0))
            .join(LineExtension, LineExtension.extension_id == Extension.id)
            .join(UserLine, and_(UserLine.user_id == UserFeatures.id,
                                 UserLine.line_id == LineExtension.line_id,
                                 UserLine.main_line == True))  # noqa
            .join(LineFeatures, and_(LineFeatures.commented == 0))
            .first())

    if not user:
        raise LookupError('No user with number %s in context %s', (exten, context))

    return user

----------------------------------------

