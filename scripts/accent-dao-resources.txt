File: __init__.py
Please review for update


----------------------------------------

File: access_feature/__init__.py
Please review for update


----------------------------------------

File: access_feature/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import AccessFeaturesPersistor
from .search import access_feature_search


@daosession
def search(session, **parameters):
    return AccessFeaturesPersistor(session, access_feature_search).search(parameters)


@daosession
def get(session, access_feature_id):
    return AccessFeaturesPersistor(session, access_feature_search).get_by({'id': access_feature_id})


@daosession
def get_by(session, **criteria):
    return AccessFeaturesPersistor(session, access_feature_search).get_by(criteria)


@daosession
def find(session, access_feature_id):
    return AccessFeaturesPersistor(session, access_feature_search).find_by({'id': access_feature_id})


@daosession
def find_by(session, **criteria):
    return AccessFeaturesPersistor(session, access_feature_search).find_by(criteria)


@daosession
def find_all_by(session, **criteria):
    return AccessFeaturesPersistor(session, access_feature_search).find_all_by(criteria)


@daosession
def create(session, access_feature):
    return AccessFeaturesPersistor(session, access_feature_search).create(access_feature)


@daosession
def edit(session, access_feature):
    AccessFeaturesPersistor(session, access_feature_search).edit(access_feature)


@daosession
def delete(session, access_feature):
    AccessFeaturesPersistor(session, access_feature_search).delete(access_feature)

----------------------------------------

File: access_feature/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.accessfeatures import AccessFeatures
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin, SearchResult


class AccessFeaturesPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = AccessFeatures

    def __init__(self, session, access_feature_search):
        self.session = session
        self.access_feature_search = access_feature_search

    def _find_query(self, criteria):
        query = self.session.query(AccessFeatures)
        return self.build_criteria(query, criteria)

    def search(self, parameters):
        query = self.session.query(self.access_feature_search.config.table)
        rows, total = self.access_feature_search.search_from_query(query, parameters)
        return SearchResult(total, rows)

----------------------------------------

File: access_feature/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.accessfeatures import AccessFeatures
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=AccessFeatures,
    columns={
        'id': AccessFeatures.id,
        'host': AccessFeatures.host,
        'feature': AccessFeatures.feature,
        'enabled': AccessFeatures.enabled,
    },
    default_sort='host',
)

access_feature_search = SearchSystem(config)

----------------------------------------

File: agent/__init__.py
Please review for update


----------------------------------------

File: agent/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import AgentPersistor
from .search import agent_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return AgentPersistor(session, agent_search, tenant_uuids).search(parameters)


@daosession
def get(session, agent_id, tenant_uuids=None):
    return AgentPersistor(session, agent_search, tenant_uuids).get_by({'id': agent_id})


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return AgentPersistor(session, agent_search, tenant_uuids).get_by(criteria)


@daosession
def find(session, agent_id, tenant_uuids=None):
    return AgentPersistor(session, agent_search, tenant_uuids).find_by({'id': agent_id})


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return AgentPersistor(session, agent_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return AgentPersistor(session, agent_search, tenant_uuids).find_all_by(criteria)


@daosession
def create(session, agent):
    return AgentPersistor(session, agent_search).create(agent)


@daosession
def edit(session, agent):
    AgentPersistor(session, agent_search).edit(agent)


@daosession
def delete(session, agent):
    AgentPersistor(session, agent_search).delete(agent)


@daosession
def associate_agent_skill(session, agent, agent_skill):
    AgentPersistor(session, agent_search).associate_agent_skill(agent, agent_skill)


@daosession
def dissociate_agent_skill(session, agent, agent_skill):
    AgentPersistor(session, agent_search).dissociate_agent_skill(agent, agent_skill)

----------------------------------------

File: agent/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.agentfeatures import AgentFeatures as Agent
from accent_dao.helpers import errors
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin, SearchResult


class AgentPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Agent

    def __init__(self, session, agent_search, tenant_uuids=None):
        self.session = session
        self.agent_search = agent_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(Agent)
        query = self.build_criteria(query, criteria)
        if self.tenant_uuids is not None:
            query = query.filter(Agent.tenant_uuid.in_(self.tenant_uuids))
        return query

    def get_by(self, criteria):
        model = self.find_by(criteria)
        if not model:
            raise errors.not_found('Agent', **criteria)
        return model

    def search(self, parameters):
        query = self.session.query(Agent)
        if self.tenant_uuids is not None:
            query = query.filter(Agent.tenant_uuid.in_(self.tenant_uuids))

        rows, total = self.agent_search.search_from_query(query, parameters)
        return SearchResult(total, rows)

    def associate_agent_skill(self, agent, agent_skill):
        if agent_skill not in agent.agent_queue_skills:
            agent.agent_queue_skills.append(agent_skill)
        self.session.flush()

    def dissociate_agent_skill(self, agent, agent_skill):
        try:
            agent.agent_queue_skills.remove(agent_skill)
            self.session.flush()
        except ValueError:
            pass

----------------------------------------

File: agent/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.agentfeatures import AgentFeatures as Agent
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Agent,
    columns={
        'id': Agent.id,
        'firstname': Agent.firstname,
        'lastname': Agent.lastname,
        'number': Agent.number,
        'preprocess_subroutine': Agent.preprocess_subroutine,
    },
    default_sort='id',
)

agent_search = SearchSystem(config)

----------------------------------------

File: application/__init__.py
Please review for update


----------------------------------------

File: application/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import ApplicationPersistor
from .search import application_search


@daosession
def _persistor(session, tenant_uuids=None):
    return ApplicationPersistor(session, application_search, tenant_uuids)


def search(tenant_uuids=None, **parameters):
    return _persistor(tenant_uuids).search(parameters)


def get(application_uuid, tenant_uuids=None):
    return _persistor(tenant_uuids).get_by({'uuid': application_uuid})


def get_by(tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).get_by(criteria)


def find(application_uuid, tenant_uuids=None):
    return _persistor(tenant_uuids).find_by({'uuid': application_uuid})


def find_by(tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).find_by(criteria)


def find_all_by(tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).find_all_by(criteria)


def create(application):
    return _persistor().create(application)


def edit(application):
    _persistor().edit(application)


def delete(application):
    _persistor().delete(application)

----------------------------------------

File: application/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.application import Application
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin, SearchResult


class ApplicationPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Application

    def __init__(self, session, application_search, tenant_uuids=None):
        self.session = session
        self.application_search = application_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(Application)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def search(self, parameters):
        query = self.session.query(self.application_search.config.table)
        query = self._filter_tenant_uuid(query)
        rows, total = self.application_search.search_from_query(query, parameters)
        return SearchResult(total, rows)

----------------------------------------

File: application/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.application import Application
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Application,
    columns={
        'uuid': Application.uuid,
        'name': Application.name,
    },
    default_sort='uuid',
)

application_search = SearchSystem(config)

----------------------------------------

File: asterisk_file/__init__.py
Please review for update


----------------------------------------

File: asterisk_file/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import AsteriskFilePersistor


@daosession
def find_by(session, **kwargs):
    return AsteriskFilePersistor(session).find_by(**kwargs)


@daosession
def edit(session, asterisk_file):
    AsteriskFilePersistor(session).edit(asterisk_file)


@daosession
def edit_section_variables(session, section, variables):
    AsteriskFilePersistor(session).edit_section_variables(section, variables)

----------------------------------------

File: asterisk_file/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.asterisk_file import AsteriskFile


class AsteriskFilePersistor:
    def __init__(self, session):
        self.session = session

    def find_by(self, **kwargs):
        query = self.session.query(AsteriskFile).filter_by(**kwargs)
        return query.first()

    def edit(self, asterisk_file):
        self.session.add(asterisk_file)
        self.session.flush()

    def edit_section_variables(self, section, variables):
        section.variables = variables
        self.session.flush()

----------------------------------------

File: call_filter/__init__.py
Please review for update


----------------------------------------

File: call_filter/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.callfiltermember import Callfiltermember as CallFilterMember
from accent_dao.helpers.db_manager import daosession

from .persistor import CallFilterPersistor
from .search import call_filter_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return CallFilterPersistor(session, call_filter_search, tenant_uuids).search(
        parameters
    )


@daosession
def get(session, call_filter_id, tenant_uuids=None):
    return CallFilterPersistor(session, call_filter_search, tenant_uuids).get_by(
        {'id': call_filter_id}
    )


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return CallFilterPersistor(session, call_filter_search, tenant_uuids).get_by(
        criteria
    )


@daosession
def find(session, call_filter_id, tenant_uuids=None):
    return CallFilterPersistor(session, call_filter_search, tenant_uuids).find_by(
        {'id': call_filter_id}
    )


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return CallFilterPersistor(session, call_filter_search, tenant_uuids).find_by(
        criteria
    )


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return CallFilterPersistor(session, call_filter_search, tenant_uuids).find_all_by(
        criteria
    )


@daosession
def create(session, call_filter):
    return CallFilterPersistor(session, call_filter_search).create(call_filter)


@daosession
def edit(session, call_filter):
    CallFilterPersistor(session, call_filter_search).edit(call_filter)


@daosession
def delete(session, call_filter):
    CallFilterPersistor(session, call_filter_search).delete(call_filter)


@daosession
def associate_recipients(session, call_filter, recipients):
    CallFilterPersistor(session, call_filter_search).associate_recipients(
        call_filter, recipients
    )


@daosession
def associate_surrogates(session, call_filter, surrogates):
    CallFilterPersistor(session, call_filter_search).associate_surrogates(
        call_filter, surrogates
    )


@daosession
def member_exists(session, member_id):
    query = session.query(CallFilterMember).filter(CallFilterMember.id == member_id)
    return query.count() > 0


@daosession
def update_fallbacks(session, call_filter, fallbacks):
    CallFilterPersistor(session, call_filter_search).update_fallbacks(
        call_filter, fallbacks
    )

----------------------------------------

File: call_filter/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.callfilter import Callfilter as CallFilter
from accent_dao.helpers import errors
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin, SearchResult


class CallFilterPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = CallFilter

    def __init__(self, session, call_filter_search, tenant_uuids=None):
        self.session = session
        self.call_filter_search = call_filter_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(CallFilter)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def get_by(self, criteria):
        model = self.find_by(criteria)
        if not model:
            raise errors.not_found('CallFilter', **criteria)
        return model

    def search(self, parameters):
        query = self.session.query(self.call_filter_search.config.table)
        query = self._filter_tenant_uuid(query)
        rows, total = self.call_filter_search.search_from_query(query, parameters)
        return SearchResult(total, rows)

    def create(self, call_filter):
        self._fill_default_values(call_filter)
        self.session.add(call_filter)
        self.session.flush()
        return call_filter

    def _fill_default_values(self, call_filter):
        call_filter.type = 'bosssecretary'

    def associate_recipients(self, call_filter, recipients):
        for recipient in recipients:
            self._fill_default_recipient_values(recipient)
        call_filter.recipients = recipients
        self.session.flush()

    def _fill_default_recipient_values(self, recipient):
        recipient.type = 'user'
        recipient.bstype = 'boss'

    def associate_surrogates(self, call_filter, surrogates):
        for surrogate in surrogates:
            self._fill_default_surrogate_values(surrogate)
        call_filter.surrogates = surrogates
        self.session.flush()

    def _fill_default_surrogate_values(self, surrogate):
        surrogate.type = 'user'
        surrogate.bstype = 'secretary'

    def update_fallbacks(self, call_filter, fallbacks):
        for event in list(call_filter.callfilter_dialactions.keys()):
            if event not in fallbacks:
                call_filter.callfilter_dialactions.pop(event, None)

        for event, dialaction in fallbacks.items():
            if dialaction is None:
                call_filter.callfilter_dialactions.pop(event, None)
                continue

            if event not in call_filter.callfilter_dialactions:
                dialaction.category = 'callfilter'
                dialaction.event = event
                call_filter.callfilter_dialactions[event] = dialaction

            call_filter.callfilter_dialactions[event].action = dialaction.action
            call_filter.callfilter_dialactions[event].actionarg1 = dialaction.actionarg1
            call_filter.callfilter_dialactions[event].actionarg2 = dialaction.actionarg2

        self.session.flush()

----------------------------------------

File: call_filter/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.callfilter import Callfilter as CallFilter
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=CallFilter,
    columns={
        'id': CallFilter.id,
        'name': CallFilter.name,
        'description': CallFilter.description,
    },
    default_sort='name',
)

call_filter_search = SearchSystem(config)

----------------------------------------

File: call_permission/__init__.py
Please review for update


----------------------------------------

File: call_permission/dao.py
Please review for update

# Copyright 2023 Accent Communications

from __future__ import annotations

from contextlib import contextmanager

from sqlalchemy.orm.strategy_options import Load, loader_option

from accent_dao.helpers.db_manager import daosession
from accent_dao.resources.call_permission.persistor import CallPermissionPersistor
from accent_dao.resources.call_permission.search import call_permission_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return CallPermissionPersistor(
        session, call_permission_search, tenant_uuids
    ).search(parameters)


@daosession
def get(session, call_permission_id, tenant_uuids=None):
    return CallPermissionPersistor(
        session, call_permission_search, tenant_uuids
    ).get_by({'id': call_permission_id})


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return CallPermissionPersistor(
        session, call_permission_search, tenant_uuids
    ).get_by(criteria)


@daosession
def find(session, call_permission_id, tenant_uuids=None):
    return CallPermissionPersistor(
        session, call_permission_search, tenant_uuids
    ).find_by({'id': call_permission_id})


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return CallPermissionPersistor(
        session, call_permission_search, tenant_uuids
    ).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return CallPermissionPersistor(
        session, call_permission_search, tenant_uuids
    ).find_all_by(criteria)


@daosession
def create(session, call_permission):
    return CallPermissionPersistor(session, call_permission_search).create(
        call_permission
    )


@daosession
def edit(session, call_permission):
    CallPermissionPersistor(session, call_permission_search).edit(call_permission)


@daosession
def delete(session, call_permission):
    CallPermissionPersistor(session, call_permission_search).delete(call_permission)


@contextmanager
def query_options(*options: Load | loader_option):
    with CallPermissionPersistor.context_query_options(*options):
        yield

----------------------------------------

File: call_permission/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.rightcall import RightCall as CallPermission
from accent_dao.helpers import errors
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.query_options import QueryOptionsMixin
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class CallPermissionPersistor(QueryOptionsMixin, CriteriaBuilderMixin, BasePersistor):
    _search_table = CallPermission

    def __init__(self, session, call_permission_search, tenant_uuids=None):
        self.session = session
        self.search_system = call_permission_search
        self.tenant_uuids = tenant_uuids

    def get_by(self, criteria):
        model = self.find_by(criteria)
        if not model:
            raise errors.not_found('CallPermission', **criteria)
        return model

    def _find_query(self, criteria):
        query = self._generate_query()
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self._generate_query()

----------------------------------------

File: call_permission/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.rightcall import RightCall as CallPermission
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=CallPermission,
    columns={
        'id': CallPermission.id,
        'name': CallPermission.name,
        'description': CallPermission.description,
        'enabled': CallPermission.enabled,
        'mode': CallPermission.mode,
    },
    default_sort='name',
)

call_permission_search = SearchSystem(config)

----------------------------------------

File: call_permission/strategy.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import selectinload

from accent_dao.alchemy.rightcall import RightCall as CallPermission

preload_relationships = (
    selectinload(CallPermission.rightcall_groups)
    .selectinload('group')
    .load_only('uuid', 'id', 'name'),
    selectinload(CallPermission.rightcall_users)
    .selectinload('user')
    .load_only('uuid', 'firstname', 'webi_lastname'),
    selectinload(CallPermission.rightcall_outcalls)
    .selectinload('outcall')
    .load_only('id', 'name'),
    selectinload(CallPermission.rightcallextens),
)

----------------------------------------

File: call_pickup/__init__.py
Please review for update


----------------------------------------

File: call_pickup/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import CallPickupPersistor
from .search import call_pickup_search


@daosession
def _persistor(session, tenant_uuids=None):
    return CallPickupPersistor(session, call_pickup_search, tenant_uuids)


@daosession
def search(session, tenant_uuids=None, **parameters):
    return _persistor(tenant_uuids).search(parameters)


@daosession
def get(session, call_pickup_id, tenant_uuids=None):
    return _persistor(tenant_uuids).get_by({'id': call_pickup_id})


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).get_by(criteria)


@daosession
def find(session, call_pickup_id, tenant_uuids=None):
    return _persistor(tenant_uuids).find_by({'id': call_pickup_id})


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).find_all_by(criteria)


@daosession
def create(session, call_pickup):
    return _persistor().create(call_pickup)


@daosession
def edit(session, call_pickup):
    _persistor().edit(call_pickup)


@daosession
def delete(session, call_pickup):
    _persistor().delete(call_pickup)


@daosession
def associate_interceptor_users(session, call_pickup, users):
    _persistor().associate_interceptor_users(call_pickup, users)


@daosession
def associate_interceptor_groups(session, call_pickup, groups):
    _persistor().associate_interceptor_groups(call_pickup, groups)


@daosession
def associate_target_users(session, call_pickup, users):
    _persistor().associate_target_users(call_pickup, users)


@daosession
def associate_target_groups(session, call_pickup, groups):
    _persistor().associate_target_groups(call_pickup, groups)

----------------------------------------

File: call_pickup/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.pickup import Pickup as CallPickup
from accent_dao.helpers import errors
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class CallPickupPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = CallPickup

    def __init__(self, session, call_pickup_search, tenant_uuids=None):
        self.session = session
        self.search_system = call_pickup_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(CallPickup)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def get_by(self, criteria):
        model = self.find_by(criteria)
        if not model:
            raise errors.not_found('CallPickup', **criteria)
        return model

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

    def create(self, call_pickup):
        self._fill_default_values(call_pickup)
        self.session.add(call_pickup)
        self.session.flush()
        return call_pickup

    def _fill_default_values(self, call_pickup):
        last_id = (
            self.session.query(CallPickup.id)
            .order_by(CallPickup.id.desc())
            .limit(1)
            .scalar()
        )
        call_pickup.id = 1 if last_id is None else last_id + 1

    def associate_interceptor_users(self, call_pickup, users):
        call_pickup.user_interceptors = users
        self.session.flush()

    def associate_target_users(self, call_pickup, users):
        call_pickup.user_targets = users
        self.session.flush()

    def associate_interceptor_groups(self, call_pickup, groups):
        call_pickup.group_interceptors = groups
        self.session.flush()

    def associate_target_groups(self, call_pickup, groups):
        call_pickup.group_targets = groups
        self.session.flush()

----------------------------------------

File: call_pickup/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.pickup import Pickup as CallPickup
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=CallPickup,
    columns={
        'id': CallPickup.id,
        'name': CallPickup.name,
        'description': CallPickup.description,
        'enabled': CallPickup.enabled,
    },
    search=['name', 'description'],
    default_sort='name',
)

call_pickup_search = SearchSystem(config)

----------------------------------------

File: conference/__init__.py
Please review for update


----------------------------------------

File: conference/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import ConferencePersistor
from .search import conference_search


@daosession
def _persistor(session, tenant_uuids=None):
    return ConferencePersistor(session, conference_search, tenant_uuids)


def search(tenant_uuids=None, **parameters):
    return _persistor(tenant_uuids).search(parameters)


def get(conference_id, tenant_uuids=None):
    return _persistor(tenant_uuids).get_by({'id': conference_id})


def get_by(tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).get_by(criteria)


def find(conference_id, tenant_uuids=None):
    return _persistor(tenant_uuids).find_by({'id': conference_id})


def find_by(tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).find_by(criteria)


def find_all_by(tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).find_all_by(criteria)


def create(conference):
    return _persistor().create(conference)


def edit(conference):
    _persistor().edit(conference)


def delete(conference):
    _persistor().delete(conference)

----------------------------------------

File: conference/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.conference import Conference
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class ConferencePersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Conference

    def __init__(self, session, conference_search, tenant_uuids=None):
        self.session = session
        self.search_system = conference_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(Conference)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

    def delete(self, conference):
        self._delete_associations(conference)
        self.session.delete(conference)
        self.session.flush()

    def _delete_associations(self, conference):
        for extension in conference.extensions:
            extension.type = 'user'
            extension.typeval = '0'

----------------------------------------

File: conference/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.conference import Conference
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Conference,
    columns={
        'id': Conference.id,
        'name': Conference.name,
        'preprocess_subroutine': Conference.preprocess_subroutine,
        'exten': Conference.exten,
    },
    default_sort='name',
)

conference_search = SearchSystem(config)

----------------------------------------

File: configuration/__init__.py
Please review for update


----------------------------------------

File: configuration/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.infos import Infos
from accent_dao.helpers.db_manager import daosession
from accent_dao.helpers.db_utils import flush_session


@daosession
def is_live_reload_enabled(session):
    infos = session.query(Infos).first()
    return infos.live_reload_enabled


@daosession
def set_live_reload_status(session, data):
    value = data['enabled']
    with flush_session(session):
        session.query(Infos).update({'live_reload_enabled': value})

----------------------------------------

File: context/__init__.py
Please review for update


----------------------------------------

File: context/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import ContextPersistor
from .search import context_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return ContextPersistor(session, context_search, tenant_uuids).search(parameters)


@daosession
def get(session, context_id, tenant_uuids=None):
    return ContextPersistor(session, context_search, tenant_uuids).get_by(
        {'id': context_id}
    )


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return ContextPersistor(session, context_search, tenant_uuids).get_by(criteria)


@daosession
def get_by_name(session, context_name, tenant_uuids=None):
    return ContextPersistor(session, context_search, tenant_uuids).get_by(
        {'name': context_name}
    )


@daosession
def find(session, context_id):
    return ContextPersistor(session, context_search).find_by({'id': context_id})


@daosession
def find_by(session, **criteria):
    return ContextPersistor(session, context_search).find_by(criteria)


@daosession
def find_all_by(session, **criteria):
    return ContextPersistor(session, context_search).find_all_by(criteria)


@daosession
def create(session, context):
    return ContextPersistor(session, context_search).create(context)


@daosession
def edit(session, context):
    ContextPersistor(session, context_search).edit(context)


@daosession
def delete(session, context):
    ContextPersistor(session, context_search).delete(context)


@daosession
def associate_contexts(session, context, contexts):
    ContextPersistor(session, context_search).associate_contexts(context, contexts)

----------------------------------------

File: context/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.context import Context
from accent_dao.alchemy.contextmember import ContextMember
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class ContextPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Context

    def __init__(self, session, context_search, tenant_uuids=None):
        self.session = session
        self.search_system = context_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(Context)
        if self.tenant_uuids is not None:
            query = query.filter(Context.tenant_uuid.in_(self.tenant_uuids))
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(Context)

    def edit(self, context):
        self.session.add(context)
        self.session.flush()

    def delete(self, context):
        self._delete_associations(context)
        self.session.delete(context)
        self.session.flush()

    def _delete_associations(self, context):
        (
            self.session.query(ContextMember)
            .filter(ContextMember.context == context.name)
            .delete()
        )

    def associate_contexts(self, context, contexts):
        context.contexts = contexts
        self.session.flush()

----------------------------------------

File: context/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.context import Context
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Context,
    columns={
        'id': Context.id,
        'description': Context.description,
        'name': Context.name,
        'label': Context.label,
        'type': Context.type,
    },
    default_sort='id',
)

context_search = SearchSystem(config)

----------------------------------------

File: directory_profile/__init__.py
Please review for update


----------------------------------------

File: directory_profile/dao.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import Integer
from sqlalchemy.sql import cast

from accent_dao.alchemy.dialaction import Dialaction
from accent_dao.alchemy.linefeatures import LineFeatures
from accent_dao.alchemy.user_line import UserLine
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.helpers.db_manager import daosession


@daosession
def find_by_incall_id(session, incall_id):
    row = (
        session.query(
            UserFeatures.uuid.label('accent_user_uuid'),
            LineFeatures.context.label('profile'),
        ).filter(
            Dialaction.category == 'incall',
            Dialaction.categoryval == str(incall_id),
            Dialaction.action == 'user',
            UserFeatures.id == cast(Dialaction.actionarg1, Integer),
            UserLine.user_id == UserFeatures.id,
            UserLine.line_id == LineFeatures.id,
            UserLine.main_line.is_(True),
            UserLine.main_user.is_(True),
        )
    ).first()
    return row

----------------------------------------

File: endpoint_custom/__init__.py
Please review for update


----------------------------------------

File: endpoint_custom/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import Session
from accent_dao.helpers.db_utils import flush_session

from .persistor import CustomPersistor
from .search import custom_search


def persistor(tenant_uuids=None):
    return CustomPersistor(Session, custom_search, tenant_uuids)


def get(custom_id, tenant_uuids=None):
    return persistor(tenant_uuids).get(custom_id)


def find_by(tenant_uuids=None, **criteria):
    return persistor(tenant_uuids).find_by(criteria)


def find_all_by(tenant_uuids=None, **criteria):
    return persistor(tenant_uuids).find_all_by(criteria)


def search(tenant_uuids=None, **parameters):
    return persistor(tenant_uuids).search(parameters)


def create(custom):
    with flush_session(Session):
        return persistor().create(custom)


def edit(custom):
    with flush_session(Session):
        return persistor().edit(custom)


def delete(custom):
    with flush_session(Session):
        return persistor().delete(custom)

----------------------------------------

File: endpoint_custom/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.usercustom import UserCustom as Custom
from accent_dao.helpers import errors
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.line.fixes import LineFixes
from accent_dao.resources.trunk.fixes import TrunkFixes
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class CustomPersistor(CriteriaBuilderMixin, BasePersistor):

    _search_table = Custom

    def __init__(self, session, custom_search, tenant_uuids=None):
        self.session = session
        self.search_system = custom_search
        self.tenant_uuids = tenant_uuids

    def get(self, custom_id):
        custom = self._find_query({'id': custom_id}).first()
        if not custom:
            raise errors.not_found('CustomEndpoint', id=id)
        return custom

    def _find_query(self, criteria):
        query = self.session.query(Custom)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

    def create(self, custom):
        self.fill_default_values(custom)
        self.session.add(custom)
        self.session.flush()
        return custom

    def fill_default_values(self, custom):
        if custom.protocol is None:
            custom.protocol = 'custom'
        if custom.category is None:
            custom.category = 'user'

    def edit(self, custom):
        self.session.add(custom)
        self.session.flush()
        self._fix_associated(custom)

    def delete(self, custom):
        self.session.query(Custom).filter_by(id=custom.id).delete()
        self.session.expire_all()
        self.session.flush()
        self._fix_associated(custom)

    def _fix_associated(self, custom):
        if custom.line:
            LineFixes(self.session).fix(custom.line.id)

        if custom.trunk:
            TrunkFixes(self.session).fix(custom.trunk.id)

----------------------------------------

File: endpoint_custom/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.usercustom import UserCustom
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=UserCustom,
    columns={
        'id': UserCustom.id,
        'interface': UserCustom.interface,
        'context': UserCustom.context,
    },
    default_sort='interface',
)

custom_search = SearchSystem(config)

----------------------------------------

File: endpoint_iax/__init__.py
Please review for update


----------------------------------------

File: endpoint_iax/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_utils import flush_session
from accent_dao.helpers.db_manager import daosession

from .persistor import IAXPersistor
from .search import iax_search


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return IAXPersistor(session, iax_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return IAXPersistor(session, iax_search, tenant_uuids).find_all_by(criteria)


@daosession
def search(session, tenant_uuids=None, **parameters):
    return IAXPersistor(session, iax_search, tenant_uuids).search(parameters)


@daosession
def get(session, iax_id, tenant_uuids=None):
    return IAXPersistor(session, iax_search, tenant_uuids).get(iax_id)


@daosession
def create(session, iax):
    with flush_session(session):
        return IAXPersistor(session, iax_search).create(iax)


@daosession
def edit(session, iax):
    with flush_session(session):
        IAXPersistor(session, iax_search).edit(iax)


@daosession
def delete(session, iax):
    with flush_session(session):
        return IAXPersistor(session, iax_search).delete(iax)

----------------------------------------

File: endpoint_iax/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from functools import partial

from accent_dao.alchemy.useriax import UserIAX as IAX
from accent_dao.helpers import errors, generators
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.trunk.fixes import TrunkFixes
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class IAXPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = IAX

    def __init__(self, session, iax_search, tenant_uuids=None):
        self.session = session
        self.search_system = iax_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(IAX)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def get(self, iax_id):
        iax = self.find_by({'id': iax_id})
        if not iax:
            raise errors.not_found('IAXEndpoint', id=iax_id)
        return iax

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

    def create(self, iax):
        self.fill_default_values(iax)
        self.persist(iax)
        return self.get(iax.id)

    def edit(self, iax):
        self.persist(iax)
        self._fix_associated(iax)

    def delete(self, iax):
        self.session.query(IAX).filter(IAX.id == iax.id).delete()
        self._fix_associated(iax)

    def _fix_associated(self, iax):
        if iax.trunk_rel:
            TrunkFixes(self.session).fix(iax.trunk_rel.id)

    def fill_default_values(self, iax):
        if iax.name is None:
            iax.name = generators.find_unused_hash(
                partial(self._already_exists, IAX.name)
            )
        if iax.type is None:
            iax.type = 'friend'
        if iax.host is None:
            iax.host = 'dynamic'
        if iax.category is None:
            iax.category = 'trunk'

    def _already_exists(self, column, data):
        return self.session.query(IAX).filter(column == data).count() > 0

----------------------------------------

File: endpoint_iax/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.useriax import UserIAX
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=UserIAX,
    columns={'name': UserIAX.name, 'type': UserIAX.type, 'host': UserIAX.host},
    default_sort='name',
)

iax_search = SearchSystem(config)

----------------------------------------

File: endpoint_sccp/__init__.py
Please review for update


----------------------------------------

File: endpoint_sccp/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession
from accent_dao.helpers.db_utils import flush_session

from .persistor import SccpPersistor
from .search import sccp_search


@daosession
def get(session, sccp_id, tenant_uuids=None):
    return SccpPersistor(session, sccp_search, tenant_uuids).get(sccp_id)


@daosession
def find(session, sccp_id, tenant_uuids=None):
    return SccpPersistor(session, sccp_search, tenant_uuids).find(sccp_id)


@daosession
def search(session, tenant_uuids=None, **parameters):
    return SccpPersistor(session, sccp_search, tenant_uuids).search(parameters)


@daosession
def create(session, sccp):
    with flush_session(session):
        return SccpPersistor(session, sccp_search).create(sccp)


@daosession
def edit(session, sccp):
    with flush_session(session):
        return SccpPersistor(session, sccp_search).edit(sccp)


@daosession
def delete(session, sccp):
    with flush_session(session):
        return SccpPersistor(session, sccp_search).delete(sccp)

----------------------------------------

File: endpoint_sccp/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from functools import partial

from sqlalchemy import text

from accent_dao.alchemy.sccpline import SCCPLine as SCCP
from accent_dao.helpers import errors, generators
from accent_dao.resources.line.fixes import LineFixes
from accent_dao.resources.utils.search import SearchResult


class SccpPersistor:
    def __init__(self, session, sccp_search, tenant_uuids=None):
        self.session = session
        self.sccp_search = sccp_search
        self.tenant_uuids = tenant_uuids

    def get(self, sccp_id):
        sccp = self.find(sccp_id)
        if not sccp:
            raise errors.not_found('SCCPEndpoint', id=sccp_id)
        return sccp

    def find(self, sccp_id):
        query = self.session.query(SCCP).filter(SCCP.id == sccp_id)
        query = self._filter_tenant_uuid(query)
        return query.first()

    def search(self, parameters):
        query = self.session.query(self.sccp_search.config.table)
        query = self._filter_tenant_uuid(query)
        rows, total = self.sccp_search.search_from_query(query, parameters)
        return SearchResult(total, rows)

    def create(self, sccp):
        self.fill_default_values(sccp)
        self.session.add(sccp)
        self.session.flush()
        return sccp

    def fill_default_values(self, sccp):
        if sccp.name is None:
            sccp.name = generators.find_unused_hash(
                partial(self._already_exists, SCCP.name)
            )
        if sccp.context is None:
            sccp.context = ''
        if sccp.cid_name is None:
            sccp.cid_name = ''
        if sccp.cid_num is None:
            sccp.cid_num = ''

    def edit(self, sccp):
        self.session.add(sccp)
        self.session.flush()

    def delete(self, sccp):
        self.session.delete(sccp)
        self.session.expire_all()
        self.session.flush()
        self._fix_line(sccp)

    def _filter_tenant_uuid(self, query):
        if self.tenant_uuids is None:
            return query

        if not self.tenant_uuids:
            return query.filter(text('false'))

        return query.filter(SCCP.tenant_uuid.in_(self.tenant_uuids))

    def _already_exists(self, column, data):
        return self.session.query(SCCP).filter(column == data).count() > 0

    def _fix_line(self, sccp):
        if sccp.line:
            LineFixes(self.session).fix(sccp.line.id)

----------------------------------------

File: endpoint_sccp/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.sccpline import SCCPLine
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(table=SCCPLine, columns={'id': SCCPLine.id}, default_sort='id')

sccp_search = SearchSystem(config)

----------------------------------------

File: endpoint_sip/__init__.py
Please review for update


----------------------------------------

File: endpoint_sip/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession
from accent_dao.helpers.db_utils import flush_session

from .persistor import SipPersistor
from .search import sip_search


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return SipPersistor(session, sip_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return SipPersistor(session, sip_search, tenant_uuids).find_all_by(criteria)


@daosession
def search(session, tenant_uuids=None, **parameters):
    return SipPersistor(session, sip_search, tenant_uuids).search(parameters)


@daosession
def get(session, sip_uuid, template, tenant_uuids=None):
    return SipPersistor(session, sip_search, tenant_uuids).get_by(
        {'uuid': sip_uuid, 'template': template},
    )


@daosession
def create(session, sip):
    with flush_session(session):
        return SipPersistor(session, sip_search).create(sip)


@daosession
def edit(session, sip):
    with flush_session(session):
        SipPersistor(session, sip_search).edit(sip)


@daosession
def delete(session, sip):
    with flush_session(session):
        return SipPersistor(session, sip_search).delete(sip)

----------------------------------------

File: endpoint_sip/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import joinedload, selectinload

from accent_dao.alchemy.endpoint_sip import EndpointSIP
from accent_dao.helpers import errors, generators
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.line.fixes import LineFixes
from accent_dao.resources.trunk.fixes import TrunkFixes
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class SipPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = EndpointSIP

    def __init__(self, session, sip_search, tenant_uuids=None):
        self.session = session
        self.search_system = sip_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = (
            self.session.query(EndpointSIP)
            .options(selectinload('transport'))
            .options(selectinload('template_relations').selectinload('parent'))
            .options(selectinload('_aor_section'))
            .options(selectinload('_auth_section'))
            .options(selectinload('_endpoint_section'))
            .options(selectinload('_registration_section'))
            .options(selectinload('_registration_outbound_auth_section'))
            .options(selectinload('_identify_section'))
            .options(selectinload('_outbound_auth_section'))
            .options(selectinload('line'))
            .options(selectinload('trunk'))
        )
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def get_by(self, criteria):
        sip = self.find_by(criteria)
        if not sip:
            template = criteria.pop('template', None)
            if template:
                raise errors.not_found('SIPEndpointTemplate', **criteria)
            else:
                raise errors.not_found('SIPEndpoint', **criteria)
        return sip

    def _search_query(self):
        return (
            self.session.query(self.search_system.config.table)
            .options(joinedload('transport'))
            .options(joinedload('template_relations').joinedload('parent'))
            .options(joinedload('_aor_section'))
            .options(joinedload('_auth_section'))
            .options(joinedload('_endpoint_section'))
            .options(joinedload('_registration_section'))
            .options(joinedload('_registration_outbound_auth_section'))
            .options(joinedload('_identify_section'))
            .options(joinedload('_outbound_auth_section'))
            .options(joinedload('line'))
            .options(joinedload('trunk'))
        )

    def create(self, sip):
        self._fill_default_values(sip)
        self.session.add(sip)
        self.session.flush()
        return sip

    def edit(self, sip):
        self.persist(sip)
        self._fix_associated(sip)

    def delete(self, sip):
        self.session.delete(sip)
        self._fix_associated(sip)

    def _fix_associated(self, sip):
        if sip.line:
            LineFixes(self.session).fix(sip.line.id)

        if sip.trunk:
            TrunkFixes(self.session).fix(sip.trunk.id)

    def _fill_default_values(self, sip):
        if sip.name is None:
            sip.name = generators.find_unused_hash(self._name_already_exists)

    def _name_already_exists(self, data):
        return (
            self.session.query(EndpointSIP).filter(EndpointSIP.name == data).count() > 0
        )

----------------------------------------

File: endpoint_sip/search.py
Please review for update

# Copyright 2023 Accent Communications

import uuid

from sqlalchemy.sql import text

from accent_dao.alchemy.endpoint_sip import EndpointSIP
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=EndpointSIP,
    columns={
        'name': EndpointSIP.name,
        'asterisk_id': EndpointSIP.asterisk_id,
        'label': EndpointSIP.label,
        'template': EndpointSIP.template,
    },
    default_sort='label',
)


class EndpointSIPSearchSystem(SearchSystem):
    def search_from_query(self, query, parameters=None):
        if isinstance(parameters, dict):
            if uuid_param := parameters.pop('uuid', None):
                uuids = [uuid for uuid in uuid_param.split(',') if is_valid_uuid(uuid)]
                query = self._filter_exact_match_uuids(query, uuids)
            return super().search_from_query(query, parameters)

    def _filter_exact_match_uuids(self, query, uuids):
        if not uuids:
            return query.filter(text('false'))
        else:
            return query.filter(EndpointSIP.uuid.in_(uuids))


def is_valid_uuid(input):
    try:
        uuid.UUID(input)
        return True
    except ValueError:
        return False


sip_search = EndpointSIPSearchSystem(config)

----------------------------------------

File: extension/__init__.py
Please review for update


----------------------------------------

File: extension/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import Session
from accent_dao.resources.utils.search import SearchResult

from .fixes import ExtensionFixes
from .persistor import ExtensionPersistor


def persistor(tenant_uuids=None):
    return ExtensionPersistor(Session, tenant_uuids)


def get_by(tenant_uuids=None, **criteria):
    return persistor(tenant_uuids).get_by(criteria)


def find_by(tenant_uuids=None, **criteria):
    return persistor(tenant_uuids).find_by(criteria)


def find_all_by(tenant_uuids=None, **criteria):
    return persistor(tenant_uuids).find_all_by(criteria)


def get(id, tenant_uuids=None):
    return persistor(tenant_uuids).get_by({'id': id})


def find(id, tenant_uuids=None):
    return persistor(tenant_uuids).find_by({'id': id})


def search(tenant_uuids=None, **parameters):
    total, items = persistor(tenant_uuids).search(parameters)
    return SearchResult(total, items)


def create(extension):
    return persistor().create(extension)


def edit(extension):
    persistor().edit(extension)
    ExtensionFixes(Session).fix(extension.id)


def delete(extension):
    persistor().delete(extension)


def associate_incall(incall, extension):
    persistor().associate_incall(incall, extension)
    ExtensionFixes(Session).fix(extension.id)


def dissociate_incall(incall, extension):
    persistor().dissociate_incall(incall, extension)
    ExtensionFixes(Session).fix(extension.id)


def associate_group(group, extension):
    persistor().associate_group(group, extension)


def dissociate_group(group, extension):
    persistor().dissociate_group(group, extension)


def associate_queue(queue, extension):
    persistor().associate_queue(queue, extension)
    queue.fix_extension()


def dissociate_queue(queue, extension):
    persistor().dissociate_queue(queue, extension)
    queue.fix_extension()


def associate_conference(conference, extension):
    persistor().associate_conference(conference, extension)


def dissociate_conference(conference, extension):
    persistor().dissociate_conference(conference, extension)


def associate_parking_lot(parking_lot, extension):
    persistor().associate_parking_lot(parking_lot, extension)


def dissociate_parking_lot(parking_lot, extension):
    persistor().dissociate_parking_lot(parking_lot, extension)

----------------------------------------

File: extension/database.py
Please review for update

# Copyright 2023 Accent Communications

from __future__ import annotations

from typing import NamedTuple

from accent.accent_helpers import clean_extension


class ServiceExtension(NamedTuple):
    id: int
    exten: str
    service: str


class ForwardExtension(NamedTuple):
    id: int
    exten: str
    forward: str


class AgentActionExtension(NamedTuple):
    id: int
    exten: str
    action: str


class ServiceExtensionConverter:
    SERVICES = (
        "enablevm",
        "vmusermsg",
        "vmuserpurge",
        "phonestatus",
        "recsnd",
        "calllistening",
        "directoryaccess",
        "fwdundoall",
        "pickup",
        "callrecord",
        "incallfilter",
        "enablednd",
    )

    @classmethod
    def typevals(cls):
        return cls.SERVICES

    def to_model(self, row):
        exten = clean_extension(row.exten)
        return ServiceExtension(id=row.id, exten=exten, service=row.typeval)


class ForwardExtensionConverter:
    FORWARDS = {'fwdbusy': 'busy', 'fwdrna': 'noanswer', 'fwdunc': 'unconditional'}  # noqa: RUF012

    TYPEVALS = {value: key for key, value in FORWARDS.items()}

    def typevals(self):
        return list(self.FORWARDS.keys())

    def to_typeval(self, forward):
        return self.TYPEVALS[forward]

    def to_forward(self, typeval):
        return self.FORWARDS[typeval]

    def to_model(self, row):
        forward = self.FORWARDS[row.typeval]
        exten = clean_extension(row.exten)
        return ForwardExtension(id=row.id, exten=exten, forward=forward)


class AgentActionExtensionConverter:
    ACTIONS = {  # noqa: RUF012
        'agentstaticlogin': 'login',
        'agentstaticlogoff': 'logout',
        'agentstaticlogtoggle': 'toggle',
    }

    TYPEVALS = {value: key for key, value in ACTIONS.items()}

    def typevals(self):
        return list(self.ACTIONS.keys())

    def to_typeval(self, action):
        return self.TYPEVALS[action]

    def to_action(self, typeval):
        return self.ACTIONS[typeval]

    def to_model(self, row):
        action = self.ACTIONS[row.typeval]
        exten = clean_extension(row.exten)
        return AgentActionExtension(id=row.id, exten=exten, action=action)


class GroupMemberActionExtensionConverter:
    ACTIONS = {  # noqa: RUF012
        'groupmemberjoin': 'join',
        'groupmemberleave': 'leave',
        'groupmembertoggle': 'toggle',
    }

    TYPEVALS = {value: key for key, value in ACTIONS.items()}

    def typevals(self):
        return list(self.ACTIONS.keys())

    def to_typeval(self, action):
        return self.TYPEVALS[action]

    def to_action(self, typeval):
        return self.ACTIONS[typeval]

    def to_model(self, row):
        action = self.ACTIONS[row.typeval]
        exten = clean_extension(row.exten)
        return AgentActionExtension(id=row.id, exten=exten, action=action)


agent_action_converter = AgentActionExtensionConverter()
fwd_converter = ForwardExtensionConverter()
group_member_action_converter = GroupMemberActionExtensionConverter()
service_converter = ServiceExtensionConverter()

----------------------------------------

File: extension/fixes.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.line_extension import LineExtension
from accent_dao.alchemy.user_line import UserLine
from accent_dao.resources.line.fixes import LineFixes


class ExtensionFixes:
    def __init__(self, session):
        self.session = session

    def fix(self, extension_id):
        self.fix_extension(extension_id)
        self.fix_lines(extension_id)
        self.session.flush()

    def fix_extension(self, extension_id):
        user_lines = self.find_all_user_line(extension_id)
        if user_lines:
            for user_line in user_lines:
                self.adjust_for_user(extension_id, user_line.user_id)
            return

        self.reset_destination(extension_id)

    def fix_lines(self, extension_id):
        line_extensions = self.find_all_line_extension(extension_id)
        for line_extension in line_extensions:
            self.adjust_line(line_extension.line_id)

    def find_all_user_line(self, extension_id):
        return (
            self.session.query(UserLine.user_id)
            .join(LineExtension, LineExtension.line_id == UserLine.line_id)
            .filter(LineExtension.extension_id == extension_id)
            .filter(LineExtension.main_extension == True)  # noqa
            .filter(UserLine.main_user == True)  # noqa
            .all()
        )

    def find_all_line_extension(self, extension_id):
        return (
            self.session.query(LineExtension.line_id)
            .filter(LineExtension.extension_id == extension_id)
            .filter(LineExtension.main_extension == True)  # noqa
            .all()
        )

    def adjust_for_user(self, extension_id, user_id):
        (
            self.session.query(Extension)
            .filter(Extension.id == extension_id)
            .update({'type': 'user', 'typeval': str(user_id)})
        )

    def reset_destination(self, extension_id):
        destination = self.get_destination(extension_id)
        if destination == 'user':
            self.remove_destination_id(extension_id)

    def get_destination(self, extension_id):
        return (
            self.session.query(Extension.type)
            .filter(Extension.id == extension_id)
            .scalar()
        )

    def remove_destination_id(self, extension_id):
        (
            self.session.query(Extension)
            .filter(Extension.id == extension_id)
            .update({'type': 'user', 'typeval': '0'})
        )

    def adjust_line(self, line_id):
        LineFixes(self.session).fix(line_id)

----------------------------------------

File: extension/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text
from sqlalchemy.orm import joinedload

from accent_dao.alchemy.extension import Extension
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.extension.search import extension_search
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class ExtensionPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Extension

    def __init__(self, session, tenant_uuids=None):
        self.session = session
        self.tenant_uuids = tenant_uuids
        self.search_system = extension_search

    def _find_query(self, criteria):
        query = self.session.query(Extension)
        query = self.build_criteria(query, criteria)
        query = self._add_tenant_filter(query)
        return query

    def _search_query(self):
        return (
            self.session.query(Extension)
            .options(joinedload('conference'))
            .options(joinedload('dialpattern').joinedload('outcall'))
            .options(joinedload('group'))
            .options(joinedload('context_rel'))
            .options(joinedload('queue'))
            .options(joinedload('incall'))
            .options(joinedload('line_extensions').joinedload('line'))
            .options(joinedload('parking_lot'))
        )

    def create(self, extension):
        self.fill_default_values(extension)
        self.session.add(extension)
        self.session.flush()
        return extension

    def fill_default_values(self, extension):
        if not extension.type:
            extension.type = 'user'
        if not extension.typeval:
            extension.typeval = '0'

    def delete(self, extension):
        self.session.query(Extension).filter(Extension.id == extension.id).delete()
        self.session.flush()

    def associate_incall(self, incall, extension):
        extension.type = 'incall'
        extension.typeval = str(incall.id)
        self.session.flush()
        self.session.expire(incall, ['extensions'])

    def dissociate_incall(self, incall, extension):
        if incall is extension.incall:
            extension.type = 'user'
            extension.typeval = '0'
            self.session.flush()
            self.session.expire(incall, ['extensions'])

    def associate_group(self, group, extension):
        extension.type = 'group'
        extension.typeval = str(group.id)
        self.session.flush()
        self.session.expire(group, ['extensions'])

    def dissociate_group(self, group, extension):
        if group is extension.group:
            extension.type = 'user'
            extension.typeval = '0'
            self.session.flush()
            self.session.expire(group, ['extensions'])

    def associate_queue(self, queue, extension):
        extension.type = 'queue'
        extension.typeval = str(queue.id)
        self.session.flush()
        self.session.expire(queue, ['extensions'])

    def dissociate_queue(self, queue, extension):
        if queue is extension.queue:
            extension.type = 'user'
            extension.typeval = '0'
            self.session.flush()
            self.session.expire(queue, ['extensions'])

    def associate_conference(self, conference, extension):
        extension.type = 'conference'
        extension.typeval = str(conference.id)
        self.session.flush()
        self.session.expire(conference, ['extensions'])

    def dissociate_conference(self, conference, extension):
        if conference is extension.conference:
            extension.type = 'user'
            extension.typeval = '0'
            self.session.flush()
            self.session.expire(conference, ['extensions'])

    def associate_parking_lot(self, parking_lot, extension):
        extension.type = 'parking'
        extension.typeval = str(parking_lot.id)
        self.session.flush()
        self.session.expire(parking_lot, ['extensions'])

    def dissociate_parking_lot(self, parking_lot, extension):
        if parking_lot is extension.parking_lot:
            extension.type = 'user'
            extension.typeval = '0'
            self.session.flush()
            self.session.expire(parking_lot, ['extensions'])

    def _add_tenant_filter(self, query):
        if self.tenant_uuids is None:
            return query

        if not self.tenant_uuids:
            return query.filter(text('false'))

        return query.filter(Extension.tenant_uuid.in_(self.tenant_uuids))

----------------------------------------

File: extension/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.extension import Extension
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Extension,
    columns={
        'exten': Extension.exten,
        'context': Extension.context,
        'type': Extension.context_type,
    },
    default_sort='exten',
)


extension_search = SearchSystem(config)

----------------------------------------

File: external_app/__init__.py
Please review for update


----------------------------------------

File: external_app/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import Session

from .persistor import ExternalAppPersistor
from .search import external_app_search


def _persistor(tenant_uuids=None):
    return ExternalAppPersistor(Session, external_app_search, tenant_uuids)


def search(tenant_uuids=None, **parameters):
    return _persistor(tenant_uuids).search(parameters)


def get(external_app_name, tenant_uuids=None):
    return _persistor(tenant_uuids).get_by({'name': external_app_name})


def get_by(tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).get_by(criteria)


def find(external_app_name, tenant_uuids=None):
    return _persistor(tenant_uuids).find_by({'name': external_app_name})


def find_by(tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).find_by(criteria)


def find_all_by(tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).find_all_by(criteria)


def create(external_app):
    return _persistor().create(external_app)


def edit(external_app):
    _persistor().edit(external_app)


def delete(external_app):
    _persistor().delete(external_app)

----------------------------------------

File: external_app/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.external_app import ExternalApp
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class ExternalAppPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = ExternalApp

    def __init__(self, session, external_app_search, tenant_uuids=None):
        self.session = session
        self.search_system = external_app_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(ExternalApp)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

----------------------------------------

File: external_app/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.external_app import ExternalApp
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=ExternalApp,
    columns={'name': ExternalApp.name},
    default_sort='name',
)

external_app_search = SearchSystem(config)

----------------------------------------

File: feature_extension/__init__.py
Please review for update


----------------------------------------

File: feature_extension/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.feature_extension import FeatureExtension
from accent_dao.helpers.db_manager import Session
from accent_dao.resources.utils.search import SearchResult

from .database import (
    agent_action_converter,
    fwd_converter,
    service_converter,
)
from .persistor import FeatureExtensionPersistor


def persistor():
    return FeatureExtensionPersistor(Session)


def get_by(**criteria):
    return persistor().get_by(criteria)


def find_by(**criteria):
    return persistor().find_by(criteria)


def find_all_by(**criteria):
    return persistor().find_all_by(criteria)


def get(uuid):
    return persistor().get_by({'uuid': uuid})


def find(uuid):
    return persistor().find_by({'uuid': uuid})


def search(**parameters):
    total, items = persistor().search(parameters)
    return SearchResult(total, items)


def create(extension):
    return persistor().create(extension)


def edit(extension):
    persistor().edit(extension)


def delete(extension):
    persistor().delete(extension)


def find_all_service_extensions():
    features = service_converter.features()
    query = Session.query(
        FeatureExtension.uuid, FeatureExtension.exten, FeatureExtension.feature
    ).filter(FeatureExtension.feature.in_(features))

    return [service_converter.to_model(row) for row in query]


def find_all_forward_extensions():
    features = fwd_converter.features()
    query = Session.query(
        FeatureExtension.uuid, FeatureExtension.exten, FeatureExtension.feature
    ).filter(FeatureExtension.feature.in_(features))

    return [fwd_converter.to_model(row) for row in query]


def find_all_agent_action_extensions():
    features = agent_action_converter.features()
    query = Session.query(
        FeatureExtension.uuid, FeatureExtension.exten, FeatureExtension.feature
    ).filter(FeatureExtension.feature.in_(features))

    return [agent_action_converter.to_model(row) for row in query]

----------------------------------------

File: feature_extension/database.py
Please review for update

# Copyright 2023 Accent Communications

from __future__ import annotations
from typing import NamedTuple

from accent.accent_helpers import clean_extension


class ServiceFeatureExtension(NamedTuple):
    uuid: str
    exten: str
    service: str


class ForwardFeatureExtension(NamedTuple):
    uuid: str
    exten: str
    forward: str


class AgentActionFeatureExtension(NamedTuple):
    uuid: str
    exten: str
    action: str


class ServiceFeatureExtensionConverter:
    SERVICES = (
        "enablevm",
        "vmusermsg",
        "vmuserpurge",
        "phonestatus",
        "recsnd",
        "calllistening",
        "directoryaccess",
        "fwdundoall",
        "pickup",
        "callrecord",
        "incallfilter",
        "enablednd",
    )

    @classmethod
    def features(cls):
        return cls.SERVICES

    def to_model(self, row):
        exten = clean_extension(row.exten)
        return ServiceFeatureExtension(uuid=row.uuid, exten=exten, service=row.feature)


class ForwardFeatureExtensionConverter:
    FORWARDS = {'fwdbusy': 'busy', 'fwdrna': 'noanswer', 'fwdunc': 'unconditional'}

    FEATURES = {value: key for key, value in FORWARDS.items()}

    def features(self):
        return list(self.FORWARDS.keys())

    def to_feature(self, forward):
        return self.FEATURES[forward]

    def to_forward(self, feature):
        return self.FORWARDS[feature]

    def to_model(self, row):
        forward = self.FORWARDS[row.feature]
        exten = clean_extension(row.exten)
        return ForwardFeatureExtension(uuid=row.uuid, exten=exten, forward=forward)


class AgentActionFeatureExtensionConverter:
    ACTIONS = {
        'agentstaticlogin': 'login',
        'agentstaticlogoff': 'logout',
        'agentstaticlogtoggle': 'toggle',
    }

    FEATURES = {value: key for key, value in ACTIONS.items()}

    def features(self):
        return list(self.ACTIONS.keys())

    def to_feature(self, action):
        return self.FEATURES[action]

    def to_action(self, feature):
        return self.ACTIONS[feature]

    def to_model(self, row):
        action = self.ACTIONS[row.feature]
        exten = clean_extension(row.exten)
        return AgentActionFeatureExtension(uuid=row.uuid, exten=exten, action=action)


class GroupMemberActionFeatureExtensionConverter:
    ACTIONS = {
        'groupmemberjoin': 'join',
        'groupmemberleave': 'leave',
        'groupmembertoggle': 'toggle',
    }

    FEATURES = {value: key for key, value in ACTIONS.items()}

    def features(self):
        return list(self.ACTIONS.keys())

    def to_feature(self, action):
        return self.FEATURES[action]

    def to_action(self, feature):
        return self.ACTIONS[feature]

    def to_model(self, row):
        action = self.ACTIONS[row.feature]
        exten = clean_extension(row.exten)
        return AgentActionFeatureExtension(uuid=row.uuid, exten=exten, action=action)


agent_action_converter = AgentActionFeatureExtensionConverter()
fwd_converter = ForwardFeatureExtensionConverter()
group_member_action_converter = GroupMemberActionFeatureExtensionConverter()
service_converter = ServiceFeatureExtensionConverter()

----------------------------------------

File: feature_extension/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.feature_extension import FeatureExtension
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin
from accent_dao.resources.feature_extension.search import feature_extension_search


class FeatureExtensionPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = FeatureExtension

    def __init__(self, session):
        self.session = session
        self.tenant_uuids = None
        self.search_system = feature_extension_search

    def _find_query(self, criteria):
        query = self.session.query(FeatureExtension)
        query = self.build_criteria(query, criteria)
        return query

    def _search_query(self):
        return self.session.query(FeatureExtension)

    def create(self, extension):
        self.session.add(extension)
        self.session.flush()
        return extension

    def delete(self, extension):
        self.session.query(FeatureExtension).filter(
            FeatureExtension.uuid == extension.uuid
        ).delete()
        self.session.flush()

----------------------------------------

File: feature_extension/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.feature_extension import FeatureExtension
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=FeatureExtension,
    columns={'exten': FeatureExtension.exten, 'feature': FeatureExtension.feature},
    default_sort='exten',
)


feature_extension_search = SearchSystem(config)

----------------------------------------

File: features/__init__.py
Please review for update


----------------------------------------

File: features/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.features import Features
from accent_dao.helpers import errors
from accent_dao.helpers.db_manager import daosession

from .persistor import FeaturesPersistor


@daosession
def find_all(session, section):
    return FeaturesPersistor(session).find_all(section)


@daosession
def edit_all(session, section, features):
    FeaturesPersistor(session).edit_all(section, features)


@daosession
def get_value(session, feature_id):
    value = session.query(Features.var_val).filter(Features.id == feature_id).scalar()

    if not value:
        raise errors.not_found('Features', id=feature_id)

    value = _extract_applicationmap_dtmf(value)

    return value


def _extract_applicationmap_dtmf(value):
    return value.split(',', 1)[0]

----------------------------------------

File: features/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql.expression import and_, not_, or_

from accent_dao.alchemy.features import Features

from .search import (
    FUNC_KEY_APPLICATIONMAP_FOREIGN_KEY,
    FUNC_KEY_FEATUREMAP_FOREIGN_KEY,
)


class FeaturesPersistor:
    def __init__(self, session):
        self.session = session

    def find_all(self, section):
        query = (
            self.session.query(Features)
            .filter(Features.category == section)
            .filter(Features.var_val != None)  # noqa
            .order_by(Features.var_metric.asc())
        )

        return query.all()

    def edit_all(self, section, features):
        self._fill_default_values(section, features)
        self._delete_all_section(section)
        features = self._update_existing_foreign_key_features(features)
        self.session.add_all(features)
        self.session.flush()

    def _fill_default_values(self, section, features):
        for setting in features:
            setting.filename = 'features.conf'
            setting.category = section
        return features

    def _delete_all_section(self, section):
        query = self.session.query(Features).filter(Features.category == section)

        if section == 'featuremap':
            query = query.filter(
                not_(Features.var_name.in_(FUNC_KEY_FEATUREMAP_FOREIGN_KEY))
            )

        if section == 'applicationmap':
            query = query.filter(
                not_(Features.var_name.in_(FUNC_KEY_APPLICATIONMAP_FOREIGN_KEY))
            )

        query.delete(synchronize_session=False)

    def _update_existing_foreign_key_features(self, features):
        query = self.session.query(Features).filter(
            or_(
                and_(
                    Features.category == 'featuremap',
                    Features.var_name.in_(FUNC_KEY_FEATUREMAP_FOREIGN_KEY),
                ),
                and_(
                    Features.category == 'applicationmap',
                    Features.var_name.in_(FUNC_KEY_APPLICATIONMAP_FOREIGN_KEY),
                ),
            )
        )
        old_features = query.all()

        results = []
        for feature in features:
            results.append(feature)
            for old_feature in old_features:
                if (
                    old_feature.category == feature.category
                    and old_feature.var_name == feature.var_name
                ):
                    old_feature.var_val = feature.var_val
                    self._fix_commented(old_feature)
                    results.remove(feature)
        return results

    def _fix_commented(self, feature):
        feature.commented = 0
----------------------------------------

File: features/search.py
Please review for update

# Copyright 2023 Accent Communications

FUNC_KEY_FEATUREMAP_FOREIGN_KEY = ['blindxfer', 'atxfer']
FUNC_KEY_APPLICATIONMAP_FOREIGN_KEY = ['togglerecord']


----------------------------------------

File: func_key/__init__.py
Please review for update


----------------------------------------

File: func_key/dao.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import or_

from accent_dao.alchemy.feature_extension import FeatureExtension
from accent_dao.alchemy.func_key_dest_forward import FuncKeyDestForward
from accent_dao.alchemy.func_key_dest_user import FuncKeyDestUser
from accent_dao.alchemy.func_key_mapping import FuncKeyMapping
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.helpers.db_manager import daosession


@daosession
def find_all_forwards(session, user_id, fwd_type):
    type_converter = _ForwardTypeConverter()

    query = (
        session.query(FuncKeyDestForward.number.label('number'))
        .join(
            FeatureExtension,
            FuncKeyDestForward.feature_extension_uuid == FeatureExtension.uuid,
        )
        .join(
            FuncKeyMapping, FuncKeyMapping.func_key_id == FuncKeyDestForward.func_key_id
        )
        .join(
            UserFeatures,
            UserFeatures.func_key_private_template_id == FuncKeyMapping.template_id,
        )
        .filter(UserFeatures.id == user_id)
        .filter(FeatureExtension.feature == type_converter.model_to_db(fwd_type))
    )
    return query.all()


@daosession
def find_users_having_user_destination(session, destination_user):
    query = (
        session.query(UserFeatures)
        .join(
            FuncKeyMapping,
            or_(
                FuncKeyMapping.template_id == UserFeatures.func_key_private_template_id,
                FuncKeyMapping.template_id == UserFeatures.func_key_template_id,
            ),
        )
        .join(
            FuncKeyDestUser, FuncKeyMapping.func_key_id == FuncKeyDestUser.func_key_id
        )
        .filter(FuncKeyDestUser.user_id == str(destination_user.id))
    )
    return query.all()


class _ForwardTypeConverter:
    fwd_types = {
        'unconditional': 'fwdunc',
        'noanswer': 'fwdrna',
        'busy': 'fwdbusy',
    }

    reversed_types = {value: key for key, value in fwd_types.items()}

    def db_to_model(self, db_type):
        return self.reversed_types[db_type]

    def model_to_db(self, model_type):
        return self.fwd_types[model_type]
----------------------------------------

File: func_key/hint_dao.py
Please review for update

# Copyright 2023 Accent Communications
from collections import defaultdict

from accent.accent_helpers import clean_extension
from sqlalchemy import (
    Integer,
    Unicode,
    and_,
    bindparam,
    literal_column,
    sql,
)
from sqlalchemy.ext import baked
from sqlalchemy.orm import (
    aliased,
    joinedload,
)
from sqlalchemy.sql.expression import true

from accent_dao.alchemy.callfilter import Callfilter
from accent_dao.alchemy.callfiltermember import Callfiltermember
from accent_dao.alchemy.conference import Conference
from accent_dao.alchemy.endpoint_sip import EndpointSIP
from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.feature_extension import FeatureExtension
from accent_dao.alchemy.func_key_dest_agent import FuncKeyDestAgent
from accent_dao.alchemy.func_key_dest_bsfilter import FuncKeyDestBSFilter
from accent_dao.alchemy.func_key_dest_conference import FuncKeyDestConference
from accent_dao.alchemy.func_key_dest_custom import FuncKeyDestCustom
from accent_dao.alchemy.func_key_dest_forward import FuncKeyDestForward
from accent_dao.alchemy.func_key_dest_group_member import FuncKeyDestGroupMember
from accent_dao.alchemy.func_key_dest_service import FuncKeyDestService
from accent_dao.alchemy.func_key_mapping import FuncKeyMapping
from accent_dao.alchemy.line_extension import LineExtension
from accent_dao.alchemy.linefeatures import LineFeatures
from accent_dao.alchemy.sccpline import SCCPLine
from accent_dao.alchemy.user_line import UserLine
from accent_dao.alchemy.usercustom import UserCustom
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.helpers.db_manager import daosession
from accent_dao.resources.func_key.model import Hint

user_extension = aliased(Extension)

agent_hints_bakery = baked.bakery()
agent_hints_query = agent_hints_bakery(
    lambda s: s.query(
        sql.cast(FuncKeyDestAgent.agent_id, Unicode).label('argument'),
        UserFeatures.id.label('user_id'),
        FeatureExtension.exten.label('feature_extension'),
        user_extension.context,
    )
    .join(
        FeatureExtension,
        FeatureExtension.uuid == FuncKeyDestAgent.feature_extension_uuid,
    )
    .join(
        FuncKeyMapping,
        FuncKeyDestAgent.func_key_id == FuncKeyMapping.func_key_id,
    )
    .filter(
        FeatureExtension.enabled == true(),
    )
    .join(
        UserFeatures,
        FuncKeyMapping.template_id == UserFeatures.func_key_private_template_id,
    )
    .join(
        UserLine,
        UserFeatures.id == UserLine.user_id,
    )
    .join(
        LineExtension,
        LineExtension.line_id == UserLine.line_id,
    )
    .join(
        user_extension,
        LineExtension.extension_id == user_extension.id,
    )
    .filter(
        and_(
            UserLine.main_user.is_(True),
            UserLine.main_line.is_(True),
            LineExtension.main_extension.is_(True),
            FuncKeyMapping.blf.is_(True),
        )
    )
)

bsfilter_hints_bakery = baked.bakery()
bsfilter_hints_query = bsfilter_hints_bakery(
    lambda s: s.query(
        sql.cast(FuncKeyDestBSFilter.filtermember_id, Unicode).label('argument'),
        Extension.context,
    )
    .join(
        Callfiltermember,
        Callfiltermember.id == FuncKeyDestBSFilter.filtermember_id,
    )
    .join(
        Callfilter,
        Callfilter.id == Callfiltermember.callfilterid,
    )
    .join(
        UserFeatures,
        sql.cast(Callfiltermember.typeval, Integer) == UserFeatures.id,
    )
    .join(
        UserLine,
        UserLine.user_id == UserFeatures.id,
    )
    .join(
        LineExtension,
        UserLine.line_id == LineExtension.line_id,
    )
    .join(
        Extension,
        Extension.id == LineExtension.extension_id,
    )
    .filter(
        and_(
            UserLine.main_user.is_(True),
            UserLine.main_line.is_(True),
            LineExtension.main_extension.is_(True),
            Extension.commented == 0,
            Callfilter.commented == 0,
        )
    )
)


conference_hints_bakery = baked.bakery()
conference_hints_query = conference_hints_bakery(
    lambda s: s.query(
        Conference.id.label('conference_id'),
        Extension.exten.label('extension'),
        Extension.context,
    )
    .select_from(Conference)
    .join(FuncKeyDestConference, FuncKeyDestConference.conference_id == Conference.id)
    .join(
        Extension,
        sql.and_(
            Extension.type == 'conference',
            Extension.typeval == sql.cast(Conference.id, Unicode),
        ),
    )
)

custom_hints_bakery = baked.bakery()
custom_hints_query = custom_hints_bakery(
    lambda s: s.query(
        FuncKeyDestCustom.exten.label('extension'), user_extension.context
    )
    .join(
        FuncKeyMapping,
        FuncKeyDestCustom.func_key_id == FuncKeyMapping.func_key_id,
    )
    .join(
        UserFeatures,
        FuncKeyMapping.template_id == UserFeatures.func_key_private_template_id,
    )
    .join(
        UserLine,
        UserFeatures.id == UserLine.user_id,
    )
    .join(
        LineExtension,
        LineExtension.line_id == UserLine.line_id,
    )
    .join(
        user_extension,
        LineExtension.extension_id == user_extension.id,
    )
    .filter(
        and_(
            UserLine.main_user.is_(True),
            UserLine.main_line.is_(True),
            LineExtension.main_extension.is_(True),
            FuncKeyMapping.blf.is_(True),
        )
    )
)

forwards_hints_bakery = baked.bakery()
forwards_hints_query = forwards_hints_bakery(
    lambda s: s.query(
        FeatureExtension.exten.label('feature_extension'),
        UserFeatures.id.label('user_id'),
        FuncKeyDestForward.number.label('argument'),
        user_extension.context,
    )
    .join(
        FuncKeyDestForward,
        FuncKeyDestForward.feature_extension_uuid == FeatureExtension.uuid,
    )
    .join(
        FuncKeyMapping,
        FuncKeyDestForward.func_key_id == FuncKeyMapping.func_key_id,
    )
    .filter(FeatureExtension.enabled == true())
    .join(
        UserFeatures,
        FuncKeyMapping.template_id == UserFeatures.func_key_private_template_id,
    )
    .join(
        UserLine,
        UserFeatures.id == UserLine.user_id,
    )
    .join(
        LineExtension,
        LineExtension.line_id == UserLine.line_id,
    )
    .join(
        user_extension,
        LineExtension.extension_id == user_extension.id,
    )
    .filter(
        and_(
            UserLine.main_user.is_(True),
            UserLine.main_line.is_(True),
            LineExtension.main_extension.is_(True),
            FuncKeyMapping.blf.is_(True),
        )
    )
)

groupmember_hints_bakery = baked.bakery()
groupmember_hints_query = groupmember_hints_bakery(
    lambda s: s.query(
        sql.cast(FuncKeyDestGroupMember.group_id, Unicode).label('argument'),
        UserFeatures.id.label('user_id'),
        FeatureExtension.exten.label('feature_extension'),
        user_extension.context,
    )
    .join(
        FeatureExtension,
        FeatureExtension.uuid == FuncKeyDestGroupMember.feature_extension_uuid,
    )
    .join(
        FuncKeyMapping,
        FuncKeyDestGroupMember.func_key_id == FuncKeyMapping.func_key_id,
    )
    .filter(
        FeatureExtension.enabled == true(),
    )
    .join(
        UserFeatures,
        FuncKeyMapping.template_id == UserFeatures.func_key_private_template_id,
    )
    .join(
        UserLine,
        UserFeatures.id == UserLine.user_id,
    )
    .join(
        LineExtension,
        LineExtension.line_id == UserLine.line_id,
    )
    .join(
        user_extension,
        LineExtension.extension_id == user_extension.id,
    )
    .filter(
        and_(
            UserLine.main_user.is_(True),
            UserLine.main_line.is_(True),
            LineExtension.main_extension.is_(True),
            FuncKeyMapping.blf.is_(True),
        )
    )
)

user_extensions_bakery = baked.bakery()
user_extensions_query = user_extensions_bakery(
    lambda s: s.query(
        UserFeatures.id.label('user_id'),
        Extension.exten.label('extension'),
        Extension.context,
    )
    .distinct()
    .join(
        UserLine.userfeatures,
    )
    .join(
        LineExtension,
        UserLine.line_id == LineExtension.line_id,
    )
    .join(
        Extension,
        LineExtension.extension_id == Extension.id,
    )
    .filter(
        and_(
            UserLine.main_user.is_(True),
            LineExtension.main_extension.is_(True),
            UserFeatures.enablehint == 1,
        )
    )
)

user_arguments_bakery = baked.bakery()
user_arguments_query = user_arguments_bakery(
    lambda s: s.query(
        UserFeatures.id.label('user_id'),
        sql.func.string_agg(
            sql.case(
                [
                    (
                        LineFeatures.endpoint_sip_uuid.isnot(None),
                        literal_column("'PJSIP/'") + EndpointSIP.name,
                    ),
                    (
                        LineFeatures.endpoint_sccp_id.isnot(None),
                        literal_column("'SCCP/'") + SCCPLine.name,
                    ),
                    (
                        LineFeatures.endpoint_custom_id.isnot(None),
                        UserCustom.interface,
                    ),
                ]
            ),
            literal_column("'&'"),
        ).label('argument'),
    )
    .join(
        UserLine.userfeatures,
    )
    .join(
        UserLine.linefeatures,
    )
    .outerjoin(
        EndpointSIP,
    )
    .outerjoin(
        SCCPLine,
    )
    .outerjoin(
        UserCustom,
    )
    .filter(
        and_(
            UserLine.main_user.is_(True),
            LineFeatures.commented == 0,
        )
    )
    .group_by(UserFeatures.id)
)
user_arguments_query += lambda q: q.filter(
    UserFeatures.id.in_(bindparam('user_ids', expanding=True))
)

service_hints_bakery = baked.bakery()
service_hints_query = service_hints_bakery(
    lambda s: s.query(
        FeatureExtension.exten.label('feature_extension'),
        UserFeatures.id.label('user_id'),
        user_extension.context,
    )
    .join(
        FuncKeyDestService,
        FuncKeyDestService.feature_extension_uuid == FeatureExtension.uuid,
    )
    .join(
        FuncKeyMapping,
        FuncKeyDestService.func_key_id == FuncKeyMapping.func_key_id,
    )
    .filter(FeatureExtension.enabled == true())
    .join(
        UserFeatures,
        FuncKeyMapping.template_id == UserFeatures.func_key_private_template_id,
    )
    .join(
        UserLine,
        UserFeatures.id == UserLine.user_id,
    )
    .join(
        LineExtension,
        LineExtension.line_id == UserLine.line_id,
    )
    .join(
        user_extension,
        LineExtension.extension_id == user_extension.id,
    )
    .filter(
        and_(
            UserLine.main_user.is_(True),
            UserLine.main_line.is_(True),
            LineExtension.main_extension.is_(True),
            FuncKeyMapping.blf.is_(True),
        )
    )
)

extenfeatures_bakery = baked.bakery()
extenfeatures_query = extenfeatures_bakery(lambda s: s.query(FeatureExtension.exten))
extenfeatures_query += lambda q: q.filter(
    FeatureExtension.feature == bindparam('feature')
)


def _find_extenfeatures(session, feature):
    return extenfeatures_query(session).params(feature=feature).scalar()


@daosession
def progfunckey_extension(session):
    extension = _find_extenfeatures(session, 'phoneprogfunckey')
    return clean_extension(extension)


@daosession
def calluser_extension(session):
    extension = _find_extenfeatures(session, 'calluser')
    return clean_extension(extension)


@daosession
def user_hints(session):
    user_extensions = _list_user_extensions(session)
    if not user_extensions:
        return {}

    user_arguments = _list_user_arguments(
        session, {item.user_id for item in user_extensions}
    )
    hints = defaultdict(list)
    for user_id, extension, context in user_extensions:
        argument = user_arguments.get(user_id)
        if argument:
            hints[context].append(
                Hint(user_id=user_id, extension=extension, argument=argument)
            )
    return hints


@daosession
def user_shared_hints(session):
    query = session.query(UserFeatures).options(
        joinedload('user_lines').joinedload('line')
    )
    hints = []
    for user in query.all():
        ifaces = [f'Custom:{user.uuid}-mobile']
        for line in user.lines:
            if line.endpoint_custom_id:
                ifaces.append(line.name)
            elif line.endpoint_sip_uuid:
                ifaces.append(f'PJSIP/{line.name}')
            elif line.endpoint_sccp_id:
                ifaces.append(f'SCCP/{line.name}')
            else:
                ifaces.append(f'CUSTOM/{line.name}')

        if not ifaces:
            continue
        argument = '&'.join(ifaces)
        hint = Hint(user_id=user.id, extension=user.uuid, argument=argument)
        hints.append(hint)
    return hints


def _list_user_extensions(session):
    return user_extensions_query(session).all()


def _list_user_arguments(session, user_ids):
    query = user_arguments_query(session).params(user_ids=list(user_ids)).all()
    return {row.user_id: row.argument for row in query}


@daosession
def conference_hints(session):
    query = conference_hints_query(session).all()
    hints = defaultdict(list)
    for row in query:
        hint = Hint(conference_id=row.conference_id, extension=row.extension)
        hints[row.context].append(hint)
    return hints


@daosession
def service_hints(session):
    query = service_hints_query(session).all()
    hints = defaultdict(list)
    for row in query:
        hint = Hint(user_id=row.user_id, extension=row.feature_extension, argument=None)
        hints[row.context].append(hint)
    return hints


@daosession
def forward_hints(session):
    query = forwards_hints_query(session).all()
    hints = defaultdict(list)
    for row in query:
        hint = Hint(
            user_id=row.user_id,
            extension=clean_extension(row.feature_extension),
            argument=row.argument,
        )
        hints[row.context].append(hint)

    return hints


@daosession
def agent_hints(session):
    query = agent_hints_query(session).all()
    hints = defaultdict(list)
    for row in query:
        hint = Hint(
            user_id=row.user_id,
            extension=clean_extension(row.feature_extension),
            argument=row.argument,
        )
        hints[row.context].append(hint)
    return hints


@daosession
def custom_hints(session):
    query = custom_hints_query(session).all()
    hints = defaultdict(list)
    for row in query:
        hint = Hint(extension=row.extension)
        hints[row.context].append(hint)
    return hints


@daosession
def bsfilter_hints(session):
    bsfilter_extension = clean_extension(_find_extenfeatures(session, 'bsfilter'))
    query = bsfilter_hints_query(session).all()
    hints = defaultdict(list)
    for row in query:
        hint = Hint(extension=bsfilter_extension, argument=row.argument)
        hints[row.context].append(hint)
    return hints


@daosession
def groupmember_hints(session):
    query = groupmember_hints_query(session).all()
    hints = defaultdict(list)
    for row in query:
        hint = Hint(
            user_id=row.user_id,
            extension=clean_extension(row.feature_extension),
            argument=row.argument,
        )
        hints[row.context].append(hint)
    return hints

----------------------------------------

File: func_key/model.py
Please review for update

# Copyright 2023 Accent Communications


class Hint:
    __slots__ = ['user_id', 'conference_id', 'extension', 'argument']

    def __init__(self, user_id=None, conference_id=None, extension=None, argument=None):
        self.user_id = user_id
        self.conference_id = conference_id
        self.extension = extension
        self.argument = argument

    def __eq__(self, other):
        return (
            self.user_id == other.user_id
            and self.conference_id == other.conference_id
            and self.extension == other.extension
            and self.argument == other.argument
        )

    def __ne__(self, other):
        return not self == other

    def __repr__(self):
        return f'Hint(user_id={self.user_id}, conference_id={self.conference_id}, extension={self.extension}, argument={self.argument})'

----------------------------------------

File: func_key/type_dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.func_key_destination_type import (
    FuncKeyDestinationType as FuncKeyDestinationTypeSchema,
)
from accent_dao.alchemy.func_key_type import FuncKeyType as FuncKeyTypeSchema
from accent_dao.helpers.db_manager import daosession


@daosession
def find_type_for_name(session, name):
    return _find_using_name(session, FuncKeyTypeSchema, name)


@daosession
def find_destination_type_for_name(session, name):
    return _find_using_name(session, FuncKeyDestinationTypeSchema, name)


def _find_using_name(session, schema, name):
    return session.query(schema).filter(schema.name == name).first()

----------------------------------------

File: func_key_template/__init__.py
Please review for update


----------------------------------------

File: func_key_template/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession
from accent_dao.helpers.db_utils import flush_session

from accent_dao.resources.func_key_template.persistor import build_persistor


@daosession
def search(session, tenant_uuids=None, **parameters):
    persistor = build_persistor(session, tenant_uuids=tenant_uuids)
    return persistor.search(parameters)


@daosession
def create(session, template):
    persistor = build_persistor(session)
    with flush_session(session):
        return persistor.create(template)


@daosession
def get(session, template_id, tenant_uuids=None):
    persistor = build_persistor(session, tenant_uuids=tenant_uuids)
    return persistor.get(template_id)


@daosession
def edit(session, template):
    persistor = build_persistor(session)
    with flush_session(session):
        return persistor.edit(template)


@daosession
def delete(session, template):
    persistor = build_persistor(session)
    return persistor.delete(template)

----------------------------------------

File: func_key_template/persistor.py
Please review for update

# Copyright 2023 Accent Communications

import abc

from sqlalchemy import text

from accent_dao.alchemy.features import Features
from accent_dao.alchemy.func_key import FuncKey
from accent_dao.alchemy.func_key_dest_agent import FuncKeyDestAgent
from accent_dao.alchemy.func_key_dest_bsfilter import FuncKeyDestBSFilter
from accent_dao.alchemy.func_key_dest_conference import FuncKeyDestConference
from accent_dao.alchemy.func_key_dest_custom import FuncKeyDestCustom
from accent_dao.alchemy.func_key_dest_features import (
    FuncKeyDestFeatures,
    FuncKeyDestOnlineRecording,
    FuncKeyDestTransfer,
)
from accent_dao.alchemy.func_key_dest_forward import FuncKeyDestForward
from accent_dao.alchemy.func_key_dest_group import FuncKeyDestGroup
from accent_dao.alchemy.func_key_dest_group_member import FuncKeyDestGroupMember
from accent_dao.alchemy.func_key_dest_paging import FuncKeyDestPaging
from accent_dao.alchemy.func_key_dest_park_position import FuncKeyDestParkPosition
from accent_dao.alchemy.func_key_dest_parking import FuncKeyDestParking
from accent_dao.alchemy.func_key_dest_queue import FuncKeyDestQueue
from accent_dao.alchemy.func_key_dest_service import FuncKeyDestService
from accent_dao.alchemy.func_key_dest_user import FuncKeyDestUser
from accent_dao.alchemy.func_key_mapping import FuncKeyMapping
from accent_dao.alchemy.func_key_template import FuncKeyTemplate
from accent_dao.helpers import errors
from accent_dao.resources.extension.database import (
    AgentActionExtensionConverter,
    ForwardExtensionConverter,
    GroupMemberActionExtensionConverter,
)
from accent_dao.resources.utils.search import SearchResult

from ...alchemy.feature_extension import FeatureExtension
from .search import template_search


def build_persistor(session, tenant_uuids=None):
    destination_persistors = {
        'agent': AgentPersistor,
        'bsfilter': BSFilterPersistor,
        'conference': ConferencePersistor,
        'custom': CustomPersistor,
        'features': FeaturesPersistor,
        'forward': ForwardPersistor,
        'group': GroupPersistor,
        'groupmember': GroupMemberPersistor,
        'onlinerec': FeaturesPersistor,
        'paging': PagingPersistor,
        'park_position': ParkPositionPersistor,
        'parking': ParkingPersistor,
        'queue': QueuePersistor,
        'service': ServicePersistor,
        'transfer': FeaturesPersistor,
        'user': UserPersistor,
    }

    return FuncKeyPersistor(
        session,
        destination_persistors,
        template_search,
        tenant_uuids=tenant_uuids,
    )


class FuncKeyPersistor:
    def __init__(self, session, persistors, template_search, tenant_uuids=None):
        self.persistors = persistors
        self.session = session
        self.template_search = template_search
        self.tenant_uuids = tenant_uuids

    def search(self, parameters):
        query = self.session.query(FuncKeyTemplate.id)
        query = self._filter_tenant_uuid(query)
        rows, total = self.template_search.search_from_query(query, parameters)

        items = [self.get(row.id) for row in rows]
        return SearchResult(total=total, items=items)

    def create(self, template):
        template = self.add_template(template)
        funckeys = self.add_funckeys(template.id, template.keys)
        template.keys = funckeys
        return template

    def add_template(self, template):
        self.session.add(template)
        self.session.flush()
        return template

    def add_funckeys(self, template_id, funckeys):
        created_funckeys = {}
        for pos, funckey in funckeys.items():
            created_funckeys[pos] = self.add_mapping(template_id, pos, funckey)
        return created_funckeys

    def add_mapping(self, template_id, position, funckey):
        destination_row = self.find_or_create_destination(funckey.destination)
        mapping = FuncKeyMapping(
            template_id=template_id,
            func_key_id=destination_row.func_key_id,
            destination_type_id=destination_row.destination_type_id,
            position=position,
            label=funckey.label,
            blf=funckey.blf,
        )

        self.session.add(mapping)
        self.session.flush()
        mapping.destination = funckey.destination
        return mapping

    def find_or_create_destination(self, destination):
        persistor = self.build_persistor(destination.type)
        destination_row = persistor.find_or_create(destination)

        if not destination_row:
            raise errors.param_not_found(
                'destination',
                'func key representing destination',
                type=destination.type,
            )
        return destination_row

    def build_persistor(self, dest_type):
        persistor_cls = self.persistors[dest_type]
        return persistor_cls(self.session)

    def get(self, template_id):
        template = self.get_template_row(template_id)
        template.keys = self.get_keys_for_template(template_id)
        return template

    def get_template_row(self, template_id):
        query = self.session.query(FuncKeyTemplate)
        query = query.filter(FuncKeyTemplate.id == template_id)
        query = self._filter_tenant_uuid(query)
        template = query.first()
        if not template:
            raise errors.not_found('FuncKeyTemplate', id=template_id)
        return template

    def get_keys_for_template(self, template_id):
        keys = {}
        for row in self.query_mappings(template_id):
            row.destination = self.build_destination(
                row.func_key_id, row.destination_type_name
            )
            keys[row.position] = row
        return keys

    def _filter_tenant_uuid(self, query):
        if self.tenant_uuids is None:
            return query

        if not self.tenant_uuids:
            return query.filter(text('false'))

        return query.filter(FuncKeyTemplate.tenant_uuid.in_(self.tenant_uuids))

    def query_mappings(self, template_id):
        query = self.session.query(FuncKeyMapping).filter(
            FuncKeyMapping.template_id == template_id
        )

        return query.all()

    def build_destination(self, func_key_id, dest_type):
        persistor = self.build_persistor(dest_type)
        return persistor.get(func_key_id)

    def delete(self, template):
        self.remove_funckeys(template)
        self.delete_template(template)
        self.session.flush()

    def remove_funckeys(self, template):
        for row in self.query_mappings(template.id):
            self.delete_mapping(row)
            self.delete_destination(row)

    def delete_mapping(self, mapping_row):
        (
            self.session.query(FuncKeyMapping)
            .filter(FuncKeyMapping.template_id == mapping_row.template_id)
            .filter(FuncKeyMapping.func_key_id == mapping_row.func_key_id)
            .filter(FuncKeyMapping.position == mapping_row.position)
            .delete()
        )

    def delete_destination(self, row):
        persistor = self.build_persistor(row.destination_type_name)
        persistor.delete(row.func_key_id)

    def delete_template(self, template):
        (
            self.session.query(FuncKeyTemplate)
            .filter(FuncKeyTemplate.id == template.id)
            .delete()
        )

    def edit(self, template):
        self.update_template(template)
        self.update_funckeys(template)

    def update_template(self, template):
        template_row = self.get_template_row(template.id)
        template_row.name = template.name
        self.session.add(template_row)

    def update_funckeys(self, template):
        self.remove_funckeys(template)
        self.add_funckeys(template.id, template.keys)


class DestinationPersistor(metaclass=abc.ABCMeta):
    def __init__(self, session):
        self.session = session

    @abc.abstractmethod
    def get(self, func_key_id):
        return

    @abc.abstractmethod
    def find_or_create(self, destination):
        return

    @abc.abstractmethod
    def delete(self, func_key_id):
        return

    def create_func_key(self, type_id, destination_type_id):
        func_key_row = FuncKey(type_id=type_id, destination_type_id=destination_type_id)
        self.session.add(func_key_row)
        self.session.flush()
        return func_key_row

    def _func_key_is_still_mapped(self, func_key_id):
        return (
            self.session.query(FuncKeyMapping)
            .filter(FuncKeyMapping.func_key_id == func_key_id)
            .first()
        )


class UserPersistor(DestinationPersistor):
    TYPE_ID = 1
    DESTINATION_TYPE_ID = 1

    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestUser).filter(
            FuncKeyDestUser.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        destination_row = (
            self.session.query(FuncKeyDestUser)
            .filter(FuncKeyDestUser.user_id == destination.user_id)
            .first()
        )

        if not destination_row:
            func_key_row = self.create_func_key(self.TYPE_ID, self.DESTINATION_TYPE_ID)
            destination_row = FuncKeyDestUser(
                func_key_id=func_key_row.id, user_id=destination.user_id
            )
            self.session.add(destination_row)
            self.session.flush()

        return destination_row

    def delete(self, func_key_id):
        if not self._func_key_is_still_mapped(func_key_id):
            (
                self.session.query(FuncKeyDestUser)
                .filter(FuncKeyDestUser.func_key_id == func_key_id)
                .delete()
            )


class QueuePersistor(DestinationPersistor):
    TYPE_ID = 1
    DESTINATION_TYPE_ID = 3

    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestQueue).filter(
            FuncKeyDestQueue.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        destination_row = (
            self.session.query(FuncKeyDestQueue)
            .filter(FuncKeyDestQueue.queue_id == destination.queue_id)
            .first()
        )

        if not destination_row:
            func_key_row = self.create_func_key(self.TYPE_ID, self.DESTINATION_TYPE_ID)
            destination_row = FuncKeyDestQueue(
                func_key_id=func_key_row.id, queue_id=destination.queue_id
            )
            self.session.add(destination_row)
            self.session.flush()

        return destination_row

    def delete(self, func_key_id):
        if not self._func_key_is_still_mapped(func_key_id):
            (
                self.session.query(FuncKeyDestQueue)
                .filter(FuncKeyDestQueue.func_key_id == func_key_id)
                .delete()
            )


class GroupPersistor(DestinationPersistor):
    TYPE_ID = 1
    DESTINATION_TYPE_ID = 2

    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestGroup).filter(
            FuncKeyDestGroup.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        destination_row = (
            self.session.query(FuncKeyDestGroup)
            .filter(FuncKeyDestGroup.group_id == destination.group_id)
            .first()
        )

        if not destination_row:
            func_key_row = self.create_func_key(self.TYPE_ID, self.DESTINATION_TYPE_ID)
            destination_row = FuncKeyDestGroup(
                func_key_id=func_key_row.id, group_id=destination.group_id
            )
            self.session.add(destination_row)
            self.session.flush()

        return destination_row

    def delete(self, func_key_id):
        if not self._func_key_is_still_mapped(func_key_id):
            (
                self.session.query(FuncKeyDestGroup)
                .filter(FuncKeyDestGroup.func_key_id == func_key_id)
                .delete()
            )


class GroupMemberPersistor(DestinationPersistor):
    TYPE_ID = 1
    DESTINATION_TYPE_ID = 13

    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestGroupMember).filter(
            FuncKeyDestGroupMember.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        typeval = self.find_typeval(destination.action)

        destination_row = (
            self.session.query(FuncKeyDestGroupMember)
            .join(
                FeatureExtension,
                FuncKeyDestGroupMember.feature_extension_uuid == FeatureExtension.uuid,
            )
            .filter(FuncKeyDestGroupMember.group_id == destination.group_id)
            .filter(FeatureExtension.feature == typeval)
            .first()
        )
        if not destination_row:
            feature_extension = (
                self.session.query(FeatureExtension)
                .filter(FeatureExtension.feature == typeval)
                .first()
            )

            func_key_row = self.create_func_key(self.TYPE_ID, self.DESTINATION_TYPE_ID)
            destination_row = FuncKeyDestGroupMember(
                func_key_id=func_key_row.id,
                group_id=destination.group_id,
                feature_extension_uuid=feature_extension.uuid,
            )
            self.session.add(destination_row)
            self.session.flush()

        return destination_row

    def find_typeval(self, action):
        return GroupMemberActionExtensionConverter().to_typeval(action)

    def delete(self, func_key_id):
        if not self._func_key_is_still_mapped(func_key_id):
            (
                self.session.query(FuncKeyDestGroupMember)
                .filter(FuncKeyDestGroupMember.func_key_id == func_key_id)
                .delete()
            )


class ConferencePersistor(DestinationPersistor):
    TYPE_ID = 1
    DESTINATION_TYPE_ID = 4

    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestConference).filter(
            FuncKeyDestConference.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        destination_row = (
            self.session.query(FuncKeyDestConference)
            .filter(FuncKeyDestConference.conference_id == destination.conference_id)
            .first()
        )

        if not destination_row:
            func_key_row = self.create_func_key(self.TYPE_ID, self.DESTINATION_TYPE_ID)
            destination_row = FuncKeyDestConference(
                func_key_id=func_key_row.id, conference_id=destination.conference_id
            )
            self.session.add(destination_row)
            self.session.flush()

        return destination_row

    def delete(self, func_key_id):
        if not self._func_key_is_still_mapped(func_key_id):
            (
                self.session.query(FuncKeyDestConference)
                .filter(FuncKeyDestConference.func_key_id == func_key_id)
                .delete()
            )


class PagingPersistor(DestinationPersistor):
    TYPE_ID = 1
    DESTINATION_TYPE_ID = 9

    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestPaging).filter(
            FuncKeyDestPaging.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        destination_row = (
            self.session.query(FuncKeyDestPaging)
            .filter(FuncKeyDestPaging.paging_id == destination.paging_id)
            .first()
        )

        if not destination_row:
            func_key_row = self.create_func_key(self.TYPE_ID, self.DESTINATION_TYPE_ID)
            destination_row = FuncKeyDestPaging(
                func_key_id=func_key_row.id, paging_id=destination.paging_id
            )
            self.session.add(destination_row)
            self.session.flush()

        return destination_row

    def delete(self, func_key_id):
        if not self._func_key_is_still_mapped(func_key_id):
            (
                self.session.query(FuncKeyDestPaging)
                .filter(FuncKeyDestPaging.func_key_id == func_key_id)
                .delete()
            )


class BSFilterPersistor(DestinationPersistor):
    TYPE_ID = 1
    DESTINATION_TYPE_ID = 12

    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestBSFilter).filter(
            FuncKeyDestBSFilter.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        destination_row = (
            self.session.query(FuncKeyDestBSFilter)
            .filter(FuncKeyDestBSFilter.filtermember_id == destination.filter_member_id)
            .first()
        )

        if not destination_row:
            func_key_row = self.create_func_key(self.TYPE_ID, self.DESTINATION_TYPE_ID)
            destination_row = FuncKeyDestBSFilter(
                func_key_id=func_key_row.id,
                filter_member_id=destination.filter_member_id,
            )
            self.session.add(destination_row)
            self.session.flush()

        return destination_row

    def delete(self, func_key_id):
        if not self._func_key_is_still_mapped(func_key_id):
            (
                self.session.query(FuncKeyDestBSFilter)
                .filter(FuncKeyDestBSFilter.func_key_id == func_key_id)
                .delete()
            )


class ServicePersistor(DestinationPersistor):
    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestService).filter(
            FuncKeyDestService.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        query = (
            self.session.query(FuncKeyDestService)
            .join(
                FeatureExtension,
                FuncKeyDestService.feature_extension_uuid == FeatureExtension.uuid,
            )
            .filter(FeatureExtension.feature == destination.service)
        )
        # NOTE: Already created by populate.sql

        return query.first()

    def delete(self, func_key_id):
        pass


class ForwardPersistor(DestinationPersistor):
    TYPE_ID = 1
    DESTINATION_TYPE_ID = 6

    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestForward).filter(
            FuncKeyDestForward.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        func_key_row = self.create_func_key(self.TYPE_ID, self.DESTINATION_TYPE_ID)
        feature_extension_uuid = self.find_extension_id(destination.forward)

        destination_row = FuncKeyDestForward(
            func_key_id=func_key_row.id,
            feature_extension_uuid=feature_extension_uuid,
            number=destination.exten,
        )
        self.session.add(destination_row)
        self.session.flush()

        return destination_row

    def find_extension_id(self, forward):
        typeval = ForwardExtensionConverter().to_typeval(forward)

        query = self.session.query(FeatureExtension.uuid).filter(
            FeatureExtension.feature == typeval
        )

        return query.scalar()

    def delete(self, func_key_id):
        (
            self.session.query(FuncKeyDestForward)
            .filter(FuncKeyDestForward.func_key_id == func_key_id)
            .delete()
        )


class ParkPositionPersistor(DestinationPersistor):
    TYPE_ID = 1
    DESTINATION_TYPE_ID = 7

    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestParkPosition).filter(
            FuncKeyDestParkPosition.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        destination_row = (
            self.session.query(FuncKeyDestParkPosition)
            .filter(
                FuncKeyDestParkPosition.parking_lot_id == destination.parking_lot_id
            )
            .filter(FuncKeyDestParkPosition.position == str(destination.position))
            .first()
        )

        if not destination_row:
            func_key_row = self.create_func_key(self.TYPE_ID, self.DESTINATION_TYPE_ID)
            destination_row = FuncKeyDestParkPosition(
                func_key_id=func_key_row.id,
                parking_lot_id=destination.parking_lot_id,
                position=str(destination.position),
            )
            self.session.add(destination_row)
            self.session.flush()

        return destination_row

    def delete(self, func_key_id):
        if not self._func_key_is_still_mapped(func_key_id):
            (
                self.session.query(FuncKeyDestParkPosition)
                .filter(FuncKeyDestParkPosition.func_key_id == func_key_id)
                .delete()
            )


class ParkingPersistor(DestinationPersistor):
    TYPE_ID = 1
    DESTINATION_TYPE_ID = 14

    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestParking).filter(
            FuncKeyDestParking.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        destination_row = (
            self.session.query(FuncKeyDestParking)
            .filter(FuncKeyDestParking.parking_lot_id == destination.parking_lot_id)
            .first()
        )

        if not destination_row:
            func_key_row = self.create_func_key(self.TYPE_ID, self.DESTINATION_TYPE_ID)
            destination_row = FuncKeyDestParking(
                func_key_id=func_key_row.id,
                parking_lot_id=destination.parking_lot_id,
            )
            self.session.add(destination_row)
            self.session.flush()

        return destination_row

    def delete(self, func_key_id):
        if not self._func_key_is_still_mapped(func_key_id):
            (
                self.session.query(FuncKeyDestParking)
                .filter(FuncKeyDestParking.func_key_id == func_key_id)
                .delete()
            )


class CustomPersistor(DestinationPersistor):
    TYPE_ID = 1
    DESTINATION_TYPE_ID = 10

    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestCustom).filter(
            FuncKeyDestCustom.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        func_key_row = self.create_func_key(self.TYPE_ID, self.DESTINATION_TYPE_ID)

        destination_row = FuncKeyDestCustom(
            func_key_id=func_key_row.id, exten=destination.exten
        )

        self.session.add(destination_row)
        self.session.flush()

        return destination_row

    def delete(self, func_key_id):
        (
            self.session.query(FuncKeyDestCustom)
            .filter(FuncKeyDestCustom.func_key_id == func_key_id)
            .delete()
        )


class AgentPersistor(DestinationPersistor):
    TYPE_ID = 1
    DESTINATION_TYPE_ID = 11

    def get(self, func_key_id):
        query = self.session.query(FuncKeyDestAgent).filter(
            FuncKeyDestAgent.func_key_id == func_key_id
        )

        return query.first()

    def find_or_create(self, destination):
        typeval = self.find_typeval(destination.action)

        destination_row = (
            self.session.query(FuncKeyDestAgent)
            .join(
                FeatureExtension,
                FuncKeyDestAgent.feature_extension_uuid == FeatureExtension.uuid,
            )
            .filter(FuncKeyDestAgent.agent_id == destination.agent_id)
            .filter(FeatureExtension.feature == typeval)
            .first()
        )
        if not destination_row:
            feature_extension = (
                self.session.query(FeatureExtension)
                .filter(FeatureExtension.feature == typeval)
                .first()
            )

            func_key_row = self.create_func_key(self.TYPE_ID, self.DESTINATION_TYPE_ID)
            destination_row = FuncKeyDestAgent(
                func_key_id=func_key_row.id,
                agent_id=destination.agent_id,
                feature_extension_uuid=feature_extension.uuid,
            )
            self.session.add(destination_row)
            self.session.flush()

        return destination_row

    def find_typeval(self, action):
        return AgentActionExtensionConverter().to_typeval(action)

    def delete(self, func_key_id):
        if not self._func_key_is_still_mapped(func_key_id):
            (
                self.session.query(FuncKeyDestAgent)
                .filter(FuncKeyDestAgent.func_key_id == func_key_id)
                .delete()
            )


class FeaturesPersistor(DestinationPersistor):
    TRANSFERS_TO_API = {'blindxfer': 'blind', 'atxfer': 'attended'}

    TRANSFERS_TO_DB = {'blind': 'blindxfer', 'attended': 'atxfer'}

    def get(self, func_key_id):
        query = (
            self.session.query(FuncKeyDestFeatures, Features.var_name, Features.id)
            .join(Features, FuncKeyDestFeatures.features_id == Features.id)
            .filter(FuncKeyDestFeatures.func_key_id == func_key_id)
        )

        result = query.first()

        if result.var_name == 'togglerecord':
            return FuncKeyDestOnlineRecording(feature_id=result.id)

        transfer = self.TRANSFERS_TO_API[result.var_name]
        return FuncKeyDestTransfer(feature_id=result.id, transfer=transfer)

    def find_or_create(self, destination):
        varname = self.find_var_name(destination)

        query = (
            self.session.query(FuncKeyDestFeatures)
            .join(Features, FuncKeyDestFeatures.features_id == Features.id)
            .filter(Features.var_name == varname)
        )
        # NOTE: Already created by populate.sql

        return query.first()

    def find_var_name(self, destination):
        if destination.type == 'transfer':
            return self.TRANSFERS_TO_DB[destination.transfer]
        elif destination.type == 'onlinerec':
            return 'togglerecord'

    def delete(self, func_key_id):
        pass

----------------------------------------

File: func_key_template/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.func_key_template import FuncKeyTemplate
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=FuncKeyTemplate, columns={'name': FuncKeyTemplate.name}, default_sort='name'
)


class FuncKeyTemplateSearchSystem(SearchSystem):
    def search_from_query(self, query, parameters=None):
        query = self._apply_private_filter(query)
        return super().search_from_query(query, parameters)

    def _apply_private_filter(self, query):
        return query.filter(FuncKeyTemplate.private.is_(False))


template_search = FuncKeyTemplateSearchSystem(config)

----------------------------------------

File: group/__init__.py
Please review for update


----------------------------------------

File: group/dao.py
Please review for update

# Copyright 2023 Accent Communications

from uuid import UUID

from accent_dao.helpers.db_manager import daosession

from .persistor import GroupPersistor
from .search import group_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return GroupPersistor(session, group_search, tenant_uuids).search(parameters)


@daosession
def get(session, group_id, tenant_uuids=None):
    field, value = _id_to_field_value(group_id)
    return GroupPersistor(session, group_search, tenant_uuids).get_by({field: value})


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return GroupPersistor(session, group_search, tenant_uuids).get_by(criteria)


@daosession
def find(session, group_id, tenant_uuids=None):
    field, value = _id_to_field_value(group_id)
    return GroupPersistor(session, group_search, tenant_uuids).find_by({field: value})


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return GroupPersistor(session, group_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return GroupPersistor(session, group_search, tenant_uuids).find_all_by(criteria)


@daosession
def create(session, group):
    return GroupPersistor(session, group_search).create(group)


@daosession
def edit(session, group):
    GroupPersistor(session, group_search).edit(group)


@daosession
def delete(session, group):
    GroupPersistor(session, group_search).delete(group)


@daosession
def associate_all_member_users(session, group, members):
    GroupPersistor(session, group_search).associate_all_member_users(group, members)


@daosession
def associate_all_member_extensions(session, group, members):
    GroupPersistor(session, group_search).associate_all_member_extensions(
        group, members
    )


@daosession
def associate_call_permission(session, group, call_permission):
    GroupPersistor(session, group_search).associate_call_permission(
        group, call_permission
    )


@daosession
def dissociate_call_permission(session, group, call_permission):
    GroupPersistor(session, group_search).dissociate_call_permission(
        group, call_permission
    )


def _id_to_field_value(id_or_uuid):
    if isinstance(id_or_uuid, UUID):
        return 'uuid', str(id_or_uuid)

    try:
        return 'id', int(id_or_uuid)
    except ValueError:
        return 'uuid', str(UUID(id_or_uuid))

----------------------------------------

File: group/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import joinedload

from accent_dao.alchemy.groupfeatures import GroupFeatures as Group
from accent_dao.helpers import errors
from accent_dao.helpers.db_manager import Session
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class GroupPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Group

    def __init__(self, session, group_search, tenant_uuids=None):
        self.session = session
        self.search_system = group_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self._search_query()
        query = self.build_criteria(query, criteria)
        if self.tenant_uuids is not None:
            query = query.filter(Group.tenant_uuid.in_(self.tenant_uuids))
        return query

    def get_by(self, criteria):
        model = self.find_by(criteria)
        if not model:
            raise errors.not_found('Group', **criteria)
        return model

    def _search_query(self):
        return (
            self.session.query(Group)
            .options(joinedload('caller_id'))
            .options(joinedload('extensions'))
            .options(joinedload('incall_dialactions').joinedload('incall'))
            .options(joinedload('group_dialactions'))
            .options(joinedload('user_queue_members').joinedload('user'))
            .options(joinedload('queue'))
            .options(joinedload('schedule_paths').joinedload('schedule'))
            .options(joinedload('rightcall_members').joinedload('rightcall'))
        )

    def delete(self, group):
        self._delete_associations(group)
        self.session.delete(group)
        self.session.flush()

    def _delete_associations(self, group):
        for extension in group.extensions:
            extension.type = 'user'
            extension.typeval = '0'

    def associate_all_member_users(self, group, members):
        with Session.no_autoflush:
            group.user_queue_members = []
            for member in members:
                self._fill_user_queue_member_default_values(member)
                group.user_queue_members.append(member)
                member.fix()
        self.session.flush()

    def _fill_user_queue_member_default_values(self, member):
        member.category = 'group'
        member.usertype = 'user'

    def associate_all_member_extensions(self, group, members):
        with Session.no_autoflush:
            group.extension_queue_members = []
            for member in members:
                self._fill_extension_queue_member_default_values(member)
                group.extension_queue_members.append(member)
                member.fix()
        self.session.flush()

    def _fill_extension_queue_member_default_values(self, member):
        member.category = 'group'
        member.usertype = 'user'
        member.userid = 0

    def associate_call_permission(self, group, call_permission):
        if call_permission not in group.call_permissions:
            group.call_permissions.append(call_permission)
            self.session.flush()
            self.session.expire(group, ['rightcall_members'])

    def dissociate_call_permission(self, group, call_permission):
        if call_permission in group.call_permissions:
            group.call_permissions.remove(call_permission)
            self.session.flush()
            self.session.expire(group, ['rightcall_members'])
----------------------------------------

File: group/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.groupfeatures import GroupFeatures as Group
from accent_dao.resources.utils.search import SearchSystem, SearchConfig


config = SearchConfig(
    table=Group,
    columns={
        'id': Group.id,
        'name': Group.name,
        'label': Group.label,
        'preprocess_subroutine': Group.preprocess_subroutine,
        'exten': Group.exten,
    },
    default_sort='label',
)

group_search = SearchSystem(config)

----------------------------------------

File: iax_callnumberlimits/__init__.py
Please review for update


----------------------------------------

File: iax_callnumberlimits/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import IAXCallNumberLimitsPersistor


@daosession
def find_all(session):
    return IAXCallNumberLimitsPersistor(session).find_all()


@daosession
def edit_all(session, iax_callnumberlimits):
    IAXCallNumberLimitsPersistor(session).edit_all(iax_callnumberlimits)

----------------------------------------

File: iax_callnumberlimits/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.iaxcallnumberlimits import IAXCallNumberLimits


class IAXCallNumberLimitsPersistor:
    def __init__(self, session):
        self.session = session

    def find_all(self):
        query = self.session.query(IAXCallNumberLimits)
        return query.all()

    def edit_all(self, iax_callnumberlimits):
        self.session.query(IAXCallNumberLimits).delete()
        self.session.add_all(iax_callnumberlimits)
        self.session.flush()

----------------------------------------

File: iax_general/__init__.py
Please review for update


----------------------------------------

File: iax_general/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import IAXGeneralPersistor


@daosession
def find_all(session):
    return IAXGeneralPersistor(session).find_all()


@daosession
def edit_all(session, iax_general):
    IAXGeneralPersistor(session).edit_all(iax_general)

----------------------------------------

File: iax_general/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.staticiax import StaticIAX


class IAXGeneralPersistor:
    def __init__(self, session):
        self.session = session

    def find_all(self):
        query = (
            self.session.query(StaticIAX)
            .filter(StaticIAX.var_name != 'register')
            .filter(StaticIAX.var_val != None)  # noqa
            .order_by(StaticIAX.var_metric.asc())
        )
        return query.all()

    def edit_all(self, iax_general):
        self.session.query(StaticIAX).filter(StaticIAX.var_name != 'register').delete()
        self.session.add_all(self._fill_default_values(iax_general))
        self.session.flush()

    def _fill_default_values(self, iax_general):
        for var_metric, setting in enumerate(iax_general):
            setting.filename = 'iax.conf'
            setting.category = 'general'
        return iax_general

----------------------------------------

File: incall/__init__.py
Please review for update


----------------------------------------

File: incall/dao.py
Please review for update

# Copyright 2023 Accent Communications

from contextlib import contextmanager

from accent_dao.helpers.db_manager import Session
from accent_dao.resources.incall.persistor import IncallPersistor
from accent_dao.resources.incall.search import incall_search


def persistor(tenant_uuids=None):
    return IncallPersistor(Session, incall_search, tenant_uuids)


def search(tenant_uuids=None, **parameters):
    return persistor(tenant_uuids).search(parameters)


def get(incall_id, tenant_uuids=None):
    return persistor(tenant_uuids).get_by({'id': incall_id})


def get_by(tenant_uuids=None, **criteria):
    return persistor(tenant_uuids).get_by(criteria)


def find(incall_id, tenant_uuids=None):
    return persistor(tenant_uuids).find_by({'id': incall_id})


def find_by(tenant_uuids=None, **criteria):
    return persistor(tenant_uuids).find_by(criteria)


def find_all_by(tenant_uuids=None, **criteria):
    return persistor(tenant_uuids).find_all_by(criteria)


def find_main_callerid(tenant_uuid):
    return persistor().find_main_callerid(tenant_uuid)


def create(incall):
    return persistor().create(incall)


def edit(incall):
    persistor().edit(incall)


def delete(incall):
    persistor().delete(incall)


@contextmanager
def query_options(*options):
    with IncallPersistor.context_query_options(*options):
        yield

----------------------------------------

File: incall/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql import cast
from sqlalchemy.sql.expression import and_, literal_column
from sqlalchemy.types import String

from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.incall import Incall
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.query_options import QueryOptionsMixin
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class IncallPersistor(QueryOptionsMixin, CriteriaBuilderMixin, BasePersistor):
    _search_table = Incall

    def __init__(self, session, incall_search, tenant_uuids=None):
        self.session = session
        self.search_system = incall_search
        self.tenant_uuids = tenant_uuids

    def create(self, incall):
        incall.main = not self._is_main_already_exists(incall.tenant_uuid)
        self.session.add(incall)
        self.session.flush()
        return incall

    def _is_main_already_exists(self, tenant_uuid):
        return (
            self.session.query(Incall)
            .filter(Incall.main.is_(True))
            .filter(Incall.tenant_uuid == tenant_uuid)
            .first()
        )

    def _find_query(self, criteria):
        query = self._generate_query()
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self._generate_query()

    def delete(self, incall):
        self._delete_associations(incall)
        self.session.delete(incall)
        self.session.flush()

    def _delete_associations(self, incall):
        (
            self.session.query(Extension)
            .filter(Extension.type == 'incall')
            .filter(Extension.typeval == str(incall.id))
            .update({'type': 'user', 'typeval': '0'})
        )

    def find_main_callerid(self, tenant_uuid):
        query = (
            self.session.query(
                Extension.exten.label('number'),
                literal_column("'main'").label('type'),
            )
            .select_from(Incall)
            .join(
                Extension,
                and_(
                    Extension.type == 'incall',
                    Extension.typeval == cast(Incall.id, String),
                ),
            )
            .filter(
                Incall.tenant_uuid == tenant_uuid,
                Incall.main.is_(True),
            )
        )
        return query.first()

----------------------------------------

File: incall/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.incall import Incall
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Incall,
    columns={
        'preprocess_subroutine': Incall.preprocess_subroutine,
        'greeting_sound': Incall.greeting_sound,
        'description': Incall.description,
        'exten': Incall.exten,
        'user_id': Incall.user_id,
    },
    default_sort='exten',
    search={
        'preprocess_subroutine': Incall.preprocess_subroutine,
        'greeting_sound': Incall.greeting_sound,
        'description': Incall.description,
        'exten': Incall.exten,
    },
)

incall_search = SearchSystem(config)
----------------------------------------

File: incall/strategy.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import joinedload

from accent_dao.alchemy.dialaction import Dialaction
from accent_dao.alchemy.incall import Incall

incall_preload_relationships = (
    joinedload(Incall.caller_id),
    joinedload(Incall.dialaction).options(
        joinedload(Dialaction.conference),
        joinedload(Dialaction.group),
        joinedload(Dialaction.user).load_only('firstname', 'webi_lastname'),
        joinedload(Dialaction.ivr),
        joinedload(Dialaction.ivr_choice),
        joinedload(Dialaction.switchboard),
        joinedload(Dialaction.voicemail),
        joinedload(Dialaction.application),
        joinedload(Dialaction.queue),
    ),
    joinedload(Incall.extensions).load_only('id', 'exten').selectinload('context_rel'),
    joinedload(Incall.schedule_paths).selectinload('schedule').load_only('id', 'name'),
)
----------------------------------------

File: infos/__init__.py
Please review for update


----------------------------------------

File: infos/dao.py
Please review for update

# Copyright 2023 Accent Communications


from accent_dao.alchemy.infos import Infos
from accent_dao.helpers import errors
from accent_dao.helpers.db_manager import daosession


@daosession
def get(session):
    row = (session.query(Infos).first())

    if not row:
        raise errors.not_found('Infos')
    return row

----------------------------------------

File: ingress_http/__init__.py
Please review for update


----------------------------------------

File: ingress_http/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import Persistor
from .search import http_ingress_search


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return Persistor(session, http_ingress_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return Persistor(session, http_ingress_search, tenant_uuids).find_all_by(criteria)


@daosession
def get(session, http_ingress_uuid, tenant_uuids=None):
    return Persistor(session, http_ingress_search, tenant_uuids).get_by(
        {'uuid': http_ingress_uuid},
    )


@daosession
def search(session, tenant_uuids=None, **parameters):
    return Persistor(session, http_ingress_search, tenant_uuids).search(parameters)


@daosession
def create(session, model):
    return Persistor(session, http_ingress_search).create(model)


@daosession
def edit(session, model):
    Persistor(session, http_ingress_search).edit(model)


@daosession
def delete(session, model):
    return Persistor(session, http_ingress_search).delete(model)

----------------------------------------

File: ingress_http/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.ingress_http import IngressHTTP
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class Persistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = IngressHTTP

    def __init__(self, session, search_system, tenant_uuids=None):
        self.session = session
        self.search_system = search_system
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(IngressHTTP)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

----------------------------------------

File: ingress_http/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.ingress_http import IngressHTTP
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=IngressHTTP,
    columns={'uri': IngressHTTP.uri},
    default_sort='uri',
)

http_ingress_search = SearchSystem(config)

----------------------------------------

File: ivr/__init__.py
Please review for update


----------------------------------------

File: ivr/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import IVRPersistor
from .search import ivr_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return IVRPersistor(session, ivr_search, tenant_uuids).search(parameters)


@daosession
def get(session, ivr_id, tenant_uuids=None):
    return IVRPersistor(session, ivr_search, tenant_uuids).get_by({'id': ivr_id})


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return IVRPersistor(session, ivr_search, tenant_uuids).get_by(criteria)


@daosession
def find(session, ivr_id, tenant_uuids=None):
    return IVRPersistor(session, ivr_search, tenant_uuids).find_by({'id': ivr_id})


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return IVRPersistor(session, ivr_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return IVRPersistor(session, ivr_search, tenant_uuids).find_all_by(criteria)


@daosession
def create(session, ivr):
    return IVRPersistor(session, ivr_search).create(ivr)


@daosession
def edit(session, ivr):
    IVRPersistor(session, ivr_search).edit(ivr)


@daosession
def delete(session, ivr):
    IVRPersistor(session, ivr_search).delete(ivr)

----------------------------------------

File: ivr/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.ivr import IVR
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class IVRPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = IVR

    def __init__(self, session, ivr_search, tenant_uuids=None):
        self.session = session
        self.search_system = ivr_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(IVR)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

----------------------------------------

File: ivr/search.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql.expression import and_, cast
from sqlalchemy.sql.sqltypes import String
from accent_dao.alchemy.ivr import IVR
from accent_dao.alchemy.incall import Incall
from accent_dao.alchemy.dialaction import Dialaction
from accent_dao.resources.utils.search import SearchSystem, SearchConfig


config = SearchConfig(
    table=IVR,
    columns={
        "id": IVR.id,
        "name": IVR.name,
        "description": IVR.description,
        "exten": Incall.exten,
    },
    search=["id", "name", "description", "exten"],
    sort=["id", "name", "description"],
    default_sort="id",
)


class IVRSearchSystem(SearchSystem):
    def _search_on_extension(self, query):
        return (
            query.outerjoin(
                Dialaction,
                and_(
                    Dialaction.action == "ivr",
                    Dialaction.actionarg1 == cast(IVR.id, String),
                ),
            )
            .outerjoin(
                Incall,
                and_(
                    Dialaction.category == "incall",
                    Dialaction.categoryval == cast(Incall.id, String),
                    Incall.commented == 0,
                ),
            )
            .group_by(IVR)
        )

    def search_from_query(self, query, parameters):
        query = self._search_on_extension(query)
        return super().search_from_query(query, parameters)


ivr_search = IVRSearchSystem(config)

----------------------------------------

File: line/__init__.py
Please review for update


----------------------------------------

File: line/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_utils import flush_session
from accent_dao.helpers.db_manager import daosession

from accent_dao.resources.line.persistor import LinePersistor
from accent_dao.resources.line.fixes import LineFixes


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return LinePersistor(session, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return LinePersistor(session, tenant_uuids).find_all_by(criteria)


@daosession
def search(session, tenant_uuids=None, **parameters):
    return LinePersistor(session, tenant_uuids).search(parameters)


@daosession
def get(session, line_id, tenant_uuids=None):
    return LinePersistor(session, tenant_uuids).get(line_id)


@daosession
def create(session, line):
    with flush_session(session):
        return LinePersistor(session).create(line)


@daosession
def edit(session, line):
    with flush_session(session):
        LinePersistor(session).edit(line)
        session.expire(line)
        LineFixes(session).fix_line(line.id)


@daosession
def delete(session, line):
    with flush_session(session):
        return LinePersistor(session).delete(line)


@daosession
def associate_endpoint_sip(session, line, endpoint):
    LinePersistor(session).associate_endpoint_sip(line, endpoint)


@daosession
def dissociate_endpoint_sip(session, line, endpoint):
    LinePersistor(session).dissociate_endpoint_sip(line, endpoint)


@daosession
def associate_endpoint_sccp(session, line, endpoint):
    LinePersistor(session).associate_endpoint_sccp(line, endpoint)


@daosession
def dissociate_endpoint_sccp(session, line, endpoint):
    LinePersistor(session).dissociate_endpoint_sccp(line, endpoint)


@daosession
def associate_endpoint_custom(session, line, endpoint):
    LinePersistor(session).associate_endpoint_custom(line, endpoint)


@daosession
def dissociate_endpoint_custom(session, line, endpoint):
    LinePersistor(session).dissociate_endpoint_custom(line, endpoint)


@daosession
def associate_application(session, line, application):
    LinePersistor(session).associate_application(line, application)


@daosession
def dissociate_application(session, line, application):
    LinePersistor(session).dissociate_application(line, application)

----------------------------------------

File: line/fixes.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import Load

from accent_dao.alchemy.endpoint_sip import EndpointSIP
from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.line_extension import LineExtension
from accent_dao.alchemy.linefeatures import LineFeatures
from accent_dao.alchemy.queuemember import QueueMember
from accent_dao.alchemy.sccpdevice import SCCPDevice
from accent_dao.alchemy.sccpline import SCCPLine
from accent_dao.alchemy.user_line import UserLine
from accent_dao.alchemy.usercustom import UserCustom
from accent_dao.alchemy.userfeatures import UserFeatures


class LineFixes:
    def __init__(self, session):
        self.session = session

    def fix(self, line_id):
        row = self.get_row(line_id)
        self.fix_number_and_context(row)
        self.fix_protocol(row)
        self.fix_name(row)
        self.fix_caller_id(row)
        self.session.flush()

    def fix_line(self, line_id):
        row = self.get_row(line_id)
        self.fix_number_and_context(row)
        self.fix_protocol(row)
        self.fix_name(row)
        self.session.flush()

    def get_row(self, line_id):
        query = (
            self.session.query(
                LineFeatures,
                EndpointSIP,
                SCCPLine,
                SCCPDevice,
                UserFeatures,
                UserCustom,
                Extension,
            )
            .outerjoin(LineFeatures.endpoint_sip)
            .outerjoin(LineFeatures.endpoint_sccp)
            .outerjoin(LineFeatures.endpoint_custom)
            .outerjoin(SCCPDevice, SCCPLine.name == SCCPDevice.line)
            .outerjoin(LineFeatures.user_lines)
            .outerjoin(UserLine.main_user_rel)
            .outerjoin(LineFeatures.line_extensions)
            .outerjoin(LineExtension.main_extension_rel)
            .options(
                Load(LineFeatures).load_only("id", "name", "number", "context"),
                Load(EndpointSIP).load_only("uuid", "name"),
                Load(SCCPLine).load_only(
                    "id", "name", "context", "cid_name", "cid_num"
                ),
                Load(SCCPDevice).load_only("id", "line"),
                Load(UserFeatures).load_only(
                    "id", "firstname", "webi_lastname", "callerid"
                ),
                Load(UserCustom).load_only("id", "context"),
                Load(Extension).load_only("id", "exten", "context"),
            )
            .filter(LineFeatures.id == line_id)
        )

        return query.first()

    def fix_protocol(self, row):
        if row.EndpointSIP:
            interface = f'PJSIP/{row.EndpointSIP.name}'
            self.fix_queue_member(row, interface)
        elif row.SCCPLine:
            self.fix_sccp_line(row)
            interface = f'SCCP/{row.SCCPLine.name}'
            self.fix_queue_member(row, interface)
        elif row.UserCustom:
            row.UserCustom.context = row.LineFeatures.context
            self.fix_queue_member(row, row.UserCustom.interface)

    def fix_sccp_line(self, row):
        if row.Extension:
            row.SCCPLine.update_extension(row.Extension)

    def fix_number_and_context(self, row):
        if row.Extension:
            row.LineFeatures.update_extension(row.Extension)
        else:
            row.LineFeatures.clear_extension()

    def fix_name(self, row):
        row.LineFeatures.update_name()

    def fix_caller_id(self, row):
        if row.UserFeatures:
            if row.LineFeatures.endpoint_sip_uuid:
                row.EndpointSIP.update_caller_id(row.UserFeatures, row.Extension)
            elif row.LineFeatures.endpoint_sccp_id:
                row.SCCPLine.update_caller_id(row.UserFeatures, row.Extension)

    def fix_queue_member(self, row, interface):
        if row.UserFeatures and row.UserFeatures.lines:
            if row.UserFeatures.lines[0] == row.LineFeatures:
                (
                    self.session.query(QueueMember)
                    .filter(QueueMember.usertype == 'user')
                    .filter(QueueMember.userid == row.UserFeatures.id)
                    .filter(QueueMember.channel != 'Local')
                    .update({'interface': interface})
                )

                if extension := row.Extension:
                    local_interface = f'Local/{extension.exten}@{extension.context}'
                    (
                        self.session.query(QueueMember)
                        .filter(QueueMember.usertype == 'user')
                        .filter(QueueMember.userid == row.UserFeatures.id)
                        .filter(QueueMember.channel == 'Local')
                        .update({'interface': local_interface})
                    )

----------------------------------------

File: line/persistor.py
Please review for update

# Copyright 2023 Accent Communications

import random

from sqlalchemy import text
from sqlalchemy.orm import joinedload

from accent_dao.alchemy.endpoint_sip import EndpointSIP
from accent_dao.alchemy.linefeatures import LineFeatures as Line
from accent_dao.alchemy.sccpline import SCCPLine
from accent_dao.alchemy.usercustom import UserCustom
from accent_dao.helpers import errors
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.line.search import line_search
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class LinePersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Line

    def __init__(self, session, tenant_uuids=None):
        self.session = session
        self.tenant_uuids = tenant_uuids
        self.search_system = line_search

    def _find_query(self, criteria):
        query = self.session.query(Line)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return (
            self.session.query(Line)
            .options(joinedload('context_rel'))
            .options(joinedload('endpoint_sccp'))
            .options(joinedload('endpoint_sip'))
            .options(joinedload('endpoint_sip').joinedload('_auth_section'))
            .options(joinedload('endpoint_sip').joinedload('_endpoint_section'))
            .options(joinedload('endpoint_custom'))
            .options(joinedload('line_extensions').joinedload('extension'))
            .options(joinedload('user_lines').joinedload('user'))
        )

    def get(self, line_id):
        line = self.find(line_id)
        if not line:
            raise errors.not_found('Line', id=line_id)
        return line

    def find(self, line_id):
        return self.query().filter(Line.id == line_id).first()

    def query(self):
        query = (
            self.session.query(Line)
            .options(joinedload('endpoint_sccp'))
            .options(joinedload('endpoint_sip'))
        )
        query = self._filter_tenant_uuid(query)
        return query

    def create(self, line):
        if line.provisioning_code is None:
            line.provisioning_code = self.generate_provisioning_code()
        if line.configregistrar is None:
            line.configregistrar = 'default'
        if line.ipfrom is None:
            line.ipfrom = ''

        self.session.add(line)
        self.session.flush()
        return line

    def delete(self, line):
        if line.endpoint_sip_uuid:
            (
                self.session.query(EndpointSIP)
                .filter(EndpointSIP.uuid == line.endpoint_sip_uuid)
                .delete()
            )
        elif line.endpoint_sccp_id:
            (
                self.session.query(SCCPLine)
                .filter(SCCPLine.id == line.endpoint_sccp_id)
                .delete()
            )
        elif line.endpoint_custom_id:
            (
                self.session.query(UserCustom)
                .filter(UserCustom.id == line.endpoint_custom_id)
                .delete()
            )
        self.session.delete(line)
        self.session.flush()

    def generate_provisioning_code(self):
        exists = True
        while exists:
            code = self.random_code()
            exists = (
                self.session.query(Line.provisioningid)
                .filter(Line.provisioningid == int(code))
                .count()
            ) > 0
        return code

    def random_code(self):
        return str(100000 + random.randint(0, 899999))

    def _filter_tenant_uuid(self, query):
        if self.tenant_uuids is None:
            return query

        if not self.tenant_uuids:
            return query.filter(text('false'))

        return query.filter(Line.tenant_uuid.in_(self.tenant_uuids))

    def associate_endpoint_sip(self, line, endpoint):
        if line.protocol not in ('sip', None):
            raise errors.resource_associated(
                'Trunk', 'Endpoint', line_id=line.id, protocol=line.protocol
            )
        line.endpoint_sip_uuid = endpoint.uuid
        self.session.flush()
        self.session.expire(line, ['endpoint_sip'])

    def dissociate_endpoint_sip(self, line, endpoint):
        if endpoint is line.endpoint_sip:
            line.endpoint_sip_uuid = None
            self.session.flush()
            self.session.expire(line, ['endpoint_sip'])

    def associate_endpoint_sccp(self, line, endpoint):
        if line.protocol not in ('sccp', None):
            raise errors.resource_associated(
                'Trunk', 'Endpoint', line_id=line.id, protocol=line.protocol
            )
        line.endpoint_sccp_id = endpoint.id
        self.session.flush()
        self.session.expire(line, ['endpoint_sccp'])

    def dissociate_endpoint_sccp(self, line, endpoint):
        if endpoint is line.endpoint_sccp:
            line.endpoint_sccp_id = None
            self.session.flush()
            self.session.expire(line, ['endpoint_sccp'])

    def associate_endpoint_custom(self, line, endpoint):
        if line.protocol not in ('custom', None):
            raise errors.resource_associated(
                'Trunk', 'Endpoint', line_id=line.id, protocol=line.protocol
            )
        line.endpoint_custom_id = endpoint.id
        self.session.flush()
        self.session.expire(line, ['endpoint_custom'])

    def dissociate_endpoint_custom(self, line, endpoint):
        if endpoint is line.endpoint_custom:
            line.endpoint_custom_id = None
            self.session.flush()
            self.session.expire(line, ['endpoint_custom'])

    def associate_application(self, line, application):
        line.application_uuid = application.uuid
        self.session.flush()

    def dissociate_application(self, line, application):
        line.application_uuid = None
        self.session.flush()

----------------------------------------

File: line/search.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql.elements import and_

from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.line_extension import LineExtension
from accent_dao.alchemy.linefeatures import LineFeatures
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=LineFeatures,
    columns={
        'context': LineFeatures.context,
        'provisioning_code': LineFeatures.provisioningid,
        'provisioning_extension': LineFeatures.provisioningid,
        'position': LineFeatures.num,
        'device_slot': LineFeatures.num,
        'protocol': LineFeatures.protocol,
        'device_id': LineFeatures.device,
        'name': LineFeatures.name,
        'caller_id_name': LineFeatures.caller_id_name,
        'caller_id_num': LineFeatures.caller_id_num,
        'exten': Extension.exten,
    },
    default_sort='name',
)


class LineSearchSystem(SearchSystem):
    def search_from_query(self, query, parameters):
        query = self._search_on_extension(query)
        return super().search_from_query(query, parameters)

    def _search_on_extension(self, query):
        return query.outerjoin(
            LineExtension,
            and_(LineExtension.line_id == LineFeatures.id, LineFeatures.commented == 0),
        ).outerjoin(
            Extension,
            and_(
                LineExtension.extension_id == Extension.id,
                LineExtension.line_id == LineFeatures.id,
                Extension.commented == 0,
            ),
        )


line_search = LineSearchSystem(config)

----------------------------------------

File: line_extension/__init__.py
Please review for update


----------------------------------------

File: line_extension/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import Session

from .persistor import LineExtensionPersistor


def get_by(**criteria):
    return LineExtensionPersistor(Session).get_by(**criteria)


def find_by(**criteria):
    return LineExtensionPersistor(Session).find_by(**criteria)


def find_all_by(**criteria):
    return LineExtensionPersistor(Session).find_all_by(**criteria)


def associate(line, extension):
    return LineExtensionPersistor(Session).associate_line_extension(line, extension)


def dissociate(line, extension):
    return LineExtensionPersistor(Session).dissociate_line_extension(line, extension)


def find_all_by_line_id(line_id):
    return LineExtensionPersistor(Session).find_all_by(line_id=line_id)


def find_by_line_id(line_id):
    return LineExtensionPersistor(Session).find_by(line_id=line_id)


def find_by_extension_id(extension_id):
    return LineExtensionPersistor(Session).find_by(extension_id=extension_id)

----------------------------------------

File: line_extension/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.line_extension import LineExtension
from accent_dao.helpers import errors
from accent_dao.resources.extension.fixes import ExtensionFixes
from accent_dao.resources.line.fixes import LineFixes
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class LineExtensionPersistor(CriteriaBuilderMixin):
    _search_table = LineExtension

    def __init__(self, session):
        self.session = session

    def find_query(self, **criteria):
        query = self.session.query(LineExtension)
        return self.build_criteria(query, criteria)

    def find_by(self, **criteria):
        return self.find_query(**criteria).first()

    def get_by(self, **criteria):
        line_extension = self.find_by(**criteria)
        if not line_extension:
            raise errors.not_found('LineExtension', **criteria)
        return line_extension

    def find_all_by(self, **criteria):
        return self.find_query(**criteria).all()

    def associate_line_extension(self, line, extension):
        line_extension = self.find_by(line_id=line.id, extension_id=extension.id)
        if line_extension:
            return line_extension

        line_main_extension = self.find_by(main_extension=True, line_id=line.id)

        line_extension = LineExtension(
            line_id=line.id,
            extension_id=extension.id,
            main_extension=(False if line_main_extension else True),
        )

        self.session.add(line_extension)
        self.session.flush()
        ExtensionFixes(self.session).fix_extension(line_extension.extension_id)
        LineFixes(self.session).fix(line_extension.line_id)

        return line_extension

    def dissociate_line_extension(self, line, extension):
        line_extension = self.find_by(line_id=line.id, extension_id=extension.id)
        if not line_extension:
            return

        if line_extension.main_extension:
            self._set_oldest_main_extension(line)

        self.session.delete(line_extension)
        self.session.flush()
        ExtensionFixes(self.session).fix_extension(line_extension.extension_id)
        LineFixes(self.session).fix(line_extension.line_id)

        return line_extension

    def _set_oldest_main_extension(self, line):
        oldest_line_extension = (
            self.session.query(LineExtension)
            .filter(LineExtension.line_id == line.id)
            .filter(LineExtension.main_extension == False)  # noqa
            .order_by(LineExtension.extension_id.asc())
            .first()
        )

        if oldest_line_extension:
            oldest_line_extension.main_extension = True
            self.session.add(oldest_line_extension)

----------------------------------------

File: meeting/__init__.py
Please review for update


----------------------------------------

File: meeting/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_utils import flush_session
from accent_dao.helpers.db_manager import daosession

from .persistor import Persistor
from .search import meeting_search


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return Persistor(session, meeting_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return Persistor(session, meeting_search, tenant_uuids).find_all_by(criteria)


@daosession
def search(session, tenant_uuids=None, **parameters):
    return Persistor(session, meeting_search, tenant_uuids).search(parameters)


@daosession
def get(session, meeting_uuid, tenant_uuids=None):
    return Persistor(session, meeting_search, tenant_uuids).get_by(
        {'uuid': meeting_uuid},
    )


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return Persistor(session, meeting_search, tenant_uuids).get_by(criteria)


@daosession
def create(session, meeting):
    with flush_session(session):
        return Persistor(session, meeting_search).create(meeting)


@daosession
def edit(session, meeting):
    with flush_session(session):
        Persistor(session, meeting_search).edit(meeting)
        if not meeting.require_authorization:
            for authorization in meeting.meeting_authorizations:
                if authorization.status == 'pending':
                    authorization.status = 'accepted'


@daosession
def delete(session, meeting):
    with flush_session(session):
        return Persistor(session, meeting_search).delete(meeting)

----------------------------------------

File: meeting/persistor.py
Please review for update

# Copyright 2023 Accent Communications

import random

from accent_dao.alchemy.meeting import Meeting, MeetingOwner
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin, SearchResult

NUMBER_LEN = 6


class Persistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Meeting

    def __init__(self, session, search_system, tenant_uuids=None):
        self.session = session
        self.search_system = search_system
        self.tenant_uuids = tenant_uuids

    def create(self, meeting):
        meeting.number = self._generate_number()
        self.session.add(meeting)
        self.session.flush()
        return meeting

    def search(self, parameters):
        query = self._search_query()
        query = self._filter_tenant_uuid(query)
        query = self._filter_owner(query, parameters)
        query = self._filter_created_before(query, parameters)
        rows, total = self.search_system.search_from_query(query, parameters)
        return SearchResult(total, rows)

    def _filter_owner(self, query, criteria):
        owner = criteria.pop('owner', None)
        if not owner:
            return query

        owner_meeting = self.session.query(MeetingOwner.meeting_uuid).filter(
            MeetingOwner.user_uuid == owner
        )
        query = query.filter(Meeting.uuid.in_(owner_meeting))

        return query

    def _filter_created_before(self, query, criteria):
        before = criteria.pop('created_before', None)
        if not before:
            return query

        return query.filter(Meeting.created_at < before)

    def _find_query(self, criteria):
        query = self.session.query(Meeting)
        query = self._filter_tenant_uuid(query)
        query = self._filter_owner(query, criteria)
        query = self._filter_created_before(query, criteria)
        return self.build_criteria(query, criteria)

    def _generate_number(self):
        max = int('9' * NUMBER_LEN)
        while True:
            number = str(random.randint(0, max)).rjust(NUMBER_LEN, '0')
            count = self.session.query(Meeting).filter(Meeting.number == number).count()
            if not count:
                return number

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

----------------------------------------

File: meeting/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.meeting import Meeting
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Meeting,
    columns={
        'name': Meeting.name,
        'persistent': Meeting.persistent,
        'require_authorization': Meeting.require_authorization,
        'creation_time': Meeting.created_at,
    },
    search=['name'],
    default_sort='name',
)

meeting_search = SearchSystem(config)

----------------------------------------

File: meeting_authorization/__init__.py
Please review for update


----------------------------------------

File: meeting_authorization/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession
from accent_dao.helpers.db_utils import flush_session

from .persistor import Persistor
from .search import meeting_authorization_search


@daosession
def find_by(session, meeting_uuid, **criteria):
    return Persistor(session, meeting_authorization_search, meeting_uuid).find_by(
        criteria
    )


@daosession
def find_all_by(session, meeting_uuid, **criteria):
    return Persistor(session, meeting_authorization_search, meeting_uuid).find_all_by(
        criteria
    )


@daosession
def search(session, meeting_uuid, **parameters):
    return Persistor(session, meeting_authorization_search, meeting_uuid).search(
        parameters
    )


@daosession
def get(session, meeting_uuid, authorization_uuid, **criteria):
    criteria = dict(criteria)
    criteria['uuid'] = authorization_uuid
    return Persistor(session, meeting_authorization_search, meeting_uuid).get_by(
        criteria
    )


@daosession
def get_by(session, meeting_uuid, **criteria):
    return Persistor(session, meeting_authorization_search, meeting_uuid).get_by(
        criteria
    )


@daosession
def create(session, meeting_authorization):
    with flush_session(session):
        return Persistor(session, meeting_authorization_search).create(
            meeting_authorization
        )


@daosession
def edit(session, meeting_authorization):
    with flush_session(session):
        Persistor(session, meeting_authorization_search).edit(meeting_authorization)


@daosession
def delete(session, meeting_authorization):
    with flush_session(session):
        return Persistor(session, meeting_authorization_search).delete(
            meeting_authorization
        )

----------------------------------------

File: meeting_authorization/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.meeting import MeetingOwner
from accent_dao.alchemy.meeting_authorization import MeetingAuthorization
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin, SearchResult


class Persistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = MeetingAuthorization

    def __init__(self, session, search_system, meeting_uuid=None):
        self.session = session
        self.search_system = search_system
        self.meeting_uuid = meeting_uuid

    def search(self, parameters):
        query = self._search_query()
        query = self._filter_meeting_uuid(query)
        query = self._filter_owner(query, parameters)
        query = self._filter_guest_uuid(query, parameters)
        query = self._filter_authorization_uuid(query, parameters)
        query = self._filter_created_before(query, parameters)
        rows, total = self.search_system.search_from_query(query, parameters)
        return SearchResult(total, rows)

    def _filter_meeting_uuid(self, query):
        if self.meeting_uuid:
            return query.filter(MeetingAuthorization.meeting_uuid == self.meeting_uuid)
        return query

    def _filter_owner(self, query, criteria):
        owner = criteria.pop('owner', None)
        if not owner:
            return query

        owner_meeting = self.session.query(MeetingOwner.meeting_uuid).filter(
            MeetingOwner.user_uuid == owner
        )
        query = query.filter(MeetingAuthorization.meeting_uuid.in_(owner_meeting))

        return query

    def _filter_guest_uuid(self, query, criteria):
        guest_uuid = criteria.pop('guest_uuid', None)
        if not guest_uuid:
            return query

        return query.filter(MeetingAuthorization.guest_uuid == guest_uuid)

    def _filter_authorization_uuid(self, query, criteria):
        uuid = criteria.pop('uuid', None)
        if not uuid:
            return query

        return query.filter(MeetingAuthorization.uuid == uuid)

    def _filter_created_before(self, query, criteria):
        before = criteria.pop('created_before', None)
        if not before:
            return query

        return query.filter(MeetingAuthorization.created_at < before)

    def _find_query(self, criteria):
        query = self.session.query(MeetingAuthorization)
        query = self._filter_meeting_uuid(query)
        query = self._filter_owner(query, criteria)
        query = self._filter_guest_uuid(query, criteria)
        query = self._filter_authorization_uuid(query, criteria)
        query = self._filter_created_before(query, criteria)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

----------------------------------------

File: meeting_authorization/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.meeting_authorization import MeetingAuthorization
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=MeetingAuthorization,
    columns={
        'guest_name': MeetingAuthorization.guest_name,
        'creation_time': MeetingAuthorization.created_at,
    },
    search=['guest_name'],
    default_sort='guest_name',
)

meeting_authorization_search = SearchSystem(config)

----------------------------------------

File: moh/__init__.py
Please review for update


----------------------------------------

File: moh/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession
from accent_dao.resources.moh.persistor import MOHPersistor
from accent_dao.resources.moh.search import moh_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return MOHPersistor(session, moh_search, tenant_uuids).search(parameters)


@daosession
def get(session, moh_uuid, tenant_uuids=None):
    return MOHPersistor(session, moh_search, tenant_uuids).get_by({'uuid': moh_uuid})


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return MOHPersistor(session, moh_search, tenant_uuids).get_by(criteria)


@daosession
def find(session, moh_uuid, tenant_uuids=None):
    return MOHPersistor(session, moh_search, tenant_uuids).find_by({'uuid': moh_uuid})


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return MOHPersistor(session, moh_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return MOHPersistor(session, moh_search, tenant_uuids).find_all_by(criteria)


@daosession
def create(session, moh):
    return MOHPersistor(session, moh_search).create(moh)


@daosession
def edit(session, moh):
    MOHPersistor(session, moh_search).edit(moh)


@daosession
def delete(session, moh):
    MOHPersistor(session, moh_search).delete(moh)

----------------------------------------

File: moh/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.moh import MOH
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class MOHPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = MOH

    def __init__(self, session, moh_search, tenant_uuids=None):
        self.session = session
        self.search_system = moh_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(MOH)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

----------------------------------------

File: moh/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.moh import MOH
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=MOH, columns={'name': MOH.name, 'label': MOH.label}, default_sort='label'
)

moh_search = SearchSystem(config)

----------------------------------------

File: outcall/__init__.py
Please review for update


----------------------------------------

File: outcall/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import OutcallPersistor
from .search import outcall_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return OutcallPersistor(session, outcall_search, tenant_uuids).search(parameters)


@daosession
def get(session, outcall_id, tenant_uuids=None):
    return OutcallPersistor(session, outcall_search, tenant_uuids).get_by(
        {'id': outcall_id}
    )


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return OutcallPersistor(session, outcall_search, tenant_uuids).get_by(criteria)


@daosession
def find(session, outcall_id, tenant_uuids=None):
    return OutcallPersistor(session, outcall_search, tenant_uuids).find_by(
        {'id': outcall_id}
    )


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return OutcallPersistor(session, outcall_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return OutcallPersistor(session, outcall_search, tenant_uuids).find_all_by(criteria)


@daosession
def create(session, outcall):
    return OutcallPersistor(session, outcall_search).create(outcall)


@daosession
def edit(session, outcall):
    OutcallPersistor(session, outcall_search).edit(outcall)


@daosession
def delete(session, outcall):
    OutcallPersistor(session, outcall_search).delete(outcall)


@daosession
def associate_call_permission(session, outcall, call_permission):
    OutcallPersistor(session, outcall_search).associate_call_permission(
        outcall, call_permission
    )


@daosession
def dissociate_call_permission(session, outcall, call_permission):
    OutcallPersistor(session, outcall_search).dissociate_call_permission(
        outcall, call_permission
    )

----------------------------------------

File: outcall/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.outcall import Outcall
from accent_dao.alchemy.rightcallmember import RightCallMember
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class OutcallPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Outcall

    def __init__(self, session, outcall_search, tenant_uuids=None):
        self.session = session
        self.search_system = outcall_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(Outcall)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

    def delete(self, outcall):
        self._delete_associations(outcall)
        self.session.delete(outcall)
        self.session.flush()

    def _delete_associations(self, outcall):
        (
            self.session.query(RightCallMember)
            .filter(RightCallMember.type == 'outcall')
            .filter(RightCallMember.typeval == str(outcall.id))
            .delete()
        )

        for extension in outcall.extensions:
            extension.type = 'user'
            extension.typeval = '0'

    def associate_call_permission(self, outcall, call_permission):
        if call_permission not in outcall.call_permissions:
            outcall.call_permissions.append(call_permission)
            self.session.flush()
            self.session.expire(outcall, ['rightcall_members'])

    def dissociate_call_permission(self, outcall, call_permission):
        if call_permission in outcall.call_permissions:
            outcall.call_permissions.remove(call_permission)
            self.session.flush()
            self.session.expire(outcall, ['rightcall_members'])

----------------------------------------

File: outcall/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.outcall import Outcall
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Outcall,
    columns={
        'id': Outcall.id,
        'description': Outcall.description,
        'name': Outcall.name,
        'preprocess_subroutine': Outcall.preprocess_subroutine,
    },
    default_sort='id',
)

outcall_search = SearchSystem(config)

----------------------------------------

File: paging/__init__.py
Please review for update


----------------------------------------

File: paging/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import PagingPersistor
from .search import paging_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return PagingPersistor(session, paging_search, tenant_uuids).search(parameters)


@daosession
def get(session, paging_id, tenant_uuids=None):
    return PagingPersistor(session, paging_search, tenant_uuids).get_by(
        {'id': paging_id}
    )


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return PagingPersistor(session, paging_search, tenant_uuids).get_by(criteria)


@daosession
def find(session, paging_id, tenant_uuids=None):
    return PagingPersistor(session, paging_search, tenant_uuids).find_by(
        {'id': paging_id}
    )


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return PagingPersistor(session, paging_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return PagingPersistor(session, paging_search, tenant_uuids).find_all_by(criteria)


@daosession
def create(session, paging):
    return PagingPersistor(session, paging_search).create(paging)


@daosession
def edit(session, paging):
    PagingPersistor(session, paging_search).edit(paging)


@daosession
def delete(session, paging):
    PagingPersistor(session, paging_search).delete(paging)

----------------------------------------

File: paging/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.paging import Paging
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class PagingPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Paging

    def __init__(self, session, paging_search, tenant_uuids=None):
        self.session = session
        self.search_system = paging_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(Paging)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

----------------------------------------

File: paging/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.paging import Paging
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Paging,
    columns={
        'id': Paging.id,
        'name': Paging.name,
        'number': Paging.number,
        'announce_sound': Paging.announce_sound,
    },
    default_sort='name',
)

paging_search = SearchSystem(config)

----------------------------------------

File: parking_lot/__init__.py
Please review for update


----------------------------------------

File: parking_lot/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import ParkingLotPersistor
from .search import parking_lot_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return ParkingLotPersistor(session, parking_lot_search, tenant_uuids).search(
        parameters
    )


@daosession
def get(session, parking_lot_id, tenant_uuids=None):
    return ParkingLotPersistor(session, parking_lot_search, tenant_uuids).get_by(
        {'id': parking_lot_id}
    )


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return ParkingLotPersistor(session, parking_lot_search, tenant_uuids).get_by(
        criteria
    )


@daosession
def find(session, parking_lot_id, tenant_uuids=None):
    return ParkingLotPersistor(session, parking_lot_search, tenant_uuids).find_by(
        {'id': parking_lot_id}
    )


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return ParkingLotPersistor(session, parking_lot_search, tenant_uuids).find_by(
        criteria
    )


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return ParkingLotPersistor(session, parking_lot_search, tenant_uuids).find_all_by(
        criteria
    )


@daosession
def create(session, parking_lot):
    return ParkingLotPersistor(session, parking_lot_search).create(parking_lot)


@daosession
def edit(session, parking_lot):
    ParkingLotPersistor(session, parking_lot_search).edit(parking_lot)


@daosession
def delete(session, parking_lot):
    ParkingLotPersistor(session, parking_lot_search).delete(parking_lot)

----------------------------------------

File: parking_lot/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.parking_lot import ParkingLot
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class ParkingLotPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = ParkingLot

    def __init__(self, session, parking_lot_search, tenant_uuids=None):
        self.session = session
        self.search_system = parking_lot_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(ParkingLot)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

    def delete(self, parking_lot):
        self._delete_associations(parking_lot)
        self.session.delete(parking_lot)
        self.session.flush()

    def _delete_associations(self, parking_lot):
        for extension in parking_lot.extensions:
            extension.type = 'user'
            extension.typeval = '0'

----------------------------------------

File: parking_lot/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.parking_lot import ParkingLot
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=ParkingLot,
    columns={
        'id': ParkingLot.id,
        'name': ParkingLot.name,
        'slots_start': ParkingLot.slots_start,
        'slots_end': ParkingLot.slots_end,
        'timeout': ParkingLot.timeout,
        'exten': ParkingLot.exten,
        'context': ParkingLot.context,
    },
    search=[
        'name',
        'slots_start',
        'slots_end',
        'timeout',
        'exten',
        'context',
    ],
    default_sort='name',
)

parking_lot_search = SearchSystem(config)

----------------------------------------

File: phone_number/__init__.py
Please review for update


----------------------------------------

File: phone_number/dao.py
Please review for update

from accent_dao.helpers.db_manager import daosession

from .persistor import Persistor
from .search import search_system


@daosession
def create(session, resource):
    return Persistor(session, search_system).create(resource)


@daosession
def delete(session, resource):
    Persistor(session, search_system).delete(resource)


@daosession
def edit(session, resource):
    Persistor(session, search_system).edit(resource)


@daosession
def find(session, uuid, tenant_uuids=None):
    return Persistor(session, search_system, tenant_uuids=tenant_uuids).find_by(
        {'uuid': uuid}
    )


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return Persistor(session, search_system, tenant_uuids=tenant_uuids).find_all_by(
        criteria
    )


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return Persistor(session, search_system, tenant_uuids=tenant_uuids).find_by(
        criteria
    )


@daosession
def get(session, uuid, tenant_uuids=None):
    return Persistor(session, search_system, tenant_uuids).get_by({'uuid': uuid})


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return Persistor(session, search_system, tenant_uuids).get_by(criteria)


@daosession
def search(session, tenant_uuids=None, **parameters):
    return Persistor(session, search_system, tenant_uuids).search(parameters)
----------------------------------------

File: phone_number/persistor.py
Please review for update

from accent_dao.alchemy.phone_number import PhoneNumber
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.helpers.sequence_utils import split_by
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class Persistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = PhoneNumber

    def __init__(self, session, search_system, tenant_uuids=None):
        self.session = session
        self.search_system = search_system
        self.tenant_uuids = tenant_uuids

    def build_bulk_criteria(self, query, criteria):
        for key, value in criteria.items():
            assert key.endswith('_in')
            column_name = key[:-3]
            column = self._get_column(column_name)
            query = query.filter(column.in_(value))
        return query

    def _find_query(self, criteria):
        query = self.session.query(PhoneNumber)
        if self.tenant_uuids is not None:
            query = query.filter(PhoneNumber.tenant_uuid.in_(self.tenant_uuids))
        bulk_criteria, criteria = split_by(
            criteria.items(), lambda x: x[0].endswith('_in')
        )
        query = self.build_bulk_criteria(query, dict(bulk_criteria))
        query = self.build_criteria(query, dict(criteria))
        return query

    def _search_query(self):
        return self.session.query(PhoneNumber)
----------------------------------------

File: phone_number/search.py
Please review for update

from accent_dao.alchemy.phone_number import PhoneNumber
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=PhoneNumber,
    columns={
        'number': PhoneNumber.number,
        'caller_id_name': PhoneNumber.caller_id_name,
        'shared': PhoneNumber.shared,
        'main': PhoneNumber.main,
    },
    default_sort='number',
)

search_system = SearchSystem(config)
----------------------------------------

File: pjsip_transport/__init__.py
Please review for update


----------------------------------------

File: pjsip_transport/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import TransportPersistor as Persistor
from .search import transport_search


@daosession
def create(session, transport):
    return Persistor(session, transport_search).create(transport)


@daosession
def delete(session, transport, fallback=None):
    Persistor(session, transport_search).delete(transport, fallback)


@daosession
def edit(session, transport):
    Persistor(session, transport_search).edit(transport)


@daosession
def find(session, uuid):
    return Persistor(session, transport_search).find_by({'uuid': uuid})


@daosession
def find_all_by(session, **criteria):
    return Persistor(session, transport_search).find_all_by(criteria)


@daosession
def find_by(session, **criteria):
    return Persistor(session, transport_search).find_by(criteria)


@daosession
def get(session, uuid):
    return Persistor(session, transport_search).get_by({'uuid': uuid})


@daosession
def get_by(session, **criteria):
    return Persistor(session, transport_search).get_by(criteria)


@daosession
def search(session, **parameters):
    return Persistor(session, transport_search).search(parameters)

----------------------------------------

File: pjsip_transport/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.endpoint_sip import EndpointSIP
from accent_dao.alchemy.pjsip_transport import PJSIPTransport
from accent_dao.helpers import errors
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin, SearchResult


class TransportPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = PJSIPTransport

    def __init__(self, session, transport_search):
        self.session = session
        self.transport_search = transport_search

    def delete(self, transport, fallback=None):
        if fallback:
            self._update_transport(transport, fallback)
        self.session.delete(transport)
        self.session.flush()

    def _update_transport(self, current, new):
        (
            self.session.query(EndpointSIP)
            .filter(EndpointSIP.transport_uuid == current.uuid)
            .update({'transport_uuid': new.uuid})
        )

    def get_by(self, criteria):
        model = self.find_by(criteria)
        if not model:
            raise errors.not_found('Transport', **criteria)
        return model

    def search(self, parameters):
        rows, total = self.transport_search.search(self.session, parameters)
        return SearchResult(total, rows)

    def _find_query(self, criteria):
        query = self.session.query(PJSIPTransport)
        return self.build_criteria(query, criteria)

----------------------------------------

File: pjsip_transport/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.pjsip_transport import PJSIPTransport
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=PJSIPTransport,
    columns={
        'uuid': PJSIPTransport.uuid,
        'name': PJSIPTransport.name,
    },
    search={'name': PJSIPTransport.name},
    default_sort='name',
)
transport_search = SearchSystem(config)

----------------------------------------

File: queue/__init__.py
Please review for update


----------------------------------------

File: queue/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import QueuePersistor
from .search import queue_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return QueuePersistor(session, queue_search, tenant_uuids).search(parameters)


@daosession
def get(session, queue_id, tenant_uuids=None):
    return QueuePersistor(session, queue_search, tenant_uuids).get_by({'id': queue_id})


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return QueuePersistor(session, queue_search, tenant_uuids).get_by(criteria)


@daosession
def find(session, queue_id, tenant_uuids=None):
    return QueuePersistor(session, queue_search, tenant_uuids).find_by({'id': queue_id})


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return QueuePersistor(session, queue_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return QueuePersistor(session, queue_search, tenant_uuids).find_all_by(criteria)


@daosession
def create(session, queue):
    return QueuePersistor(session, queue_search).create(queue)


@daosession
def edit(session, queue):
    QueuePersistor(session, queue_search).edit(queue)


@daosession
def delete(session, queue):
    QueuePersistor(session, queue_search).delete(queue)


@daosession
def associate_schedule(session, queue, schedule):
    QueuePersistor(session, queue_search).associate_schedule(queue, schedule)


@daosession
def dissociate_schedule(session, queue, schedule):
    QueuePersistor(session, queue_search).dissociate_schedule(queue, schedule)


@daosession
def associate_member_user(session, queue, member):
    QueuePersistor(session, queue_search).associate_member_user(queue, member)


@daosession
def dissociate_member_user(session, queue, member):
    QueuePersistor(session, queue_search).dissociate_member_user(queue, member)


@daosession
def associate_member_agent(session, queue, member):
    QueuePersistor(session, queue_search).associate_member_agent(queue, member)


@daosession
def dissociate_member_agent(session, queue, member):
    QueuePersistor(session, queue_search).dissociate_member_agent(queue, member)

----------------------------------------

File: queue/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import joinedload

from accent_dao.alchemy.contextmember import ContextMember
from accent_dao.alchemy.queuefeatures import QueueFeatures as Queue
from accent_dao.helpers import errors
from accent_dao.helpers.db_manager import Session
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class QueuePersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Queue

    def __init__(self, session, queue_search, tenant_uuids=None):
        self.session = session
        self.search_system = queue_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self._joinedload_query()
        query = self.build_criteria(query, criteria)
        if self.tenant_uuids is not None:
            query = query.filter(Queue.tenant_uuid.in_(self.tenant_uuids))
        return query

    def get_by(self, criteria):
        model = self.find_by(criteria)
        if not model:
            raise errors.not_found('Queue', **criteria)
        return model

    def _search_query(self):
        return self._joinedload_query()

    def _joinedload_query(self):
        return (
            self.session.query(Queue)
            .options(joinedload('_queue'))
            .options(joinedload('extensions'))
            .options(joinedload('caller_id'))
            .options(joinedload('queue_dialactions'))
            .options(joinedload('schedule_paths').joinedload('schedule'))
        )

    def delete(self, queue):
        self._delete_associations(queue)
        self.session.delete(queue)
        self.session.flush()

    def _delete_associations(self, queue):
        (
            self.session.query(ContextMember)
            .filter(ContextMember.type == 'queue')
            .filter(ContextMember.typeval == str(queue.id))
            .delete()
        )

        for extension in queue.extensions:
            extension.type = 'user'
            extension.typeval = '0'

    def associate_schedule(self, queue, schedule):
        queue.schedules = [schedule]
        self.session.flush()

    def dissociate_schedule(self, queue, schedule):
        queue.schedules = []
        self.session.flush()

    def associate_member_user(self, queue, member):
        if member not in queue.user_queue_members:
            with Session.no_autoflush:
                self._fill_user_queue_member_default_values(member)
                queue.user_queue_members.append(member)
                member.fix()
        self.session.flush()

    def _fill_user_queue_member_default_values(self, member):
        member.category = 'queue'
        member.usertype = 'user'

    def dissociate_member_user(self, queue, member):
        try:
            queue.user_queue_members.remove(member)
            self.session.flush()
        except ValueError:
            pass

    def associate_member_agent(self, queue, member):
        if member not in queue.agent_queue_members:
            with Session.no_autoflush:
                self._fill_agent_queue_member_default_values(member)
                queue.agent_queue_members.append(member)
                member.fix()
        self.session.flush()

    def _fill_agent_queue_member_default_values(self, member):
        member.category = 'queue'
        member.usertype = 'agent'

    def dissociate_member_agent(self, queue, member):
        try:
            queue.agent_queue_members.remove(member)
            self.session.flush()
        except ValueError:
            pass

----------------------------------------

File: queue/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.queuefeatures import QueueFeatures
from accent_dao.resources.utils.search import SearchSystem, SearchConfig


config = SearchConfig(
    table=QueueFeatures,
    columns={
        'id': QueueFeatures.id,
        'name': QueueFeatures.name,
        'label': QueueFeatures.label,
        'preprocess_subroutine': QueueFeatures.preprocess_subroutine,
        'exten': QueueFeatures.exten,
    },
    default_sort='id',
)

queue_search = SearchSystem(config)

----------------------------------------

File: queue_general/__init__.py
Please review for update


----------------------------------------

File: queue_general/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import QueueGeneralPersistor


@daosession
def find_all(session):
    return QueueGeneralPersistor(session).find_all()


@daosession
def edit_all(session, queue_general):
    QueueGeneralPersistor(session).edit_all(queue_general)

----------------------------------------

File: queue_general/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.staticqueue import StaticQueue


class QueueGeneralPersistor:
    def __init__(self, session):
        self.session = session

    def find_all(self):
        query = (
            self.session.query(StaticQueue)
            .filter(StaticQueue.category == 'general')
            .filter(StaticQueue.var_val != None)  # noqa
            .order_by(StaticQueue.var_metric.asc())
        )
        return query.all()

    def edit_all(self, queue_general):
        self.session.query(StaticQueue).filter(
            StaticQueue.category == 'general'
        ).delete()
        self.session.add_all(self._fill_default_values(queue_general))
        self.session.flush()

    def _fill_default_values(self, queue_general):
        for setting in queue_general:
            setting.filename = 'queues.conf'
            setting.category = 'general'
        return queue_general

----------------------------------------

File: register_iax/__init__.py
Please review for update


----------------------------------------

File: register_iax/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import RegisterIAXPersistor
from .search import register_iax_search


@daosession
def search(session, **parameters):
    return RegisterIAXPersistor(session, register_iax_search).search(parameters)


@daosession
def get(session, register_iax_id):
    return RegisterIAXPersistor(session, register_iax_search).get_by({'id': register_iax_id})


@daosession
def find(session, register_iax_id):
    return RegisterIAXPersistor(session, register_iax_search).find_by({'id': register_iax_id})


@daosession
def create(session, register):
    return RegisterIAXPersistor(session, register_iax_search).create(register)


@daosession
def edit(session, register):
    RegisterIAXPersistor(session, register_iax_search).edit(register)


@daosession
def delete(session, register):
    RegisterIAXPersistor(session, register_iax_search).delete(register)

----------------------------------------

File: register_iax/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.staticiax import StaticIAX as RegisterIAX
from accent_dao.alchemy.trunkfeatures import TrunkFeatures
from accent_dao.helpers import errors
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin, SearchResult


class RegisterIAXPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = RegisterIAX

    def __init__(self, session, register_iax_search):
        self.session = session
        self.register_iax_search = register_iax_search

    def _find_query(self, criteria):
        query = self.session.query(RegisterIAX).filter(
            RegisterIAX.var_name == 'register'
        )
        return self.build_criteria(query, criteria)

    def get_by(self, criteria):
        model = self.find_by(criteria)
        if not model:
            raise errors.not_found('IAXRegister', **criteria)
        return model

    def search(self, parameters):
        rows, total = self.register_iax_search.search(self.session, parameters)
        return SearchResult(total, rows)

    def delete(self, register_iax):
        (
            self.session.query(TrunkFeatures)
            .filter(TrunkFeatures.register_iax_id == register_iax.id)
            .update({'registercommented': 0})
        )

        self.session.delete(register_iax)
        self.session.flush()

----------------------------------------

File: register_iax/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.staticiax import StaticIAX as RegisterIAX
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=RegisterIAX, columns={'id': RegisterIAX.id}, default_sort='id'
)


class RegisterIAXSearchSystem(SearchSystem):
    def search(self, session, parameters=None):
        query = session.query(self.config.table).filter(
            RegisterIAX.var_name == 'register'
        )
        return self.search_from_query(query, parameters)


register_iax_search = RegisterIAXSearchSystem(config)

----------------------------------------

File: sccp_general/__init__.py
Please review for update


----------------------------------------

File: sccp_general/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import SCCPGeneralPersistor


@daosession
def find_all(session):
    return SCCPGeneralPersistor(session).find_all()


@daosession
def edit_all(session, sccp_general):
    SCCPGeneralPersistor(session).edit_all(sccp_general)

----------------------------------------

File: sccp_general/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.sccpgeneralsettings import SCCPGeneralSettings


class SCCPGeneralPersistor:
    def __init__(self, session):
        self.session = session

    def find_all(self):
        query = self.session.query(SCCPGeneralSettings)
        return query.all()

    def edit_all(self, sccp_general):
        self.session.query(SCCPGeneralSettings).delete()
        self.session.add_all(sccp_general)
        self.session.flush()

----------------------------------------

File: schedule/__init__.py
Please review for update


----------------------------------------

File: schedule/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import SchedulePersistor
from .search import schedule_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return SchedulePersistor(session, schedule_search, tenant_uuids).search(parameters)


@daosession
def get(session, schedule_id, tenant_uuids=None):
    return SchedulePersistor(session, schedule_search, tenant_uuids).get_by(
        {'id': schedule_id}
    )


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return SchedulePersistor(session, schedule_search, tenant_uuids).get_by(criteria)


@daosession
def find(session, schedule_id, tenant_uuids=None):
    return SchedulePersistor(session, schedule_search, tenant_uuids).find_by(
        {'id': schedule_id}
    )


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return SchedulePersistor(session, schedule_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return SchedulePersistor(session, schedule_search, tenant_uuids).find_all_by(
        criteria
    )


@daosession
def create(session, schedule):
    return SchedulePersistor(session, schedule_search).create(schedule)


@daosession
def edit(session, schedule):
    SchedulePersistor(session, schedule_search).edit(schedule)


@daosession
def delete(session, schedule):
    SchedulePersistor(session, schedule_search).delete(schedule)
----------------------------------------

File: schedule/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.schedule import Schedule
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class SchedulePersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Schedule

    def __init__(self, session, schedule_search, tenant_uuids=None):
        self.session = session
        self.search_system = schedule_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(Schedule)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

----------------------------------------

File: schedule/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.schedule import Schedule
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Schedule,
    columns={'id': Schedule.id, 'name': Schedule.name, 'timezone': Schedule.timezone},
    default_sort='name',
)

schedule_search = SearchSystem(config)
----------------------------------------

File: skill/__init__.py
Please review for update


----------------------------------------

File: skill/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import SkillPersistor
from .search import skill_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return SkillPersistor(session, skill_search, tenant_uuids).search(parameters)


@daosession
def get(session, skill_id, tenant_uuids=None):
    return SkillPersistor(session, skill_search, tenant_uuids).get_by({'id': skill_id})


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return SkillPersistor(session, skill_search, tenant_uuids).get_by(criteria)


@daosession
def find(session, skill_id, tenant_uuids=None):
    return SkillPersistor(session, skill_search, tenant_uuids).find_by({'id': skill_id})


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return SkillPersistor(session, skill_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return SkillPersistor(session, skill_search, tenant_uuids).find_all_by(criteria)


@daosession
def create(session, skill):
    return SkillPersistor(session, skill_search).create(skill)


@daosession
def edit(session, skill):
    SkillPersistor(session, skill_search).edit(skill)


@daosession
def delete(session, skill):
    SkillPersistor(session, skill_search).delete(skill)

----------------------------------------

File: skill/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.queueskill import QueueSkill
from accent_dao.helpers import errors
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class SkillPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = QueueSkill

    def __init__(self, session, skill_search, tenant_uuids=None):
        self.session = session
        self.search_system = skill_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(QueueSkill)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def get_by(self, criteria):
        model = self.find_by(criteria)
        if not model:
            raise errors.not_found('Skill', **criteria)
        return model

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

    def create(self, skill):
        self.session.add(skill)
        self.session.flush()
        return skill

    def edit(self, skill):
        self.session.add(skill)
        self.session.flush()

----------------------------------------

File: skill/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.queueskill import QueueSkill
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=QueueSkill,
    columns={
        'id': QueueSkill.id,
        'name': QueueSkill.name,
        'description': QueueSkill.description,
    },
    default_sort='name',
)

skill_search = SearchSystem(config)

----------------------------------------

File: skill_rule/__init__.py
Please review for update


----------------------------------------

File: skill_rule/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import SkillRulePersistor
from .search import skill_rule_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return SkillRulePersistor(session, skill_rule_search, tenant_uuids).search(
        parameters
    )


@daosession
def get(session, skill_rule_id, tenant_uuids=None):
    return SkillRulePersistor(session, skill_rule_search, tenant_uuids).get_by(
        {'id': skill_rule_id}
    )


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return SkillRulePersistor(session, skill_rule_search, tenant_uuids).get_by(criteria)


@daosession
def find(session, skill_rule_id, tenant_uuids=None):
    return SkillRulePersistor(session, skill_rule_search, tenant_uuids).find_by(
        {'id': skill_rule_id}
    )


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return SkillRulePersistor(session, skill_rule_search, tenant_uuids).find_by(
        criteria
    )


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return SkillRulePersistor(session, skill_rule_search, tenant_uuids).find_all_by(
        criteria
    )


@daosession
def create(session, skill_rule):
    return SkillRulePersistor(session, skill_rule_search).create(skill_rule)


@daosession
def edit(session, skill_rule):
    SkillRulePersistor(session, skill_rule_search).edit(skill_rule)


@daosession
def delete(session, skill_rule):
    SkillRulePersistor(session, skill_rule_search).delete(skill_rule)

----------------------------------------

File: skill_rule/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.queueskillrule import QueueSkillRule
from accent_dao.helpers import errors
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class SkillRulePersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = QueueSkillRule

    def __init__(self, session, skill_rule_search, tenant_uuids=None):
        self.session = session
        self.search_system = skill_rule_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(QueueSkillRule)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def get_by(self, criteria):
        model = self.find_by(criteria)
        if not model:
            raise errors.not_found('SkillRule', **criteria)
        return model

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

----------------------------------------

File: skill_rule/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.queueskillrule import QueueSkillRule
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=QueueSkillRule,
    columns={
        'id': QueueSkillRule.id,
        'name': QueueSkillRule.name,
    },
    default_sort='name',
)

skill_rule_search = SearchSystem(config)
----------------------------------------

File: switchboard/__init__.py
Please review for update


----------------------------------------

File: switchboard/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import SwitchboardPersistor
from .search import switchboard_search


@daosession
def _persistor(session, tenant_uuids=None):
    return SwitchboardPersistor(session, switchboard_search, tenant_uuids=tenant_uuids)


def search(tenant_uuids=None, **parameters):
    return _persistor(tenant_uuids).search(parameters)


def get(switchboard_uuid, tenant_uuids=None):
    return _persistor(tenant_uuids).get_by({'uuid': str(switchboard_uuid)})


def get_by(tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).get_by(criteria)


def find(switchboard_uuid, tenant_uuids=None):
    return _persistor(tenant_uuids).find_by({'uuid': str(switchboard_uuid)})


def find_by(tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).find_by(criteria)


def find_all_by(tenant_uuids=None, **criteria):
    return _persistor(tenant_uuids).find_all_by(criteria)


def create(switchboard):
    return _persistor().create(switchboard)


def edit(switchboard):
    return _persistor().edit(switchboard)


def delete(switchboard):
    _persistor().delete(switchboard)

----------------------------------------

File: switchboard/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.switchboard import Switchboard
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class SwitchboardPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Switchboard

    def __init__(self, session, switchboard_search, tenant_uuids=None):
        self.session = session
        self.search_system = switchboard_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(Switchboard)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

----------------------------------------

File: switchboard/search.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql import and_, cast
from sqlalchemy.sql.sqltypes import String

from accent_dao.alchemy.dialaction import Dialaction
from accent_dao.alchemy.incall import Incall
from accent_dao.alchemy.switchboard import Switchboard
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Switchboard,
    columns={
        "name": Switchboard.name,
        "exten": Incall.exten,
    },
    search=[
        "name",
        "exten",
    ],
    sort=[
        "name",
    ],
    default_sort="name",
)


class SwitchboardSearchSystem(SearchSystem):
    def _search_on_extension(self, query):
        return (
            query.outerjoin(
                Dialaction,
                and_(
                    Dialaction.action == "switchboard",
                    Dialaction.actionarg1 == Switchboard.uuid,
                ),
            )
            .outerjoin(
                Incall,
                and_(
                    Dialaction.category == "incall",
                    Dialaction.categoryval == cast(Incall.id, String),
                    Incall.commented == 0,
                ),
            )
            .group_by(Switchboard)
        )

    def search_from_query(self, query, parameters):
        query = self._search_on_extension(query)
        return super().search_from_query(query, parameters)


switchboard_search = SwitchboardSearchSystem(config)
----------------------------------------

File: tenant/__init__.py
Please review for update


----------------------------------------

File: tenant/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import Persistor
from .search import tenant_search


@daosession
def find(session, resource_uuid, tenant_uuids=None):
    return Persistor(session, tenant_search, tenant_uuids).find_by(
        {'uuid': resource_uuid}
    )


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return Persistor(session, tenant_search, tenant_uuids).find_all_by(criteria)


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return Persistor(session, tenant_search, tenant_uuids).find_by(criteria)


@daosession
def get(session, resource_uuid, tenant_uuids=None):
    return Persistor(session, tenant_search, tenant_uuids).get_by(
        {'uuid': resource_uuid}
    )


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return Persistor(session, tenant_search, tenant_uuids).get_by(criteria)


@daosession
def search(session, tenant_uuids=None, **parameters):
    return Persistor(session, tenant_search, tenant_uuids).search(parameters)


@daosession
def edit(session, tenant):
    Persistor(session, tenant_search).edit(tenant)


@daosession
def delete(session, tenant):
    Persistor(session, tenant_search).delete(tenant)
----------------------------------------

File: tenant/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy import text

from accent_dao.alchemy.tenant import Tenant
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class Persistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Tenant

    def __init__(self, session, search, tenant_uuids=None):
        self.session = session
        self.search_system = search
        self.tenant_uuids = tenant_uuids

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

    def _find_query(self, criteria):
        query = self.session.query(Tenant)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _filter_tenant_uuid(self, query):
        if self.tenant_uuids is None:
            return query

        if not self.tenant_uuids:
            return query.filter(text('false'))

        return query.filter(Tenant.uuid.in_(self.tenant_uuids))

----------------------------------------

File: tenant/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.tenant import Tenant
from accent_dao.resources.utils.search import (
    SearchConfig,
    SearchSystem,
)

config = SearchConfig(
    table=Tenant,
    columns={
        'uuid': Tenant.uuid,
    },
    default_sort='uuid',
)

tenant_search = SearchSystem(config)
----------------------------------------

File: trunk/__init__.py
Please review for update


----------------------------------------

File: trunk/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession
from accent_dao.helpers.db_utils import flush_session

from .fixes import TrunkFixes
from .persistor import TrunkPersistor
from .search import trunk_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return TrunkPersistor(session, trunk_search, tenant_uuids).search(parameters)


@daosession
def get(session, trunk_id, tenant_uuids=None):
    return TrunkPersistor(session, trunk_search, tenant_uuids).get_by({'id': trunk_id})


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return TrunkPersistor(session, trunk_search, tenant_uuids).get_by(criteria)


@daosession
def find(session, trunk_id, tenant_uuids=None):
    return TrunkPersistor(session, trunk_search, tenant_uuids).find_by({'id': trunk_id})


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return TrunkPersistor(session, trunk_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return TrunkPersistor(session, trunk_search, tenant_uuids).find_all_by(criteria)


@daosession
def create(session, trunk):
    return TrunkPersistor(session, trunk_search).create(trunk)


@daosession
def edit(session, trunk):
    with flush_session(session):  # Maybe useless
        TrunkPersistor(session, trunk_search).edit(trunk)
        session.expire(trunk)
        TrunkFixes(session).fix(trunk.id)


@daosession
def delete(session, trunk):
    TrunkPersistor(session, trunk_search).delete(trunk)


@daosession
def associate_endpoint_sip(session, trunk, endpoint):
    TrunkPersistor(session, trunk_search).associate_endpoint_sip(trunk, endpoint)


@daosession
def dissociate_endpoint_sip(session, trunk, endpoint):
    TrunkPersistor(session, trunk_search).dissociate_endpoint_sip(trunk, endpoint)


@daosession
def associate_endpoint_iax(session, trunk, endpoint):
    TrunkPersistor(session, trunk_search).associate_endpoint_iax(trunk, endpoint)


@daosession
def dissociate_endpoint_iax(session, trunk, endpoint):
    TrunkPersistor(session, trunk_search).dissociate_endpoint_iax(trunk, endpoint)


@daosession
def associate_endpoint_custom(session, trunk, endpoint):
    TrunkPersistor(session, trunk_search).associate_endpoint_custom(trunk, endpoint)


@daosession
def dissociate_endpoint_custom(session, trunk, endpoint):
    TrunkPersistor(session, trunk_search).dissociate_endpoint_custom(trunk, endpoint)


@daosession
def associate_register_iax(session, trunk, register):
    TrunkPersistor(session, trunk_search).associate_register_iax(trunk, register)


@daosession
def dissociate_register_iax(session, trunk, register):
    TrunkPersistor(session, trunk_search).dissociate_register_iax(trunk, register)

----------------------------------------

File: trunk/fixes.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import Load

from accent_dao.alchemy.trunkfeatures import TrunkFeatures
from accent_dao.alchemy.usercustom import UserCustom
from accent_dao.alchemy.useriax import UserIAX


class TrunkFixes:
    def __init__(self, session):
        self.session = session

    def fix(self, trunk_id):
        row = self.get_row(trunk_id)
        self.fix_protocol(row)
        self.session.flush()

    def get_row(self, trunk_id):
        query = (
            self.session.query(TrunkFeatures, UserIAX, UserCustom)
            .outerjoin(TrunkFeatures.endpoint_sip)
            .outerjoin(TrunkFeatures.endpoint_iax)
            .outerjoin(TrunkFeatures.endpoint_custom)
            .options(
                Load(TrunkFeatures).load_only("id", "context"),
                Load(UserIAX).load_only("id", "category", "context"),
                Load(UserCustom).load_only("id", "category", "context"),
            )
            .filter(TrunkFeatures.id == trunk_id)
        )

        return query.first()

    def fix_protocol(self, row):
        if row.UserIAX:
            row.UserIAX.context = row.TrunkFeatures.context
            row.UserIAX.category = 'trunk'
        elif row.UserCustom:
            row.UserCustom.context = row.TrunkFeatures.context
            row.UserCustom.category = 'trunk'

----------------------------------------

File: trunk/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.endpoint_sip import EndpointSIP
from accent_dao.alchemy.staticiax import StaticIAX
from accent_dao.alchemy.trunkfeatures import TrunkFeatures as Trunk
from accent_dao.alchemy.usercustom import UserCustom
from accent_dao.alchemy.useriax import UserIAX
from accent_dao.helpers import errors
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class TrunkPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Trunk

    def __init__(self, session, trunk_search, tenant_uuids=None):
        self.session = session
        self.search_system = trunk_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(Trunk)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def get_by(self, criteria):
        model = self.find_by(criteria)
        if not model:
            raise errors.not_found('Trunk', **criteria)
        return model

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

    def delete(self, trunk):
        if trunk.endpoint_sip_uuid:
            (
                self.session.query(EndpointSIP)
                .filter(EndpointSIP.uuid == trunk.endpoint_sip_uuid)
                .delete()
            )
        elif trunk.endpoint_iax_id:
            (
                self.session.query(UserIAX)
                .filter(UserIAX.id == trunk.endpoint_iax_id)
                .delete()
            )
        elif trunk.endpoint_custom_id:
            (
                self.session.query(UserCustom)
                .filter(UserCustom.id == trunk.endpoint_custom_id)
                .delete()
            )

        if trunk.register_iax_id:
            (
                self.session.query(StaticIAX)
                .filter(StaticIAX.id == trunk.register_iax_id)
                .delete()
            )

        self.session.delete(trunk)
        self.session.flush()

    def associate_endpoint_sip(self, trunk, endpoint):
        if trunk.protocol not in ('sip', None):
            raise errors.resource_associated(
                'Trunk', 'Endpoint', trunk_id=trunk.id, protocol=trunk.protocol
            )
        trunk.endpoint_sip_uuid = endpoint.uuid
        self.session.flush()
        self.session.expire(trunk, ['endpoint_sip'])

    def dissociate_endpoint_sip(self, trunk, endpoint):
        if endpoint is trunk.endpoint_sip:
            trunk.endpoint_sip_uuid = None
            self.session.flush()
            self.session.expire(trunk, ['endpoint_sip'])

    def associate_endpoint_iax(self, trunk, endpoint):
        if trunk.protocol not in ('iax', None):
            raise errors.resource_associated(
                'Trunk', 'Endpoint', trunk_id=trunk.id, protocol=trunk.protocol
            )
        trunk.endpoint_iax_id = endpoint.id
        self.session.flush()
        self.session.expire(trunk, ['endpoint_iax'])

    def dissociate_endpoint_iax(self, trunk, endpoint):
        if endpoint is trunk.endpoint_iax:
            trunk.endpoint_iax_id = None
            self.session.flush()
            self.session.expire(trunk, ['endpoint_iax'])

    def associate_endpoint_custom(self, trunk, endpoint):
        if trunk.protocol not in ('custom', None):
            raise errors.resource_associated(
                'Trunk', 'Endpoint', trunk_id=trunk.id, protocol=trunk.protocol
            )
        trunk.endpoint_custom_id = endpoint.id
        self.session.flush()
        self.session.expire(trunk, ['endpoint_custom'])

    def dissociate_endpoint_custom(self, trunk, endpoint):
        if endpoint is trunk.endpoint_custom:
            trunk.endpoint_custom_id = None
            self.session.flush()
            self.session.expire(trunk, ['endpoint_custom'])

    def associate_register_iax(self, trunk, register):
        if trunk.protocol not in ('iax', None):
            raise errors.resource_associated(
                'Trunk', 'Endpoint', trunk_id=trunk.id, protocol=trunk.protocol
            )
        trunk.register_iax_id = register.id
        self.session.flush()
        self.session.expire(trunk, ['register_iax'])

    def dissociate_register_iax(self, trunk, register):
        if register is trunk.register_iax:
            trunk.register_iax_id = None
            self.session.flush()
            self.session.expire(trunk, ['register_iax'])

----------------------------------------

File: trunk/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.trunkfeatures import TrunkFeatures as Trunk
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Trunk,
    columns={
        'id': Trunk.id,
        'context': Trunk.context,
        'description': Trunk.description,
        'name': Trunk.name,
        'label': Trunk.label,
        'outgoing_caller_id_format': Trunk.outgoing_caller_id_format,
    },
    default_sort='id',
)

trunk_search = SearchSystem(config)

----------------------------------------

File: user/__init__.py
Please review for update


----------------------------------------

File: user/dao.py
Please review for update

# Copyright 2023 Accent Communications

from contextlib import contextmanager

from accent_dao.helpers.db_manager import Session
from accent_dao.resources.func_key_template.persistor import (
    build_persistor as build_template_persistor,
)
from accent_dao.resources.user.fixes import UserFixes
from accent_dao.resources.user.persistor import UserPersistor
from accent_dao.resources.user.search import user_search
from accent_dao.resources.user.view import user_view


def persistor(tenant_uuids=None):
    return UserPersistor(Session, user_view, user_search, tenant_uuids)


def search(**parameters):
    tenant_uuids = parameters.pop('tenant_uuids', None)
    return persistor(tenant_uuids).search(parameters)


def search_collated(**parameters):
    tenant_uuids = parameters.pop('tenant_uuids', None)
    return persistor(tenant_uuids).search_collated(parameters)


def get(user_id, tenant_uuids=None):
    return persistor(tenant_uuids).get_by({'id': user_id})


def get_by(tenant_uuids=None, **criteria):
    return persistor(tenant_uuids).get_by(criteria)


def find_by_id_uuid(id, tenant_uuids=None):
    return persistor(tenant_uuids).find_by_id_uuid(id)


def get_by_id_uuid(id, tenant_uuids=None):
    return persistor(tenant_uuids).get_by_id_uuid(id)


def find_all_by_agent_id(agent_id):
    return persistor().find_all_by_agent_id(agent_id)


def find(user_id):
    return persistor().find_by({'id': user_id})


def find_by(**criteria):
    return persistor().find_by(criteria)


def find_all_by(**criteria):
    return persistor().find_all_by(criteria)


def count_all_by(column_name, **criteria):
    return persistor().count_all_by(column_name, criteria)


def create(user):
    return persistor().create(user)


def edit(user):
    persistor().edit(user)
    UserFixes(Session).fix(user.id)


def delete(user):
    persistor().delete(user)
    template_persistor = build_template_persistor(Session)
    template_persistor.delete(user.func_key_template_private)


def associate_all_groups(user, groups):
    persistor().associate_all_groups(user, groups)


def list_outgoing_callerid_associated(user_id):
    return persistor().list_outgoing_callerid_associated(user_id)


@contextmanager
def query_options(*options):
    with UserPersistor.context_query_options(*options):
        yield

----------------------------------------

File: user/fixes.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.user_line import UserLine
from accent_dao.resources.line.fixes import LineFixes


class UserFixes:
    def __init__(self, session):
        self.session = session

    def fix(self, user_id):
        self.fix_lines(user_id)
        self.session.flush()

    def fix_lines(self, user_id):
        user_lines = self.find_user_line(user_id)
        for user_line in user_lines:
            LineFixes(self.session).fix(user_line.line_id)

    def find_user_line(self, user_id):
        return (
            self.session.query(UserLine.line_id)
            .filter(UserLine.main_user == True)  # noqa
            .filter(UserLine.user_id == user_id)
            .all()
        )

----------------------------------------

File: user/model.py
Please review for update

# Copyright 2023 Accent Communications


class UserDirectory:
    def __init__(
        self,
        id,
        uuid,
        line_id,
        agent_id,
        firstname,
        lastname,
        exten,
        email,
        mobile_phone_number,
        voicemail_number,
        userfield,
        description,
        context,
    ):
        self.id = id
        self.uuid = uuid
        self.line_id = line_id
        self.agent_id = agent_id
        self.firstname = firstname
        self.lastname = lastname
        self.exten = exten
        self.email = email
        self.mobile_phone_number = mobile_phone_number
        self.voicemail_number = voicemail_number
        self.userfield = userfield
        self.description = description
        self.context = context

    def __eq__(self, other):
        return self.__dict__ == other.__dict__


class UserSummary:
    def __init__(
        self,
        id,
        uuid,
        firstname,
        lastname,
        email,
        enabled,
        provisioning_code,
        protocol,
        extension,
        context,
    ):
        self.id = id
        self.uuid = uuid
        self.firstname = firstname
        self.lastname = lastname
        self.email = email
        self.enabled = enabled
        self.provisioning_code = provisioning_code
        self.protocol = protocol
        self.extension = extension
        self.context = context

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

----------------------------------------

File: user/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql import cast, func
from sqlalchemy.sql.expression import and_, literal_column
from sqlalchemy.types import String

from accent_dao.alchemy.dialaction import Dialaction
from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.func_key_template import FuncKeyTemplate
from accent_dao.alchemy.incall import Incall
from accent_dao.alchemy.userfeatures import UserFeatures as User
from accent_dao.helpers import errors
from accent_dao.helpers.db_manager import Session
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.query_options import QueryOptionsMixin
from accent_dao.resources.utils.search import CriteriaBuilderMixin, SearchResult


class UserPersistor(QueryOptionsMixin, CriteriaBuilderMixin, BasePersistor):
    _search_table = User

    def __init__(self, session, user_view, user_search, tenant_uuids=None):
        self.session = session
        self.user_view = user_view
        self.user_search = user_search
        self.tenant_uuids = tenant_uuids

    def find_by_id_uuid(self, id):
        query = self.session.query(User)
        if isinstance(id, int):
            query = query.filter_by(id=id)
        else:
            id = str(id)
            if id.isdigit():
                query = query.filter_by(id=int(id))
            else:
                query = query.filter_by(uuid=id)
        if self.tenant_uuids is not None:
            query = query.filter(User.tenant_uuid.in_(self.tenant_uuids))
        return query.first()

    def get_by_id_uuid(self, id):
        user = self.find_by_id_uuid(id)
        if not user:
            raise errors.not_found('User', id=id)
        return user

    def find_all_by_agent_id(self, agent_id):
        return self.session.query(User).filter(User.agent.has(id=agent_id)).all()

    def _find_query(self, criteria):
        query = self.session.query(User)
        if self.tenant_uuids is not None:
            query = query.filter(User.tenant_uuid.in_(self.tenant_uuids))
        return self.build_criteria(query, criteria)

    def count_all_by(self, column_name, criteria):
        column = self._get_column(column_name)
        query = self.session.query(column, func.count(column).label('count'))
        query = self.build_criteria(query, criteria)
        query = query.group_by(column)
        return query.all()

    def _search(self, parameters, is_collated=False):
        view = self.user_view.select(
            parameters.get('view'),
            default_query=self._generate_query(),
        )
        query = view.query(self.session)
        if self.tenant_uuids is not None:
            query = query.filter(User.tenant_uuid.in_(self.tenant_uuids))
        if not is_collated:
            rows, total = self.user_search.search_from_query(query, parameters)
        else:
            rows, total = self.user_search.search_from_query_collated(query, parameters)
        users = view.convert_list(rows)
        return SearchResult(total, users)

    def search(self, parameters):
        return self._search(parameters)

    def search_collated(self, parameters):
        return self._search(parameters, is_collated=True)

    def create(self, user):
        self.prepare_template(user)
        user.fill_caller_id()

        self.session.add(user)
        self.session.flush()

        return user

    def prepare_template(self, user):
        if not user.func_key_private_template_id:
            template = FuncKeyTemplate(tenant_uuid=user.tenant_uuid, private=True)
            user.func_key_template_private = template

    def associate_all_groups(self, user, groups):
        with Session.no_autoflush:
            user.groups = groups
            for member in user.group_members:
                member.user = user
                member.fix()
        self.session.flush()

    def list_outgoing_callerid_associated(self, user_id):
        query = (
            self.session.query(
                Extension.exten.label('number'),
                literal_column("'associated'").label('type'),
            )
            .select_from(Incall)
            .join(
                Dialaction,
                and_(
                    Dialaction.category == 'incall',
                    Dialaction.categoryval == cast(Incall.id, String),
                ),
            )
            .join(
                Extension,
                and_(
                    Extension.type == 'incall',
                    Extension.typeval == cast(Incall.id, String),
                ),
            )
            .filter(
                and_(
                    Dialaction.action == 'user',
                    Dialaction.actionarg1 == str(user_id),
                )
            )
        )
        return query.all()

----------------------------------------

File: user/search.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql import and_, or_

from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.line_extension import LineExtension
from accent_dao.alchemy.linefeatures import LineFeatures
from accent_dao.alchemy.user_line import UserLine
from accent_dao.alchemy.userfeatures import UserFeatures
from accent_dao.alchemy.voicemail import Voicemail
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=UserFeatures,
    columns={
        'id': UserFeatures.id,
        'uuid': UserFeatures.uuid,
        'firstname': UserFeatures.firstname,
        'lastname': UserFeatures.lastname,
        'fullname': (UserFeatures.firstname + " " + UserFeatures.lastname),
        'caller_id': UserFeatures.callerid,
        'description': UserFeatures.description,
        'userfield': UserFeatures.userfield,
        'email': UserFeatures.email,
        'mobile_phone_number': UserFeatures.mobilephonenumber,
        'music_on_hold': UserFeatures.musiconhold,
        'outgoing_caller_id': UserFeatures.outcallerid,
        'preprocess_subroutine': UserFeatures.preprocess_subroutine,
        'voicemail_number': Voicemail.mailbox,
        'provisioning_code': LineFeatures.provisioning_code,
        'exten': Extension.exten,
        'extension': Extension.exten,
        'context': Extension.context,
        'username': UserFeatures.loginclient,
        'enabled': UserFeatures.enabled,
    },
    search=[
        'fullname',
        'caller_id',
        'description',
        'userfield',
        'email',
        'mobile_phone_number',
        'preprocess_subroutine',
        'outgoing_caller_id',
        'exten',
        'username',
        'provisioning_code',
    ],
    default_sort='lastname',
)


class UserSearchSystem(SearchSystem):
    def search_from_query(self, query, parameters):
        if 'uuid' in parameters and isinstance(parameters['uuid'], str):
            uuids = parameters.pop('uuid').split(',')
            query = self._filter_exact_match_uuids(query, uuids)

        if 'exten' in parameters and isinstance(parameters['exten'], str):
            extens = parameters.pop('exten').split(',')
            query = self._filter_exact_match_extens(query, extens)

        if 'mobile_phone_number' in parameters and isinstance(
            parameters['mobile_phone_number'], str
        ):
            extens = parameters.pop('mobile_phone_number').split(',')
            query = self._filter_exact_match_mobile_phone_numbers(query, extens)

        query = self._search_on_extension(query)
        return super().search_from_query(query, parameters)

    def _filter_exact_match_uuids(self, query, uuids):
        column = self.config.column_for_searching('uuid')
        return query.filter(or_(column == uuid for uuid in uuids))

    def _filter_exact_match_extens(self, query, extens):
        column = self.config.column_for_searching('exten')
        return query.filter(or_(column == exten for exten in extens))

    def _filter_exact_match_mobile_phone_numbers(self, query, extens):
        column = self.config.column_for_searching('mobile_phone_number')
        return query.filter(or_(column == exten for exten in extens))

    def _search_on_extension(self, query):
        return (
            query.outerjoin(
                UserLine,
                and_(
                    UserLine.user_id == UserFeatures.id,
                    UserLine.main_line == True,  # noqa
                ),
            )
            .outerjoin(
                LineFeatures,
                and_(LineFeatures.id == UserLine.line_id, LineFeatures.commented == 0),
            )
            .outerjoin(LineExtension, UserLine.line_id == LineExtension.line_id)
            .outerjoin(
                Extension,
                and_(
                    LineExtension.extension_id == Extension.id,
                    LineExtension.main_extension == True,  # noqa
                    Extension.commented == 0,
                ),
            )
            .outerjoin(
                Voicemail,
                and_(
                    UserFeatures.voicemailid == Voicemail.uniqueid,
                    Voicemail.commented == 0,
                ),
            )
        )


user_search = UserSearchSystem(config)

----------------------------------------

File: user/strategy.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.orm import joinedload, lazyload, selectinload

user_unpaginated_strategy = (
    joinedload('agent'),
    joinedload('rightcall_members').selectinload('rightcall'),
    joinedload('group_members')
    .selectinload('group')
    .selectinload('call_pickup_interceptor_pickups')
    .options(
        selectinload('pickupmember_user_targets').selectinload('user'),
        selectinload('pickupmember_group_targets')
        .selectinload('group')
        .selectinload('user_queue_members')
        .selectinload('user'),
    ),
    joinedload('call_pickup_interceptor_pickups').options(
        selectinload('pickupmember_user_targets').selectinload('user'),
        selectinload('pickupmember_group_targets')
        .selectinload('group')
        .selectinload('user_queue_members')
        .selectinload('user'),
    ),
    joinedload('user_dialactions').selectinload('user'),
    joinedload('incall_dialactions').selectinload('incall').selectinload('extensions'),
    joinedload('user_lines').options(
        selectinload('line').options(
            selectinload('application'),
            selectinload('context_rel'),
            selectinload('endpoint_sip').options(
                selectinload('_endpoint_section').selectinload('_options'),
                selectinload('_auth_section').selectinload('_options'),
            ),
            selectinload('endpoint_sccp'),
            selectinload('endpoint_custom'),
            selectinload('line_extensions').selectinload('extension'),
            selectinload('user_lines').selectinload('user'),
        ),
    ),
    joinedload('queue_members'),
    joinedload('schedule_paths').selectinload('schedule'),
    joinedload('switchboard_member_users').selectinload('switchboard'),
    joinedload('tenant'),
    joinedload('voicemail'),
    lazyload('*'),
)


no_strategy = []

----------------------------------------

File: user/view.py
Please review for update

# Copyright 2023 Accent Communications

from sqlalchemy.sql import case, func

from accent_dao.alchemy.extension import Extension
from accent_dao.alchemy.linefeatures import LineFeatures as Line
from accent_dao.alchemy.user_line import UserLine
from accent_dao.alchemy.userfeatures import UserFeatures as User
from accent_dao.alchemy.voicemail import Voicemail
from accent_dao.helpers import errors
from accent_dao.resources.user.model import UserDirectory, UserSummary
from accent_dao.resources.utils.view import View, ViewSelector


class DefaultView(View):
    def __init__(self, query=None):
        self._query = query

    def query(self, session):
        if self._query:
            return self._query
        else:
            return session.query(User)

    def convert(self, row):
        return row


class DirectoryView(View):
    def query(self, session):
        query = session.query(
            User.id.label('id'),
            User.uuid.label('uuid'),
            UserLine.line_id.label('line_id'),
            User.agentid.label('agent_id'),
            User.firstname.label('firstname'),
            func.nullif(User.lastname, '').label('lastname'),
            func.nullif(User.email, '').label('email'),
            func.nullif(User.mobilephonenumber, '').label('mobile_phone_number'),
            Voicemail.mailbox.label('voicemail_number'),
            func.nullif(User.userfield, '').label('userfield'),
            func.nullif(User.description, '').label('description'),
            Extension.exten.label('exten'),
            Extension.context.label('context'),
        )
        return query

    def convert(self, row):
        return UserDirectory(
            id=row.id,
            uuid=row.uuid,
            line_id=row.line_id,
            agent_id=row.agent_id,
            firstname=row.firstname,
            lastname=row.lastname,
            email=row.email,
            mobile_phone_number=row.mobile_phone_number,
            voicemail_number=row.voicemail_number,
            exten=row.exten,
            userfield=row.userfield,
            description=row.description,
            context=row.context,
        )


class SummaryView(View):
    def query(self, session):
        query = session.query(
            User.id.label('id'),
            User.uuid.label('uuid'),
            User.firstname.label('firstname'),
            func.nullif(User.lastname, '').label('lastname'),
            func.nullif(User.email, '').label('email'),
            User.enabled.label('enabled'),
            case(
                [(Line.endpoint_custom_id.is_(None), Line.provisioning_code)],
                else_=None,
            ).label('provisioning_code'),
            Line.protocol.label('protocol'),
            Extension.exten.label('extension'),
            Extension.context.label('context'),
        )
        return query

    def convert(self, row):
        return UserSummary(
            id=row.id,
            uuid=row.uuid,
            firstname=row.firstname,
            lastname=row.lastname,
            email=row.email,
            enabled=row.enabled,
            provisioning_code=row.provisioning_code,
            protocol=row.protocol,
            extension=row.extension,
            context=row.context,
        )


class UserViewSelector(ViewSelector):
    def select(self, name=None, default_query=None):
        if not name:
            if default_query:
                return DefaultView(default_query)
            else:
                return self.default
        if name not in self.views:
            raise errors.invalid_view(name)
        return self.views[name]


user_view = UserViewSelector(
    default=DefaultView(), directory=DirectoryView(), summary=SummaryView()
)

----------------------------------------

File: user_call_permission/__init__.py
Please review for update


----------------------------------------

File: user_call_permission/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import Session
from accent_dao.resources.user_call_permission.persistor import Persistor


def persistor():
    return Persistor(Session)


def get_by(**criteria):
    return persistor().get_by(**criteria)


def find_by(**criteria):
    return persistor().find_by(**criteria)


def find_all_by(**criteria):
    return persistor().find_all_by(**criteria)


def associate(user, call_permission):
    return persistor().associate_user_call_permission(user, call_permission)


def dissociate(user, call_permission):
    return persistor().dissociate_user_call_permission(user, call_permission)


def dissociate_all_by_user(user):
    return persistor().dissociate_all_call_permissions_by_user(user)

----------------------------------------

File: user_call_permission/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.rightcallmember import RightCallMember as UserCallPermission
from accent_dao.helpers import errors
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class Persistor(CriteriaBuilderMixin):
    _search_table = UserCallPermission

    def __init__(self, session):
        self.session = session

    def find_by(self, **criteria):
        query = self._find_query(criteria)
        return query.first()

    def _find_query(self, criteria):
        query = self.session.query(UserCallPermission).filter(
            UserCallPermission.type == 'user'
        )
        return self.build_criteria(query, criteria)

    def get_by(self, **criteria):
        user_call_permission = self.find_by(**criteria)
        if not user_call_permission:
            raise errors.not_found('UserCallPermission', **criteria)
        return user_call_permission

    def find_all_by(self, **criteria):
        query = self._find_query(criteria)
        return query.all()

    def associate_user_call_permission(self, user, call_permission):
        user_call_permission = self.find_by(
            user_id=user.id, call_permission_id=call_permission.id
        )
        if not user_call_permission:
            user_call_permission = UserCallPermission(
                user_id=user.id, call_permission_id=call_permission.id
            )
            self.session.add(user_call_permission)
            self.session.flush()
        return user_call_permission

    def dissociate_user_call_permission(self, user, call_permission):
        user_call_permission = self.find_by(
            user_id=user.id, call_permission_id=call_permission.id
        )
        if user_call_permission:
            self.session.delete(user_call_permission)
            self.session.flush()
        return user_call_permission

    def dissociate_all_call_permissions_by_user(self, user):
        user_call_permissions = self.find_all_by(user_id=user.id)
        for user_call_permission in user_call_permissions:
            self.session.delete(user_call_permission)
        self.session.flush()
        return user_call_permissions

----------------------------------------

File: user_external_app/__init__.py
Please review for update


----------------------------------------

File: user_external_app/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import Session


from .persistor import UserExternalAppPersistor
from .search import user_external_app_search


def _persistor():
    return UserExternalAppPersistor(Session, user_external_app_search)


def search(user_uuid, **parameters):
    return _persistor().search(user_uuid, parameters)


def get(user_uuid, external_app_name):
    return _persistor().get_by(user_uuid, {'name': external_app_name})


def get_by(user_uuid, **criteria):
    return _persistor().get_by(user_uuid, criteria)


def find(user_uuid, external_app_name):
    return _persistor().find_by(user_uuid, {'name': external_app_name})


def find_by(user_uuid, **criteria):
    return _persistor().find_by(user_uuid, criteria)


def find_all_by(user_uuid, **criteria):
    return _persistor().find_all_by(user_uuid, criteria)


def create(external_app):
    return _persistor().create(external_app)


def edit(external_app):
    _persistor().edit(external_app)


def delete(external_app):
    _persistor().delete(external_app)

----------------------------------------

File: user_external_app/persistor.py
Please review for update

# Copyright 2023 Accent Communications


from accent_dao.alchemy.user_external_app import UserExternalApp
from accent_dao.helpers import errors
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin, SearchResult


class UserExternalAppPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = UserExternalApp

    def __init__(self, session, user_external_app_search):
        self.session = session
        self.user_external_app_search = user_external_app_search

    def find_by(self, user_uuid, criteria):
        query = self._find_query(user_uuid, criteria)
        return query.first()

    def _find_query(self, user_uuid, criteria):
        query = self.session.query(UserExternalApp)
        query = query.filter(UserExternalApp.user_uuid == user_uuid)
        return self.build_criteria(query, criteria)

    def get_by(self, user_uuid, criteria):
        external_app = self.find_by(user_uuid, criteria)
        if not external_app:
            criteria['user_uuid'] = user_uuid
            raise errors.not_found('UserExternalApp', **criteria)
        return external_app

    def find_all_by(self, user_uuid, criteria):
        query = self._find_query(user_uuid, criteria)
        return query.all()

    def search(self, user_uuid, parameters):
        query = self.session.query(self.user_external_app_search.config.table)
        query = query.filter(UserExternalApp.user_uuid == user_uuid)
        rows, total = self.user_external_app_search.search_from_query(query, parameters)
        return SearchResult(total, rows)

----------------------------------------

File: user_external_app/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.user_external_app import UserExternalApp
from accent_dao.resources.utils.search import SearchSystem
from accent_dao.resources.utils.search import SearchConfig


config = SearchConfig(
    table=UserExternalApp,
    columns={'name': UserExternalApp.name},
    default_sort='name',
)

user_external_app_search = SearchSystem(config)

----------------------------------------

File: user_line/__init__.py
Please review for update


----------------------------------------

File: user_line/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import Session
from accent_dao.resources.user_line.persistor import Persistor


def persistor():
    return Persistor(Session, 'UserLine')


def get_by(**criteria):
    return persistor().get_by(**criteria)


def find_by(**criteria):
    return persistor().find_by(**criteria)


def find_all_by(**criteria):
    return persistor().find_all_by(**criteria)


def find_all_by_user_id(user_id):
    return find_all_by(user_id=user_id)


def find_all_by_line_id(line_id):
    return find_all_by(line_id=line_id)


def find_main_user_line(line_id):
    return find_by(line_id=line_id, main_user=True)


def associate(user, line):
    return persistor().associate_user_line(user, line)


def dissociate(user, line):
    return persistor().dissociate_user_line(user, line)


def associate_all_lines(user, lines):
    return persistor().associate_all_lines(user, lines)

----------------------------------------

File: user_line/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.queuemember import QueueMember
from accent_dao.alchemy.user_line import UserLine
from accent_dao.helpers import errors
from accent_dao.resources.extension.fixes import ExtensionFixes
from accent_dao.resources.line.fixes import LineFixes
from accent_dao.resources.line_extension import dao as line_extension_dao
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class Persistor(CriteriaBuilderMixin):
    _search_table = UserLine

    def __init__(self, session, resource):
        self.session = session
        self.resource = resource

    def find_query(self, criteria):
        query = self.session.query(UserLine)
        return self.build_criteria(query, criteria)

    def find_by(self, **criteria):
        return self.find_query(criteria).first()

    def get_by(self, **criteria):
        user_line = self.find_by(**criteria)
        if not user_line:
            raise errors.not_found(self.resource, **criteria)
        return user_line

    def find_all_by(self, **criteria):
        return self.find_query(criteria).all()

    def associate_user_line(self, user, line):
        user_line = self.find_by(user_id=user.id, line_id=line.id)
        if user_line:
            return user_line

        main_user_line = self.find_by(main_user=True, line_id=line.id)
        user_main_line = self.find_by(main_line=True, user_id=user.id)

        user_line = UserLine(
            user_id=user.id,
            line_id=line.id,
            main_line=(False if user_main_line else True),
            main_user=(False if main_user_line else True),
        )

        self.session.add(user_line)
        self.session.flush()
        self.fix_associations(user_line)

        return user_line

    def dissociate_user_line(self, user, line):
        user_line = self.find_by(user_id=user.id, line_id=line.id)
        if not user_line:
            return

        self.delete_queue_member(user_line, line)

        if user_line.main_line:
            self._set_oldest_main_line(user)

        self.session.delete(user_line)
        self.session.flush()
        self.fix_associations(user_line)

        return user_line

    def delete_queue_member(self, user_line, line):
        if line.endpoint_sip:
            interface = f'PJSIP/{line.endpoint_sip.name}'
        elif line.endpoint_sccp:
            interface = f'SCCP/{line.endpoint_sccp.name}'
        elif line.endpoint_custom:
            interface = line.endpoint_custom.interface
        else:
            return

        (
            self.session.query(QueueMember)
            .filter(QueueMember.usertype == 'user')
            .filter(QueueMember.userid == user_line.user_id)
            .filter(QueueMember.interface == interface)
            .delete()
        )

    def _set_oldest_main_line(self, user):
        oldest_user_line = (
            self.session.query(UserLine)
            .filter(UserLine.user_id == user.id)
            .filter(UserLine.main_line == False)  # noqa
            .order_by(UserLine.line_id.asc())
            .first()
        )
        if oldest_user_line:
            oldest_user_line.main_line = True
            self.session.add(oldest_user_line)

    def fix_associations(self, user_line):
        line_extension = line_extension_dao.find_by(line_id=user_line.line_id)
        if line_extension:
            ExtensionFixes(self.session).fix_extension(line_extension.extension_id)

        LineFixes(self.session).fix(user_line.line_id)

    def associate_all_lines(self, user, lines):
        # Do this only to execute dissociation's fixes
        for existing_line in user.lines:
            if existing_line not in lines:
                self.dissociate_user_line(user, existing_line)

        user.lines = lines

        for user_line in user.user_lines:
            main_user_line = self.find_by(main_user=True, line_id=user_line.line.id)
            if not main_user_line:
                user_line.main_user = True

        self.session.flush()
        for user_line in user.user_lines:
            self.fix_associations(user_line)

        return user.user_lines

----------------------------------------

File: user_voicemail/__init__.py
Please review for update


----------------------------------------

File: user_voicemail/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.userfeatures import UserFeatures as UserSchema
from accent_dao.helpers import errors
from accent_dao.helpers.db_manager import daosession
from accent_dao.helpers.db_utils import flush_session

COLUMNS = {'user_id': UserSchema.id, 'voicemail_id': UserSchema.voicemailid}


def find_query(session, criteria):
    query = (
        session.query(
            UserSchema.id.label('user_id'),
            UserSchema.uuid.label('user_uuid'),
            UserSchema.voicemailid.label('voicemail_id'),
            UserSchema.enablevoicemail,
        )
        .filter(UserSchema.voicemailid != None)  # noqa
        .filter(UserSchema.voicemailid != 0)
    )
    for name, value in criteria.items():
        column = COLUMNS.get(name)
        if not column:
            raise errors.unknown(column)
        query = query.filter(column == value)
    return query


@daosession
def find_by(session, **criteria):
    query = find_query(session, criteria)
    return query.first()


def get_by(**criteria):
    user_voicemail = find_by(**criteria)
    if not user_voicemail:
        raise errors.not_found('UserVoicemail', **criteria)
    return user_voicemail


@daosession
def find_all_by(session, **criteria):
    query = find_query(session, criteria)
    return query.all()


def get_by_user_id(user_id):
    return get_by(user_id=user_id)


def find_by_user_id(user_id):
    return find_by(user_id=user_id)


def find_all_by_voicemail_id(voicemail_id):
    return find_all_by(voicemail_id=voicemail_id)


@daosession
def associate(session, user, voicemail):
    with flush_session(session):
        user.voicemailid = voicemail.id
        user.enablevoicemail = 1
        session.add(user)


@daosession
def dissociate(session, user, voicemail):
    with flush_session(session):
        if user.voicemail is voicemail:
            user.voicemailid = None
            user.enablevoicemail = 0
            session.add(user)

----------------------------------------

File: utils/__init__.py
Please review for update


----------------------------------------

File: utils/query_options.py
Please review for update

# Copyright 2023 Accent Communications

from __future__ import annotations

from contextlib import contextmanager
from contextvars import ContextVar

# Note: Proper interface for loader strategy are implemented in SQLAlchemy >= 1.4
from sqlalchemy.orm.query import Query
from sqlalchemy.orm.strategy_options import Load, loader_option


class QueryOptionsMixin:
    __ctx_query_options: ContextVar[tuple[Load | loader_option] | None] = ContextVar(
        'query_options', default=None
    )

    def _generate_query(self) -> Query:
        query = self.session.query(self._search_table)
        options = self.__ctx_query_options.get()
        if options:
            query = query.options(*options)
        return query

    @classmethod
    @contextmanager
    def context_query_options(cls, *options: Load | loader_option):
        memento = cls.__ctx_query_options.set(options)
        try:
            yield
        finally:
            cls.__ctx_query_options.reset(memento)

----------------------------------------

File: utils/search.py
Please review for update

# Copyright 2023 Accent Communications
from __future__ import annotations

import unicodedata
from typing import Any, NamedTuple

import sqlalchemy as sa
from sqlalchemy import sql
from sqlalchemy.sql.functions import ReturnTypeFromArgs
from sqlalchemy.types import Integer
from unidecode import unidecode

from accent_dao.helpers import errors


class SearchResult(NamedTuple):
    total: int
    items: list[Any]


class unaccent(ReturnTypeFromArgs):
    pass


class CriteriaBuilderMixin:
    def build_criteria(self, query, criteria):
        for name, value in criteria.items():
            column = self._get_column(name)
            query = query.filter(column == value)
        return query

    def _get_column(self, name):
        column = getattr(self._search_table, name, None)
        if column is None:
            raise errors.unknown(name)
        return column


class SearchConfig:
    def __init__(self, table, columns, default_sort, search=None, sort=None):
        self.table = table
        self._columns = columns
        self._default_sort = default_sort
        self._search = search
        self._sort = sort

    def all_search_columns(self):
        if self._search:
            return [self._columns[s] for s in self._search]
        return list(self._columns.values())

    def column_for_searching(self, column_name):
        return self._columns.get(column_name)

    def column_for_sorting(self, name=None):
        column_name = self._get_sort_column_name(name)
        return self._columns[column_name]

    def _get_sort_column_name(self, name=None):
        name = name or self._default_sort
        sort_columns = self._sort or self._columns.keys()

        if name not in sort_columns:
            raise errors.invalid_ordering(name)

        return name


class SearchSystem:
    SORT_DIRECTIONS = {  # noqa: RUF012
        'asc': sql.asc,
        'desc': sql.desc,
    }

    DEFAULTS = {  # noqa: RUF012
        'search': None,
        'order': None,
        'direction': 'asc',
        'limit': None,
        'offset': 0,
    }

    def __init__(self, config):
        self.config = config

    def search(self, session, parameters=None):
        query = session.query(self.config.table)
        return self.search_from_query(query, parameters)

    def search_collated(self, session, parameters=None):
        query = session.query(self.config.table)
        return self.search_from_query_collated(query, parameters)

    def search_from_query(self, query, parameters=None):
        parameters = self._populate_parameters(parameters)
        self._validate_parameters(parameters)
        query = self._filter(query, parameters['search'])
        query = self._filter_exact_match(query, parameters)
        sorted_query = self._sort(query, parameters['order'], parameters['direction'])
        paginated_query = self._paginate(
            sorted_query, parameters['limit'], parameters['offset']
        )

        return paginated_query.all(), sorted_query.count()

    def search_from_query_collated(self, query, parameters=None):
        parameters, order, limit, offset, reverse = self._extract_search_params(
            parameters
        )
        rows, total = self.search_from_query(query, parameters)
        return self._apply_search_params(rows, order, limit, offset, reverse), total

    def _populate_parameters(self, parameters=None):
        new_params = dict(self.DEFAULTS)
        if parameters:
            parameters.setdefault('offset', self.DEFAULTS['offset'])
            new_params.update(parameters)

        return new_params

    def _validate_parameters(self, parameters):
        if parameters['offset'] < 0:
            raise errors.wrong_type('offset', 'positive number')

        if parameters['limit'] is not None and parameters['limit'] <= 0:
            raise errors.wrong_type('limit', 'positive number')

        if parameters['direction'] not in self.SORT_DIRECTIONS.keys():
            raise errors.invalid_direction(parameters['direction'])

    def _filter(self, query, term=None):
        if not term:
            return query

        criteria = []
        for column in self.config.all_search_columns():
            clean_term = unidecode(term)
            expression = unaccent(sql.cast(column, sa.String)).ilike(f'%{clean_term}%')
            criteria.append(expression)

        query = query.filter(sql.or_(*criteria))
        return query

    def _filter_exact_match(self, query, parameters):
        for column_name, value in parameters.items():
            column = self.config.column_for_searching(column_name)
            if column is not None:
                if isinstance(column.type, Integer) and not self._represents_int(value):
                    return query.filter(False)
                query = query.filter(column == value)

        return query

    def _represents_int(self, value):
        try:
            int(value)
            return True
        except ValueError:
            return False

    def _sort(self, query, order=None, direction='asc'):
        column = self.config.column_for_sorting(order)
        direction = self.SORT_DIRECTIONS[direction]

        return query.order_by(direction(column))

    def _paginate(self, query, limit=None, offset=0):
        if offset > 0:
            query = query.offset(offset)

        if limit:
            query = query.limit(limit)

        return query

    def _extract_search_params(self, parameters):
        parameters = self._populate_parameters(parameters)
        self._validate_parameters(parameters)
        self.config.column_for_sorting(parameters['order'])

        order = parameters.pop('order', None)
        limit = parameters.pop('limit', None)
        offset = parameters.pop('offset', 0)
        reverse = False if parameters.pop('direction', 'asc') == 'asc' else True
        return parameters, order, limit, offset, reverse

    def _apply_search_params(self, rows, order, limit, offset, reverse):
        def _get_attr(o):
            a = getattr(o, order, '')
            return str(a) if a is not None else ''

        if order:
            rows = sorted(
                rows,
                key=lambda x: (
                    _get_attr(x) == '',
                    unicodedata.normalize('NFKD', _get_attr(x)),
                ),
                reverse=reverse,
            )
        elif reverse:
            rows.reverse()

        if not limit:
            return rows[offset:]
        else:
            return rows[offset : offset + limit]

----------------------------------------

File: utils/view.py
Please review for update

# Copyright 2023 Accent Communications

import abc

from accent_dao.helpers import errors


class ViewSelector:
    def __init__(self, default, **views):
        self.default = default
        self.views = views

    def select(self, name=None):
        if name is None:
            return self.default
        if name not in self.views:
            raise errors.invalid_view(name)
        return self.views[name]


class View(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def query(self, session):
        return

    @abc.abstractmethod
    def convert(self, row):
        return

    def convert_list(self, rows):
        return [self.convert(row) for row in rows]


class ModelView(View):
    @property
    @abc.abstractmethod
    def table(self):
        return

    @property
    @abc.abstractmethod
    def db_converter(self):
        return

    def query(self, session):
        return session.query(self.table)

    def convert(self, row):
        return self.db_converter.to_model(row)
----------------------------------------

File: voicemail/__init__.py
Please review for update


----------------------------------------

File: voicemail/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import VoicemailPersistor
from .search import voicemail_search


@daosession
def search(session, tenant_uuids=None, **parameters):
    return VoicemailPersistor(session, voicemail_search, tenant_uuids).search(
        parameters
    )


@daosession
def get(session, voicemail_id, tenant_uuids=None):
    return VoicemailPersistor(session, voicemail_search, tenant_uuids).get_by(
        {'id': voicemail_id}
    )


@daosession
def get_by(session, tenant_uuids=None, **criteria):
    return VoicemailPersistor(session, voicemail_search, tenant_uuids).get_by(criteria)


@daosession
def find(session, voicemail_id, tenant_uuids=None):
    return VoicemailPersistor(session, voicemail_search, tenant_uuids).find_by(
        {'id': voicemail_id}
    )


@daosession
def find_by(session, tenant_uuids=None, **criteria):
    return VoicemailPersistor(session, voicemail_search, tenant_uuids).find_by(criteria)


@daosession
def find_all_by(session, tenant_uuids=None, **criteria):
    return VoicemailPersistor(session, voicemail_search, tenant_uuids).find_all_by(
        criteria
    )


@daosession
def create(session, voicemail):
    return VoicemailPersistor(session, voicemail_search).create(voicemail)


@daosession
def edit(session, voicemail):
    VoicemailPersistor(session, voicemail_search).edit(voicemail)


@daosession
def delete(session, voicemail):
    VoicemailPersistor(session, voicemail_search).delete(voicemail)

----------------------------------------

File: voicemail/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.voicemail import Voicemail
from accent_dao.helpers.persistor import BasePersistor
from accent_dao.resources.utils.search import CriteriaBuilderMixin


class VoicemailPersistor(CriteriaBuilderMixin, BasePersistor):
    _search_table = Voicemail

    def __init__(self, session, voicemail_search, tenant_uuids=None):
        self.session = session
        self.search_system = voicemail_search
        self.tenant_uuids = tenant_uuids

    def _find_query(self, criteria):
        query = self.session.query(Voicemail)
        query = self._filter_tenant_uuid(query)
        return self.build_criteria(query, criteria)

    def _search_query(self):
        return self.session.query(self.search_system.config.table)

----------------------------------------

File: voicemail/search.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.voicemail import Voicemail
from accent_dao.resources.utils.search import SearchConfig, SearchSystem

config = SearchConfig(
    table=Voicemail,
    columns={
        'name': Voicemail.fullname,
        'number': Voicemail.mailbox,
        'email': Voicemail.email,
        'context': Voicemail.context,
        'language': Voicemail.language,
        'timezone': Voicemail.tz,
        'pager': Voicemail.pager,
    },
    search=['name', 'number', 'email', 'pager'],
    default_sort='number',
)

voicemail_search = SearchSystem(config)

----------------------------------------

File: voicemail_general/__init__.py
Please review for update


----------------------------------------

File: voicemail_general/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import VoicemailGeneralPersistor


@daosession
def find_all(session):
    return VoicemailGeneralPersistor(session).find_all()


@daosession
def edit_all(session, voicemail_general):
    VoicemailGeneralPersistor(session).edit_all(voicemail_general)

----------------------------------------

File: voicemail_general/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.staticvoicemail import StaticVoicemail


class VoicemailGeneralPersistor:
    def __init__(self, session):
        self.session = session

    def find_all(self):
        query = (
            self.session.query(StaticVoicemail)
            .filter(StaticVoicemail.category == 'general')
            .filter(StaticVoicemail.var_val != None)  # noqa
            .order_by(StaticVoicemail.var_metric.asc())
        )
        return query.all()

    def edit_all(self, voicemail_general):
        self.session.query(StaticVoicemail).filter(
            StaticVoicemail.category == 'general'
        ).delete()
        self.session.add_all(self._fill_default_values(voicemail_general))
        self.session.flush()

    def _fill_default_values(self, voicemail_general):
        for var_metric, setting in enumerate(voicemail_general):
            setting.filename = 'voicemail.conf'
            setting.category = 'general'
        return voicemail_general

----------------------------------------

File: voicemail_zonemessages/__init__.py
Please review for update


----------------------------------------

File: voicemail_zonemessages/dao.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.helpers.db_manager import daosession

from .persistor import VoicemailZoneMessagesPersistor


@daosession
def find_all(session):
    return VoicemailZoneMessagesPersistor(session).find_all()


@daosession
def edit_all(session, voicemail_zonemessages):
    VoicemailZoneMessagesPersistor(session).edit_all(voicemail_zonemessages)

----------------------------------------

File: voicemail_zonemessages/persistor.py
Please review for update

# Copyright 2023 Accent Communications

from accent_dao.alchemy.staticvoicemail import StaticVoicemail


class VoicemailZoneMessagesPersistor:
    def __init__(self, session):
        self.session = session

    def find_all(self):
        query = (
            self.session.query(StaticVoicemail)
            .filter(StaticVoicemail.category == 'zonemessages')
            .filter(StaticVoicemail.var_val != None)  # noqa
        )
        return query.all()

    def edit_all(self, voicemail_zonemessages):
        self.session.query(StaticVoicemail).filter(
            StaticVoicemail.category == 'zonemessages'
        ).delete()
        self.session.add_all(self._fill_default_values(voicemail_zonemessages))
        self.session.flush()

    def _fill_default_values(self, voicemail_zonemessages):
        for setting in voicemail_zonemessages:
            setting.cat_metric = 1
            setting.filename = 'voicemail.conf'
            setting.category = 'zonemessages'
        return voicemail_zonemessages
----------------------------------------

