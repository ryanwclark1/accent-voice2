File: __init__.py
Please review for update


----------------------------------------

File: conftest.py
Please review for update

# Copyright 2025 Accent Communications

"""Test fixtures for accent-lib-rest-client."""

import asyncio
import logging
import os
import sys
from typing import Any, AsyncGenerator, Generator

import httpx
import pytest
import respx
import uvicorn
from fastapi import FastAPI
from pytest_mock import MockerFixture

from accent_lib_rest_client.client import BaseClient
from accent_lib_rest_client.command import RESTCommand
from tests.mock_server.server import create_app


# Basic fixture for REST command testing
class TestCommand(RESTCommand):
    """Test command implementation."""

    resource = "test"

    def get_data(self) -> dict[str, Any]:
        """Get test data."""
        response = self.sync_client.get(f"{self.base_url}/data")
        response.raise_for_status()
        return response.json()

    async def get_data_async(self) -> dict[str, Any]:
        """Get test data asynchronously."""
        response = await self.async_client.get(f"{self.base_url}/data")
        response.raise_for_status()
        return response.json()


# Basic client for testing
class TestClient(BaseClient):
    """Test client implementation."""

    namespace = "test_client.commands"

def pytest_configure(config):
    """Configure pytest."""
    # Set the default asyncio fixture loop scope explicitly
    config.option.asyncio_default_fixture_loop_scope = "function"

@pytest.fixture
def test_command_class() -> type[TestCommand]:
    """Return the test command class."""
    return TestCommand


@pytest.fixture
def test_client() -> TestClient:
    """Return a test client instance."""
    return TestClient(
        host="localhost",
        port=8000,
        version="v1",
        https=False,
    )


@pytest.fixture
def mock_response() -> dict[str, Any]:
    """Return a mock response body."""
    return {"data": "test value", "status": "success"}


@pytest.fixture
def respx_mock() -> respx.Router:
    """Return a respx mock router."""
    with respx.mock(base_url="http://localhost:8000") as mock:
        yield mock


@pytest.fixture
def httpx_mock(respx_mock: respx.Router) -> respx.Router:
    """Return a configured respx mock with common patterns."""
    # Set up common routes
    respx_mock.get("/v1/test/data").respond(
        json={"data": "test value", "status": "success"}
    )
    respx_mock.post("/v1/test/create").respond(
        json={"id": "new-item", "status": "created"}, status_code=201
    )
    respx_mock.get("/v1/not-found").respond(status_code=404)
    respx_mock.get("/v1/error").respond(status_code=500)
    respx_mock.get("/v1/auth").respond(status_code=401)

    return respx_mock


@pytest.fixture(scope="session")
def mock_server_app() -> FastAPI:
    """Create and return the FastAPI mock server app."""
    return create_app()


@pytest.fixture(scope="session")
def mock_server(mock_server_app: FastAPI) -> Generator[None, None, None]:
    """Start the FastAPI mock server in a separate process."""
    # Disable server logs during tests
    logging.getLogger("uvicorn").setLevel(logging.WARNING)

    # Start the server in a separate process
    port = 8000
    config = uvicorn.Config(
        mock_server_app, host="127.0.0.1", port=port, log_level="error"
    )
    server = uvicorn.Server(config)

    # Run the server in a separate thread
    import threading

    thread = threading.Thread(target=server.run)
    thread.daemon = True
    thread.start()

    # Wait for server to start
    import time

    time.sleep(1)

    yield

    # Server will automatically shut down when the process exits


@pytest.fixture
async def async_client() -> AsyncGenerator[httpx.AsyncClient, None]:
    """Return an async client for testing."""
    async with httpx.AsyncClient() as client:
        yield client

----------------------------------------

File: mock_server/server.py
Please review for update

# Copyright 2025 Accent Communications

"""Mock server for testing accent-lib-rest-client."""

from datetime import datetime, timedelta
from typing import Any

from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.responses import JSONResponse
from fastapi.security import HTTPBasic, HTTPBasicCredentials

# Create FastAPI app
security = HTTPBasic()


def create_app() -> FastAPI:
    """Create and configure the FastAPI application for testing."""
    app = FastAPI(title="Accent REST Client Test Server")

    # Authentication middleware
    def verify_credentials(
        credentials: HTTPBasicCredentials = Depends(security),
    ) -> str:
        correct_username = "testuser"
        correct_password = "testpass"
        if (
            credentials.username != correct_username
            or credentials.password != correct_password
        ):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid credentials",
                headers={"WWW-Authenticate": "Basic"},
            )
        return credentials.username

    # Routes
    @app.get("/v1/test")
    async def test_endpoint() -> JSONResponse:
        """Basic test endpoint."""
        return JSONResponse(content={"message": "Test endpoint"})

    @app.get("/v1/test/data")
    async def get_data() -> dict[str, Any]:
        """Return test data."""
        return {
            "data": "test value",
            "status": "success",
            "timestamp": datetime.now().isoformat(),
        }

    @app.post("/v1/test/create")
    async def create_item(item: dict[str, Any]) -> dict[str, Any]:
        """Create a new item."""
        return {
            "id": "new-item",
            "status": "created",
            "data": item,
            "timestamp": datetime.now().isoformat(),
        }

    @app.get("/v1/error")
    async def server_error() -> JSONResponse:
        """Return a server error."""
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Server error occurred"},
        )

    @app.get("/v1/not-found")
    async def not_found() -> JSONResponse:
        """Return a not found error."""
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail={"message": "Resource not found"},
        )

    @app.get("/v1/auth")
    async def auth_endpoint(
        username: str = Depends(verify_credentials),
    ) -> dict[str, Any]:
        """Endpoint that requires authentication."""
        return {
            "message": f"Hello, {username}!",
            "authenticated": True,
            "expires": (datetime.now() + timedelta(hours=1)).isoformat(),
        }

    @app.get("/v1/echo-headers")
    async def echo_headers(request: Any) -> dict[str, Any]:
        """Echo the request headers."""
        return {"headers": dict(request.headers)}

    @app.get("/v1/tenant/{tenant_id}")
    async def tenant_endpoint(tenant_id: str) -> dict[str, Any]:
        """Endpoint that works with tenant information."""
        return {
            "tenant_id": tenant_id,
            "name": f"Tenant {tenant_id}",
            "status": "active",
        }

    return app


if __name__ == "__main__":
    import uvicorn

    app = create_app()
    uvicorn.run(app, host="127.0.0.1", port=8000)

----------------------------------------

File: mock_server/__init__.py
Please review for update


----------------------------------------

File: unit/test_client.py
Please review for update

# Copyright 2025 Accent Communications

"""Unit tests for the BaseClient class."""

import os
from unittest.mock import Mock, PropertyMock, patch

import httpx
import pytest
from accent_lib_rest_client.client import BaseClient
from accent_lib_rest_client.exceptions import InvalidArgumentError
from pytest_mock import MockerFixture


# Test client implementation for unit testing
class TestClientImpl(BaseClient):
    """Test client implementation to avoid namespace issues."""

    namespace = "test_client_namespace"


class TestBaseClient:
    """Test cases for the BaseClient class."""

    def test_init_requires_host(self) -> None:
        """Test that initialization requires a host."""
        with pytest.raises(InvalidArgumentError):
            TestClientImpl(host="")

    def test_init_sets_config(self) -> None:
        """Test that initialization sets the config properly."""
        client = TestClientImpl(
            host="example.com",
            port=8080,
            version="v1",
            token="abc123",
            tenant_uuid="tenant1",
            https=True,
            timeout=5.0,
        )

        assert client.config.host == "example.com"
        assert client.config.port == 8080
        assert client.config.version == "v1"
        assert client.config.token == "abc123"
        assert client.config.tenant_uuid == "tenant1"
        assert client.config.https is True
        assert client.config.timeout == 5.0

    def test_build_prefix(self) -> None:
        """Test prefix building logic."""
        client = TestClientImpl(host="example.com")

        assert client._build_prefix(None) == ""
        assert client._build_prefix("") == ""
        assert client._build_prefix("api") == "/api"
        assert client._build_prefix("/api") == "/api"

    def test_url_building(self) -> None:
        """Test URL building with various parameters."""
        # Basic URL
        client = TestClientImpl(host="example.com")
        assert client.url() == "https://example.com"

        # With port
        client = TestClientImpl(host="example.com", port=8080)
        assert client.url() == "https://example.com:8080"

        # With version
        client = TestClientImpl(host="example.com", version="v1")
        assert client.url() == "https://example.com/v1"

        # With prefix
        client = TestClientImpl(host="example.com", prefix="api")
        assert client.url() == "https://example.com/api"

        # With HTTP instead of HTTPS
        client = TestClientImpl(host="example.com", https=False)
        assert client.url() == "http://example.com"

        # With all options and fragments
        client = TestClientImpl(
            host="example.com",
            port=8080,
            version="v1",
            prefix="api",
            https=True,
        )
        assert client.url() == "https://example.com:8080/api/v1"
        assert client.url("resource") == "https://example.com:8080/api/v1/resource"
        assert (
            client.url("resource", "item")
            == "https://example.com:8080/api/v1/resource/item"
        )

    def test_sync_client_creation(self) -> None:
        """Test synchronous client creation."""
        client = TestClientImpl(
            host="example.com",
            token="abc123",
            tenant_uuid="tenant1",
            user_agent="test-agent",
        )

        sync_client = client.sync_client
        assert isinstance(sync_client, httpx.Client)
        assert sync_client.headers["X-Auth-Token"] == "abc123"
        assert sync_client.headers["Accent-Tenant"] == "tenant1"
        assert sync_client.headers["User-agent"] == "test-agent"
        assert sync_client.headers["Connection"] == "close"

    def test_session_deprecated(self, mocker: MockerFixture) -> None:
        """Test that session() method is deprecated but works."""
        # Reset mock history before our test
        mocker.stopall()
        mock_logger = mocker.patch("accent_lib_rest_client.client.logger")

        # Use a special mock configuration that ignores initialization warnings
        def side_effect(msg, *args, **kwargs):
            # Ignore the "No commands found" warning
            if "No commands found" not in msg:
                return Mock()

        mock_logger.warning.side_effect = side_effect

        client = TestClientImpl(host="example.com")
        session = client.session()

        assert isinstance(session, httpx.Client)

        # Check that warning was called with the specific message we expect
        mock_logger.warning.assert_any_call(
            "Deprecated method 'session()'. Use 'sync_client' instead."
        )

    def test_set_token(self) -> None:
        """Test setting a token after initialization."""
        client = TestClientImpl(host="example.com")

        # Initially no token
        assert client.config.token is None

        # Set a token
        client.set_token("new-token")
        assert client.config.token == "new-token"

        # Check that the client gets recreated with the new token
        assert client._sync_client is None  # Should be reset
        sync_client = client.sync_client
        assert sync_client.headers["X-Auth-Token"] == "new-token"

    def test_set_tenant_deprecated(self, mocker: MockerFixture) -> None:
        """Test that set_tenant() method is deprecated but works."""
        # Reset mock history before our test
        mocker.stopall()
        mock_logger = mocker.patch("accent_lib_rest_client.client.logger")

        # Use a special mock configuration that ignores initialization warnings
        def side_effect(msg, *args, **kwargs):
            # Ignore the "No commands found" warning
            if "No commands found" not in msg:
                return Mock()

        mock_logger.warning.side_effect = side_effect

        client = TestClientImpl(host="example.com")
        client.set_tenant("new-tenant")

        assert client.config.tenant_uuid == "new-tenant"

        # Check that warning was called with the specific message we expect
        mock_logger.warning.assert_any_call(
            "Deprecated method 'set_tenant()'. Set 'tenant_uuid' directly instead."
        )

    def test_tenant_deprecated(self, mocker: MockerFixture) -> None:
        """Test that tenant() method is deprecated but works."""
        # Reset mock history before our test
        mocker.stopall()
        mock_logger = mocker.patch("accent_lib_rest_client.client.logger")

        # Use a special mock configuration that ignores initialization warnings
        def side_effect(msg, *args, **kwargs):
            # Ignore the "No commands found" warning
            if "No commands found" not in msg:
                return Mock()

        mock_logger.warning.side_effect = side_effect

        client = TestClientImpl(host="example.com", tenant_uuid="test-tenant")
        tenant = client.tenant()

        assert tenant == "test-tenant"

        # Check that warning was called with the specific message we expect
        mock_logger.warning.assert_any_call(
            "Deprecated method 'tenant()'. Access 'tenant_uuid' directly instead."
        )

    def test_is_server_reachable(self) -> None:
        """Test checking if server is reachable."""
        # Create client
        client = TestClientImpl(host="example.com")

        # Create temp client and mock it inside the method without patching property
        mock_client = Mock(spec=httpx.Client)

        # Test successful response
        mock_client.head.return_value = httpx.Response(200)
        client._sync_client = mock_client
        assert client.is_server_reachable() is True
        client._sync_client = None

        # Test HTTP error (server is still reachable)
        mock_client = Mock(spec=httpx.Client)
        mock_client.head.side_effect = httpx.HTTPStatusError(
            "HTTP Error",
            request=httpx.Request("HEAD", "https://example.com"),
            response=httpx.Response(500),
        )
        client._sync_client = mock_client
        assert client.is_server_reachable() is True
        client._sync_client = None

        # Test connection error (server is not reachable)
        mock_client = Mock(spec=httpx.Client)
        mock_client.head.side_effect = httpx.ConnectError("Failed to connect")
        client._sync_client = mock_client
        assert client.is_server_reachable() is False
        client._sync_client = None

    @pytest.mark.asyncio
    async def test_is_server_reachable_async(self) -> None:
        """Test checking if server is reachable asynchronously."""
        # Create client
        client = TestClientImpl(host="example.com")

        # Create temp client and mock it directly
        mock_client = Mock(spec=httpx.AsyncClient)

        # Test successful response
        mock_client.head.return_value = httpx.Response(200)
        client._async_client = mock_client
        assert await client.is_server_reachable_async() is True
        client._async_client = None

        # Test HTTP error (server is still reachable)
        mock_client = Mock(spec=httpx.AsyncClient)
        mock_client.head.side_effect = httpx.HTTPStatusError(
            "HTTP Error",
            request=httpx.Request("HEAD", "https://example.com"),
            response=httpx.Response(500),
        )
        client._async_client = mock_client
        assert await client.is_server_reachable_async() is True
        client._async_client = None

        # Test connection error (server is not reachable)
        mock_client = Mock(spec=httpx.AsyncClient)
        mock_client.head.side_effect = httpx.ConnectError("Failed to connect")
        client._async_client = mock_client
        assert await client.is_server_reachable_async() is False
        client._async_client = None

    def test_user_agent_from_argv(self) -> None:
        """Test that user_agent defaults to the program name."""
        with patch.object(os, "path") as mock_path:
            mock_path.basename.return_value = "test-program"

            client = TestClientImpl(host="example.com")
            assert client.config.user_agent == "test-program"

----------------------------------------

File: unit/test_command.py
Please review for update

# Copyright 2025 Accent Communications

"""Unit tests for the HTTPCommand and RESTCommand classes."""

import time
from typing import Any, cast
from unittest.mock import Mock, PropertyMock, patch

import httpx
import pytest
from accent_lib_rest_client.client import BaseClient
from accent_lib_rest_client.command import HTTPCommand, RESTCommand
from accent_lib_rest_client.exceptions import (
    AccentAPIError,
    AuthenticationError,
    ResourceNotFoundError,
    ServerError,
)
from accent_lib_rest_client.models import CommandResponse, JSONResponse
from pytest_mock import MockerFixture


class TestHTTPCommand:
    """Test cases for the HTTPCommand class."""

    @pytest.fixture
    def mock_client(self) -> Mock:
        """Return a mock client."""
        mock = Mock(spec=BaseClient)
        mock.sync_client = Mock(spec=httpx.Client)
        mock.async_client = Mock(spec=httpx.AsyncClient)
        return mock

    @pytest.fixture
    def command(self, mock_client: Mock) -> HTTPCommand:
        """Return an HTTPCommand instance with a mock client."""
        return HTTPCommand(mock_client)

    def test_init(self, command: HTTPCommand, mock_client: Mock) -> None:
        """Test command initialization."""
        assert command._client is mock_client

    def test_sync_client(self, command: HTTPCommand, mock_client: Mock) -> None:
        """Test sync_client property."""
        assert command.sync_client is mock_client.sync_client

    def test_async_client(self, command: HTTPCommand, mock_client: Mock) -> None:
        """Test async_client property."""
        assert command.async_client is mock_client.async_client

    def test_session_deprecated(self, command: HTTPCommand, mock_client: Mock) -> None:
        """Test that session property returns sync_client."""
        assert command.session is mock_client.sync_client

    def test_raise_from_response_success(self) -> None:
        """Test raise_from_response with a successful response."""
        response = Mock(spec=httpx.Response)
        response.status_code = 200

        # This should not raise
        HTTPCommand.raise_from_response(response)
        response.raise_for_status.assert_called_once()

    def test_raise_from_response_error_with_message(self) -> None:
        """Test raise_from_response with an error response containing a message."""
        response = Mock(spec=httpx.Response)
        response.status_code = 400
        response.json.return_value = {"message": "Custom error message"}

        # Setup raise_for_status to raise an exception
        response.raise_for_status.side_effect = httpx.HTTPStatusError(
            "Bad request", request=Mock(), response=response
        )

        # Use a simpler approach
        with pytest.raises(httpx.HTTPStatusError):
            try:
                HTTPCommand.raise_from_response(response)
            except httpx.HTTPStatusError as e:
                # Verify the custom message is used or considered
                assert "Bad request" in str(e)
                # Re-raise for the pytest.raises check
                raise

    def test_raise_from_response_error_without_message(self) -> None:
        """Test raise_from_response with an error response without a message."""
        response = Mock(spec=httpx.Response)
        response.status_code = 400
        response.json.side_effect = ValueError("Invalid JSON")
        response.raise_for_status.side_effect = httpx.HTTPStatusError(
            "Bad request", request=Mock(), response=response
        )

        with pytest.raises(httpx.HTTPStatusError) as excinfo:
            HTTPCommand.raise_from_response(response)

        # Check that the exception was raised correctly
        assert "Bad request" in str(excinfo.value)

    def test_process_response_success(self, command: HTTPCommand) -> None:
        """Test process_response with a successful response."""
        response = Mock(spec=httpx.Response)
        response.status_code = 200
        response.content = b'{"key": "value"}'
        response.headers = {"Content-Type": "application/json"}

        start_time = time.time() - 0.5  # 500ms ago
        result = command.process_response(response, start_time)

        assert isinstance(result, CommandResponse)
        assert result.status_code == 200
        assert result.content == b'{"key": "value"}'
        assert result.headers == {"Content-Type": "application/json"}
        assert result.response_time is not None
        assert 0.4 < result.response_time < 0.6  # Approximately 500ms

    def test_process_response_error(
        self, command: HTTPCommand, mocker: MockerFixture
    ) -> None:
        """Test process_response with an error response."""
        response = Mock(spec=httpx.Response)
        response.status_code = 404
        response.raise_for_status.side_effect = httpx.HTTPStatusError(
            "Not found", request=Mock(), response=response
        )

        mock_handle_error = mocker.patch(
            "accent_lib_rest_client.command.handle_http_error"
        )

        with pytest.raises(Exception):
            command.process_response(response)

        mock_handle_error.assert_called_once()

    def test_process_json_response_success(self, command: HTTPCommand) -> None:
        """Test process_json_response with a successful response."""
        response = Mock(spec=httpx.Response)
        response.status_code = 200
        response.json.return_value = {"key": "value"}
        response.headers = {"Content-Type": "application/json"}

        result = command.process_json_response(response)

        assert isinstance(result, JSONResponse)
        assert result.status_code == 200
        assert result.data == {"key": "value"}
        assert result.headers == {"Content-Type": "application/json"}

    def test_process_json_response_error(
        self, command: HTTPCommand, mocker: MockerFixture
    ) -> None:
        """Test process_json_response with an error response."""
        response = Mock(spec=httpx.Response)
        response.status_code = 500
        response.raise_for_status.side_effect = httpx.HTTPStatusError(
            "Server error", request=Mock(), response=response
        )

        mock_handle_error = mocker.patch(
            "accent_lib_rest_client.command.handle_http_error"
        )

        with pytest.raises(Exception):
            command.process_json_response(response)

        mock_handle_error.assert_called_once()


class TestRESTCommand:
    """Test cases for the RESTCommand class."""

    # Implementation class, not a test class
    class TestRESTImpl(RESTCommand):
        """Concrete implementation of RESTCommand for testing."""

        resource = "test-resource"

    @pytest.fixture
    def mock_client(self) -> Mock:
        """Return a mock client."""
        mock = Mock(spec=BaseClient)
        mock.url.return_value = "https://example.com/v1/test-resource"

        # Mock the config property
        config_mock = Mock()
        config_mock.timeout = 10.0
        type(mock).config = PropertyMock(return_value=config_mock)

        mock.sync_client = Mock(spec=httpx.Client)
        mock.async_client = Mock(spec=httpx.AsyncClient)
        return mock

    @pytest.fixture
    def rest_command(self, mock_client: Mock) -> TestRESTImpl:
        """Return a RESTCommand instance with a mock client."""
        return self.TestRESTImpl(mock_client)

    def test_init(self, rest_command: TestRESTImpl, mock_client: Mock) -> None:
        """Test REST command initialization."""
        assert rest_command._client is mock_client
        assert rest_command.base_url == "https://example.com/v1/test-resource"
        assert rest_command.timeout == 10.0
        mock_client.url.assert_called_once_with("test-resource")

    def test_get_headers_default(self, rest_command: TestRESTImpl) -> None:
        """Test default headers."""
        headers = rest_command._get_headers()
        assert headers == {"Accept": "application/json"}

    def test_get_headers_with_tenant(self, rest_command: TestRESTImpl) -> None:
        """Test headers with tenant UUID."""
        headers = rest_command._get_headers(tenant_uuid="test-tenant")
        assert headers == {
            "Accept": "application/json",
            "Accent-Tenant": "test-tenant",
        }

    def test_get_headers_ignores_other_kwargs(self, rest_command: TestRESTImpl) -> None:
        """Test that other kwargs are ignored in headers."""
        headers = rest_command._get_headers(
            tenant_uuid="test-tenant",
            other_param="value",
            another_param=123,
        )
        assert headers == {
            "Accept": "application/json",
            "Accent-Tenant": "test-tenant",
        }

----------------------------------------

File: unit/test_exceptions.py
Please review for update

# Copyright 2025 Accent Communications

"""Unit tests for custom exceptions."""

import json
from unittest.mock import Mock

import httpx
import pytest
from accent_lib_rest_client.exceptions import (
    AccentAPIError,
    AuthenticationError,
    InvalidArgumentError,
    ResourceNotFoundError,
    ServerError,
    handle_http_error,
)


class TestExceptions:
    """Test cases for custom exceptions."""

    def test_accent_api_error(self) -> None:
        """Test AccentAPIError initialization."""
        error = AccentAPIError("Test error", status_code=400)
        assert str(error) == "Test error"
        assert error.status_code == 400
        assert error.message == "Test error"

    def test_invalid_argument_error(self) -> None:
        """Test InvalidArgumentError initialization."""
        error = InvalidArgumentError("test_arg")
        assert str(error) == 'Invalid value for argument "test_arg"'
        assert error.argument_name == "test_arg"

    def test_authentication_error(self) -> None:
        """Test AuthenticationError initialization."""
        # Default message
        error = AuthenticationError()
        assert str(error) == "Authentication failed"
        assert error.status_code == 401

        # Custom message
        error = AuthenticationError("Invalid token")
        assert str(error) == "Invalid token"
        assert error.status_code == 401

    def test_resource_not_found_error(self) -> None:
        """Test ResourceNotFoundError initialization."""
        error = ResourceNotFoundError("user/123")
        assert str(error) == "Resource not found: user/123"
        assert error.status_code == 404
        assert error.resource == "user/123"

    def test_server_error(self) -> None:
        """Test ServerError initialization."""
        # Default message
        error = ServerError()
        assert str(error) == "Server error occurred"
        assert error.status_code == 500

        # Custom message
        error = ServerError("Database connection failed")
        assert str(error) == "Database connection failed"
        assert error.status_code == 500

    def test_handle_http_error_401(self) -> None:
        """Test handling of 401 HTTP errors."""
        response = Mock(spec=httpx.Response)
        response.status_code = 401
        response.json.return_value = {"message": "Authentication failed"}

        error = httpx.HTTPStatusError("HTTP Error", request=Mock(), response=response)

        with pytest.raises(AuthenticationError) as excinfo:
            handle_http_error(error)

        assert str(excinfo.value) == "Authentication failed"
        assert excinfo.value.status_code == 401

    def test_handle_http_error_404(self) -> None:
        """Test handling of 404 HTTP errors."""
        response = Mock(spec=httpx.Response)
        response.status_code = 404
        response.json.return_value = {"message": "Resource not found"}

        error = httpx.HTTPStatusError("HTTP Error", request=Mock(), response=response)

        with pytest.raises(ResourceNotFoundError) as excinfo:
            handle_http_error(error)

        # The ResourceNotFoundError format is "Resource not found: {message}"
        assert "Resource not found" in str(excinfo.value)

    def test_handle_http_error_500(self) -> None:
        """Test handling of 500 HTTP errors."""
        response = Mock(spec=httpx.Response)
        response.status_code = 500
        response.json.return_value = {"message": "Internal server error"}

        error = httpx.HTTPStatusError("HTTP Error", request=Mock(), response=response)

        with pytest.raises(ServerError) as excinfo:
            handle_http_error(error)

        assert str(excinfo.value) == "Internal server error"
        assert excinfo.value.status_code == 500

    def test_handle_http_error_other(self) -> None:
        """Test handling of other HTTP errors."""
        response = Mock(spec=httpx.Response)
        response.status_code = 403
        response.json.return_value = {"message": "Forbidden"}

        error = httpx.HTTPStatusError("HTTP Error", request=Mock(), response=response)

        with pytest.raises(AccentAPIError) as excinfo:
            handle_http_error(error)

        assert str(excinfo.value) == "Forbidden"
        assert excinfo.value.status_code == 403

    def test_handle_http_error_invalid_json(self) -> None:
        """Test handling of HTTP errors with invalid JSON response."""
        response = Mock(spec=httpx.Response)
        response.status_code = 400
        response.json.side_effect = json.JSONDecodeError("Invalid JSON", "", 0)

        error = httpx.HTTPStatusError("Bad request", request=Mock(), response=response)

        with pytest.raises(AccentAPIError) as excinfo:
            handle_http_error(error)

        assert "Bad request" in str(excinfo.value)
        assert excinfo.value.status_code == 400

----------------------------------------

File: unit/__init__.py
Please review for update


----------------------------------------

File: integration/test_live_requests.py
Please review for update

# Copyright 2025 Accent Communications

"""Integration tests for accent-lib-rest-client with a mock server."""

import httpx
import pytest
from accent_lib_rest_client.client import BaseClient
from accent_lib_rest_client.command import RESTCommand
from accent_lib_rest_client.exceptions import (
    AuthenticationError,
    ResourceNotFoundError,
    ServerError,
    handle_http_error,
)


# Implementation class, not a test class
class TestCommandImpl(RESTCommand):
    """Test command implementation for integration tests."""

    resource = "test"

    def get_data(self) -> dict:
        """Get test data."""
        response = self.sync_client.get(f"{self.base_url}/data")
        response.raise_for_status()
        return response.json()

    async def get_data_async(self) -> dict:
        """Get test data asynchronously."""
        response = await self.async_client.get(f"{self.base_url}/data")
        response.raise_for_status()
        return response.json()

    def create_item(self, data: dict) -> dict:
        """Create a new item."""
        response = self.sync_client.post(f"{self.base_url}/create", json=data)
        response.raise_for_status()
        return response.json()

    async def create_item_async(self, data: dict) -> dict:
        """Create a new item asynchronously."""
        response = await self.async_client.post(f"{self.base_url}/create", json=data)
        response.raise_for_status()
        return response.json()


# Implementation class, not a test class
class TestClientImpl(BaseClient):
    """Test client implementation for integration tests."""

    namespace = "test_client.commands"
    test: TestCommandImpl  # This would be populated by stevedore in real usage


class TestLiveRequests:
    """Integration tests with a mock server."""

    @pytest.fixture
    def client(self, mock_server) -> TestClientImpl:
        """Create a TestClient connected to the mock server."""
        client = TestClientImpl(
            host="127.0.0.1",
            port=8000,
            version="v1",
            https=False,
        )
        # Manually add the command since we're not using stevedore
        client.test = TestCommandImpl(client)
        return client

    def test_get_data(self, client: TestClientImpl) -> None:
        """Test getting data from the server."""
        result = client.test.get_data()
        assert result["status"] == "success"
        assert "data" in result
        assert "timestamp" in result

    @pytest.mark.asyncio
    async def test_get_data_async(self, client: TestClientImpl) -> None:
        """Test getting data from the server asynchronously."""
        result = await client.test.get_data_async()
        assert result["status"] == "success"
        assert "data" in result
        assert "timestamp" in result

    def test_create_item(self, client: TestClientImpl) -> None:
        """Test creating an item on the server."""
        test_data = {"name": "Test Item", "value": 42}
        result = client.test.create_item(test_data)

        assert result["status"] == "created"
        assert result["id"] == "new-item"
        assert result["data"] == test_data
        assert "timestamp" in result

    @pytest.mark.asyncio
    async def test_create_item_async(self, client: TestClientImpl) -> None:
        """Test creating an item on the server asynchronously."""
        test_data = {"name": "Test Item", "value": 42}
        result = await client.test.create_item_async(test_data)

        assert result["status"] == "created"
        assert result["id"] == "new-item"
        assert result["data"] == test_data
        assert "timestamp" in result

    def test_error_handling(self, client: TestClientImpl) -> None:
        """Test error handling with different status codes."""
        # 404 Not Found
        with pytest.raises(ResourceNotFoundError):
            try:
                response = client.sync_client.get("http://127.0.0.1:8000/v1/not-found")
                response.raise_for_status()
            except httpx.HTTPStatusError as e:
                handle_http_error(e)

        # 500 Server Error
        with pytest.raises(ServerError):
            try:
                response = client.sync_client.get("http://127.0.0.1:8000/v1/error")
                response.raise_for_status()
            except httpx.HTTPStatusError as e:
                handle_http_error(e)

    def test_url_building(self, client: TestClientImpl) -> None:
        """Test URL building with the client."""
        assert client.url() == "http://127.0.0.1:8000/v1"
        assert client.url("test") == "http://127.0.0.1:8000/v1/test"
        assert client.url("test", "data") == "http://127.0.0.1:8000/v1/test/data"

    def test_server_reachable(self, client: TestClientImpl) -> None:
        """Test server reachability check."""
        assert client.is_server_reachable() is True

        # Test with an unreachable server
        unreachable_client = TestClientImpl(
            host="invalid-host",
            port=9999,
            https=False,
        )
        assert unreachable_client.is_server_reachable() is False

----------------------------------------

File: integration/__init__.py
Please review for update


----------------------------------------

File: async/test_async_client.py
Please review for update

# Copyright 2025 Accent Communications

"""Async tests for accent-lib-rest-client."""

import asyncio
from typing import Any, AsyncGenerator, Dict

import httpx
import pytest
import pytest_asyncio
from accent_lib_rest_client.client import BaseClient
from accent_lib_rest_client.command import RESTCommand
from accent_lib_rest_client.exceptions import (
    AuthenticationError,
    ResourceNotFoundError,
    ServerError,
    handle_http_error,
)


# We're extending the RESTCommand class for testing, not creating a test class
class AsyncTestCommandImpl(RESTCommand):
    """Test command implementation with async methods."""

    resource = "test"

    async def get_data(self) -> Dict[str, Any]:
        """Get test data asynchronously."""
        response = await self.async_client.get(f"{self.base_url}/data")
        response.raise_for_status()
        return response.json()

    async def create_item(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Create a new item asynchronously."""
        response = await self.async_client.post(f"{self.base_url}/create", json=data)
        response.raise_for_status()
        return response.json()


# We're extending the BaseClient class for testing, not creating a test class
class AsyncTestClientImpl(BaseClient):
    """Test client implementation for async tests."""

    namespace = "async_test_client.commands"
    test: AsyncTestCommandImpl


@pytest_asyncio.fixture
async def async_client(mock_server) -> AsyncGenerator[AsyncTestClientImpl, None]:
    """Create an AsyncTestClient connected to the mock server."""
    client = AsyncTestClientImpl(
        host="127.0.0.1",
        port=8000,
        version="v1",
        https=False,
    )
    # Manually add the command since we're not using stevedore
    client.test = AsyncTestCommandImpl(client)

    yield client

    # Close the client after the test
    await client._close_async_client()


class TestAsyncClient:
    """Async tests for the client."""

    @pytest.mark.asyncio
    async def test_async_client_creation(self) -> None:
        """Test async client creation."""
        # Use AsyncTestClientImpl instead of BaseClient to avoid namespace issues
        client = AsyncTestClientImpl(host="example.com")
        async_client = client.async_client

        assert isinstance(async_client, httpx.AsyncClient)
        assert async_client.headers["Connection"] == "close"

        # Clean up
        await client._close_async_client()

    @pytest.mark.asyncio
    async def test_is_server_reachable_async(
        self, async_client: AsyncTestClientImpl
    ) -> None:
        """Test async server reachability check."""
        assert await async_client.is_server_reachable_async() is True

        # Test with an unreachable server
        unreachable_client = AsyncTestClientImpl(
            host="invalid-host",
            port=9999,
            https=False,
        )
        assert await unreachable_client.is_server_reachable_async() is False

    @pytest.mark.asyncio
    async def test_get_data_async(self, async_client: AsyncTestClientImpl) -> None:
        """Test getting data asynchronously."""
        result = await async_client.test.get_data()

        assert result["status"] == "success"
        assert "data" in result
        assert "timestamp" in result

    @pytest.mark.asyncio
    async def test_create_item_async(self, async_client: AsyncTestClientImpl) -> None:
        """Test creating an item asynchronously."""
        test_data = {"name": "Async Test", "value": 100}
        result = await async_client.test.create_item(test_data)

        assert result["status"] == "created"
        assert result["id"] == "new-item"
        assert result["data"] == test_data
        assert "timestamp" in result

    @pytest.mark.asyncio
    async def test_error_handling_async(
        self, async_client: AsyncTestClientImpl
    ) -> None:
        """Test async error handling."""
        # Import inside the test to avoid circular imports
        import httpx

        # 404 Not Found
        with pytest.raises(ResourceNotFoundError):
            try:
                response = await async_client.async_client.get(
                    "http://127.0.0.1:8000/v1/not-found"
                )
                response.raise_for_status()
            except httpx.HTTPStatusError as e:
                handle_http_error(e)

        # 500 Server Error
        with pytest.raises(ServerError):
            try:
                response = await async_client.async_client.get(
                    "http://127.0.0.1:8000/v1/error"
                )
                response.raise_for_status()
            except httpx.HTTPStatusError as e:
                handle_http_error(e)

    @pytest.mark.asyncio
    async def test_concurrent_requests(self, async_client: AsyncTestClientImpl) -> None:
        """Test running multiple async requests concurrently."""
        # Create tasks for multiple concurrent requests
        tasks = []

        # Add data fetching tasks
        tasks.append(async_client.test.get_data())
        tasks.append(async_client.test.get_data())

        # Add item creation tasks
        for i in range(5):
            tasks.append(
                async_client.test.create_item({"name": "Concurrent Test", "value": i})
            )

        # Run all tasks concurrently
        results = await asyncio.gather(*tasks)

        # Verify each result
        for i, result in enumerate(results):
            if i < 2:  # First two are get_data calls
                assert result["status"] == "success"
                assert "data" in result
            else:  # The rest are create_item calls
                assert result["status"] == "created"
                assert result["id"] == "new-item"
                assert result["data"]["name"] == "Concurrent Test"

----------------------------------------

File: async/__init__.py
Please review for update


----------------------------------------

