File: accent_bus/__init__.py

from .consumer import BusConsumer
from .publisher import BusPublisher

__all__ = [
    'BusConsumer',
    'BusPublisher',
]

----------------------------------------

File: accent_bus/base.py

from __future__ import annotations

import logging
from types import TracebackType
from typing import Any, NamedTuple, Protocol, Self

from kombu import Exchange
from kombu.utils.url import as_url

from .resources.common.abstract import EventProtocol


class ConnectionParams(NamedTuple):
    user: str
    password: str
    host: str
    port: int


class BaseProtocol(Protocol):
    _name: str
    _logger: logging.Logger
    _connection_params: ConnectionParams
    _default_exchange: Exchange

    def __init__(
        self,
        name: str | None,
        username: str = 'guest',
        password: str = 'guest',
        host: str = 'localhost',
        port: int = 5672,
        exchange_name: str = '',
        exchange_type: str = '',
        **kwargs: Any,
    ):
        ...

    @property
    def url(self) -> str:
        ...

    @property
    def log(self) -> logging.Logger:
        ...

    @property
    def is_running(self) -> bool:
        ...

    def _marshal(
        self,
        event: EventProtocol,
        headers: dict | None,
        payload: dict | None,
        routing_key: str | None = None,
    ) -> tuple[dict | None, dict | None, str | None]:
        ...

    def _unmarshal(
        self, event_name: str, headers: dict, payload: dict
    ) -> tuple[dict, dict]:
        ...

    def __enter__(self) -> Self:
        return self

    def __exit__(
        self,
        exc: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        ...


class Base(BaseProtocol):
    '''Base class for publishers/consumers (to be extended by mixins)'''

    def __init__(
        self,
        name: str | None = None,
        username: str = 'guest',
        password: str = 'guest',
        host: str = 'localhost',
        port: int = 5672,
        exchange_name: str = '',
        exchange_type: str = '',
        **kwargs: Any,
    ) -> None:
        durable = kwargs.pop('exchange_durable', True)
        self._name = name or type(self).__name__
        self._logger = logging.getLogger(type(self).__name__)
        self._connection_params = ConnectionParams(username, password, host, port)
        self._default_exchange = Exchange(
            name=exchange_name, type=exchange_type, durable=durable
        )

    @property
    def url(self) -> str:
        return as_url('amqp', **self._connection_params._asdict())

    @property
    def log(self) -> logging.Logger:
        return self._logger

    @property
    def is_running(self) -> bool:
        return True

    def _marshal(
        self,
        event: EventProtocol,
        headers: dict | None,
        payload: dict | None,
        routing_key: str | None = None,
    ) -> tuple[dict | None, dict | None, str | None]:
        return headers, payload, routing_key

    def _unmarshal(
        self, event_name: str, headers: dict, payload: dict
    ) -> tuple[dict, dict]:
        return headers, payload

----------------------------------------

File: accent_bus/collectd/__init__.py
Please review for update


----------------------------------------

File: accent_bus/collectd/calls.py

from __future__ import annotations

import string

from .common import CollectdEvent


def _validate_plugin_instance_fragment(plugin_instance_fragment: str) -> str:
    result = ''.join(
        c
        for c in plugin_instance_fragment
        if (c in string.ascii_letters or c in string.digits or c == '-')
    )
    return result or '<unknown>'


class _BaseCallCollectdEvent(CollectdEvent):
    routing_key_fmt = 'collectd.calls'
    plugin = 'calls'
    type_ = 'counter'
    values = ('1',)

    def __init__(
        self,
        application: str,
        application_id: str | None,
        time: int | str | None = None,
    ):
        super().__init__()
        if time:
            self.time = int(time)

        application = _validate_plugin_instance_fragment(application)
        if application_id is not None:
            application_id = _validate_plugin_instance_fragment(application_id)
            self.plugin_instance = f'{application}.{application_id}'
        else:
            self.plugin_instance = application


class CallStartCollectdEvent(_BaseCallCollectdEvent):
    name = 'collectd_call_started'
    type_instance = 'start'


class CallConnectCollectdEvent(_BaseCallCollectdEvent):
    name = 'collectd_call_connected'
    type_instance = 'connect'


class CallEndCollectdEvent(_BaseCallCollectdEvent):
    name = 'collectd_call_ended'
    type_instance = 'end'


class CallAbandonedCollectdEvent(_BaseCallCollectdEvent):
    name = 'collectd_call_abandoned'
    type_instance = 'abandoned'


class CallDurationCollectdEvent(_BaseCallCollectdEvent):
    name = 'collectd_call_duration'
    type_ = 'gauge'
    type_instance = 'duration'

    def __init__(
        self,
        application: str,
        application_id: str | None,
        duration: int,
        time: str | int | None = None,
    ):
        super().__init__(application, application_id, time)
        self.values = (str(round(duration, 3)),)

----------------------------------------

File: accent_bus/collectd/channels.py

from .common import CollectdEvent


class _BaseChannelCollectdEvent(CollectdEvent):
    routing_key_fmt = 'collectd.channels'
    plugin = 'channels'
    plugin_instance = 'global'
    type_ = 'counter'
    values = ('1',)


class ChannelCreatedCollectdEvent(_BaseChannelCollectdEvent):
    name = 'collectd_channel_created'
    type_instance = 'created'


class ChannelEndedCollectdEvent(_BaseChannelCollectdEvent):
    name = 'collectd_channel_ended'
    type_instance = 'ended'

----------------------------------------

File: accent_bus/collectd/common.py

from __future__ import annotations

from abc import abstractmethod

from ..resources.common.abstract import EventProtocol


class CollectdEvent(EventProtocol):
    '''
    Base Collectd Event

    subclasses must define the following attributes:
      * name
      * routing_key_fmt
      * plugin
      * type_
    '''

    routing_key_fmt: str
    interval: int = 10
    plugin_instance: str | None = None
    time: str | int = 'N'
    type_instance: str | None = None
    values: tuple[str, ...] = ()

    def __init__(self, content: dict | None = None):
        self.content = content or {}

    @property
    @abstractmethod
    def plugin(self) -> str:
        pass

    @property
    @abstractmethod
    def type_(self) -> str:
        pass

    def is_valid(self) -> bool:
        return (
            self.plugin is not None
            and self.plugin_instance is not None
            and self.type_ is not None
            and self.type_instance is not None
            and (self.time == 'N' or isinstance(self.time, int))
            and len(self.values) > 0
        )

    def __str__(self) -> str:
        content = ', '.join(
            [
                f'plugin=\'{self.plugin}\'',
                f'plugin_instance=\'{self.plugin_instance}\'',
                f'type=\'{self.type_}\'',
                f'type_instance=\'{self.type_instance}\'',
                f'values={self.values}',
            ]
        )
        return f'CollectdEvent({content})'

----------------------------------------

File: accent_bus/consumer.py

from __future__ import annotations

from typing import Any

from .base import Base
from .mixins import (
    AccentEventMixin,
    ConsumerMixin,
    SubscribeExchangeDict,
    ThreadableMixin,
)


class BusConsumer(AccentEventMixin, ThreadableMixin, ConsumerMixin, Base):
    def __init__(
        self,
        name: str | None = None,
        username: str = 'guest',
        password: str = 'guest',
        host: str = 'localhost',
        port: int = 5672,
        exchange_name: str = '',
        exchange_type: str = '',
        subscribe: SubscribeExchangeDict | None = None,
        **kwargs: Any,
    ):
        super().__init__(
            name=name,
            username=username,
            password=password,
            host=host,
            port=port,
            exchange_name=exchange_name,
            exchange_type=exchange_type,
            subscribe=subscribe,
            **kwargs,
        )

----------------------------------------

File: accent_bus/mixins.py

from __future__ import annotations

import os
from collections import defaultdict
from collections.abc import Callable, Iterator
from contextlib import contextmanager
from datetime import datetime
from queue import Empty, Queue
from threading import Event, Lock, Thread, current_thread, main_thread
from typing import Any, ClassVar, NamedTuple, Protocol, Self, TypedDict

from amqp.exceptions import NotFound
from kombu import Connection, Consumer, Exchange, Message, Producer
from kombu import Queue as AMQPQueue
from kombu import binding as Binding
from kombu.exceptions import OperationalError
from kombu.mixins import ConsumerMixin as KombuConsumer
from kombu.transport.base import StdChannel

from .base import BaseProtocol
from .collectd.common import CollectdEvent
from .resources.common.abstract import EventProtocol

EventHandlerType = Callable[[dict], None]
ThreadTargetType = Callable[..., None]
ThreadOnStopType = Callable[[], None]


class BusThread(NamedTuple):
    thread: Thread
    on_stop: ThreadOnStopType | None
    ready_flag: Event


class SubscribeExchangeDict(TypedDict):
    exchange_name: str
    exchange_type: str


class PublishExchangeDict(TypedDict):
    exchange_name: str
    exchange_type: str


class Subscription(NamedTuple):
    handler: EventHandlerType
    binding: Binding


class ThreadableProtocol(Protocol):
    @property
    def is_stopping(self) -> bool:
        ...

    def _register_thread(
        self,
        name: str,
        run: ThreadTargetType,
        on_stop: ThreadOnStopType | None,
        **kwargs: Any,
    ) -> Thread:
        ...

    def start(self) -> None:
        ...

    def stop(self) -> None:
        ...


class ThreadableMixin(BaseProtocol):
    '''
    Mixin to provide methods for easy thread creation/management

    Public attributes:
        * `is_running`:
            Returns True if threads are alive and running

    Public methods:
        * `start`:
            Starts execution of registered thread
        * `stop`:
            Kill all running threads

    Private methods:
        * `_register_thread`:
            Allows another mixin to register a thread for execution
    '''

    def __init__(self, **kwargs: Any):
        self.__internal_threads_list: list[BusThread] = list()
        self.__stop_flag = Event()
        super().__init__(**kwargs)

    @property
    def is_stopping(self) -> bool:
        return self.__stop_flag.is_set()

    @property
    def is_running(self) -> bool:
        status = all({bus_thread.thread.is_alive() for bus_thread in self.__threads})
        return super().is_running and status  # type: ignore[safe-super]

    @property
    def __threads(self) -> list[BusThread]:
        return self.__internal_threads_list

    def __enter__(self) -> Self:
        self.start()
        return super().__enter__()

    def __exit__(self, *args: Any) -> None:
        self.stop()
        super().__exit__(*args)

    def _register_thread(
        self,
        name: str,
        run: ThreadTargetType,
        on_stop: ThreadOnStopType | None = None,
        **kwargs: Any,
    ) -> Thread:
        if not callable(run):
            raise ValueError('Run must be a function')
        ready_flag = Event()
        bus_thread = BusThread(
            Thread(
                target=self.__wrap_thread(run),
                name=f'{self._name}:{name}',
                args=(self, name, ready_flag),
                kwargs=kwargs,
            ),
            on_stop,
            ready_flag,
        )
        self.__threads.append(bus_thread)
        return bus_thread.thread

    def start(self) -> None:
        if self.is_running:
            raise RuntimeError(f'{len(self.__threads)} threads are already running')

        for bus_thread in self.__threads:
            bus_thread.thread.start()

        for bus_thread in self.__threads:
            bus_thread.ready_flag.wait(timeout=3.0)
        self.log.debug('All threads started successfully...')

    def stop(self) -> None:
        self.__stop_flag.set()
        for bus_thread in self.__threads:
            if bus_thread.thread.is_alive():
                self.log.debug('Stopping AMQP thread \'%s\'', bus_thread.thread.name)
                if callable(bus_thread.on_stop):
                    bus_thread.on_stop()
                bus_thread.thread.join()

    @staticmethod
    def __wrap_thread(func: ThreadTargetType) -> ThreadTargetType:
        def wrapper(self: Self, name: str, ready_flag: Event, **kwargs: Any) -> None:
            self.log.debug('Started AMQP thread \'%s\'', name)
            while not self.is_stopping:
                try:
                    func(ready_flag, **kwargs)
                except Exception:
                    restart = ', restarting...' if not self.is_stopping else ''
                    self.log.exception(
                        'Exception occurred in thread \'%s\'%s', name, restart
                    )

        return wrapper


class ConsumerMixin(KombuConsumer, BaseProtocol):
    '''
    Mixin to provide RabbitMQ message consuming capabilities

    Public methods:
        * `consumer_connected`:
            Returns whether the consumer is connected to RabbitMQ or not
        * `subscribe`:
            Install a handler for the specified event
        * `unsubscribe`:
            Uninstall a handler for the specified event
    '''

    consumer_args: ClassVar[dict] = {}

    def __init__(self, subscribe: SubscribeExchangeDict | None = None, **kwargs: Any):
        super().__init__(**kwargs)
        name = f'{self._name}.{os.urandom(3).hex()}'
        if subscribe:
            exchange = Exchange(subscribe['exchange_name'], subscribe['exchange_type'])

        self.__connection = Connection(self.url)
        self.__exchange = exchange if subscribe else self._default_exchange
        self.__subscriptions: defaultdict[str, list[Subscription]] = defaultdict(list)
        self.__queue = AMQPQueue(name=name, auto_delete=True, durable=False)
        self.__lock = Lock()
        self.__thread: Thread | None = None
        if hasattr(self, '_register_thread'):
            self.__thread = self._register_thread(
                'consumer', self.__thread_run, self.__thread_stop
            )

        self.create_connection()
        self.log.debug('setting consuming exchange as \'%s\'', self.__exchange)

    def consumer_connected(self) -> bool:
        is_running = self.__thread.is_alive() if self.__thread is not None else True
        return bool(is_running and self.connection.connected)

    @property
    @contextmanager
    def __binding_channel(self) -> Iterator[StdChannel]:
        if not self.__connection.connected:
            self.__connection.connect()
        yield self.__connection.default_channel

    def __create_binding(self, headers: dict, routing_key: str | None) -> Binding:
        binding = Binding(self.__exchange, routing_key, headers, headers)
        self.__queue.bindings.add(binding)
        if self.is_running:
            try:
                with self.__binding_channel as channel:
                    self.__queue.queue_declare(passive=True, channel=channel)
                    binding.bind(self.__queue, channel=channel)
            except self.__connection.connection_errors as e:
                self.log.error('Connection error while creating binding: %s', e)
            except NotFound:
                self.log.error(
                    'Queue %s doesn\'t exist on the server', self.__queue.name
                )
        return binding

    def __remove_binding(self, binding: Binding) -> None:
        self.__queue.bindings.remove(binding)
        if self.is_running:
            try:
                with self.__binding_channel as channel:
                    self.__queue.queue_declare(passive=True, channel=channel)
                    binding.unbind(self.__queue, channel=channel)
            except self.__connection.connection_errors:
                self.log.exception('Connection error while removing binding: %s')
            except NotFound:
                pass

    def __dispatch(
        self, event_name: str, payload: dict, headers: dict | None = None
    ) -> None:
        with self.__lock:
            subscriptions = self.__subscriptions[event_name].copy()
        if subscriptions:
            self.log.debug(
                'Received bus event: name=%s, headers=%s, payload=%s',
                event_name,
                headers,
                payload,
            )
        for handler, _ in subscriptions:
            try:
                handler(payload)
            except Exception:
                self.log.exception(
                    'Handler \'%s\' for event \'%s\' failed',
                    getattr(handler, '__name__', handler),
                    event_name,
                )
            continue

    def __extract_event_from_message(self, message: Message) -> tuple[str, dict, dict]:
        event_name = None
        headers = message.headers
        payload = message.payload

        if 'name' in headers:
            event_name = headers['name']
        elif isinstance(payload, dict) and 'name' in payload:
            event_name = payload['name']
        else:
            raise ValueError('Received invalid messsage; no event name could be found.')
        return event_name, headers, payload

    def subscribe(
        self,
        event_name: str,
        handler: EventHandlerType,
        headers: dict | None = None,
        routing_key: str | None = None,
        headers_match_all: bool = True,
    ) -> None:
        headers = dict(headers or {})
        headers.update(name=event_name)
        if self.__exchange.type == 'headers':
            headers.setdefault('x-match', 'all' if headers_match_all else 'any')

        binding = self.__create_binding(headers, routing_key)
        subscription = Subscription(handler, binding)
        with self.__lock:
            self.__subscriptions[event_name].append(subscription)
        self.log.debug(
            'Registered handler \'%s\' to event \'%s\'',
            getattr(handler, '__name__', handler),
            event_name,
        )

    def unsubscribe(self, event_name: str, handler: EventHandlerType) -> bool:
        with self.__lock:
            subscriptions = self.__subscriptions[event_name].copy()
        try:
            for subscription in subscriptions:
                if subscription.handler == handler:
                    with self.__lock:
                        self.__subscriptions[event_name].remove(subscription)
                    self.__remove_binding(subscription.binding)
                    self.log.debug(
                        'Unregistered handler \'%s\' from \'%s\'',
                        getattr(handler, '__name__', handler),
                        event_name,
                    )
                    return True
            return False
        finally:
            if not self.__subscriptions[event_name]:
                with self.__lock:
                    self.__subscriptions.pop(event_name)

    def get_consumers(
        self, Consumer: type[Consumer], channel: StdChannel
    ) -> list[Consumer]:
        self.__exchange.bind(channel).declare()
        return [
            Consumer(
                queues=[self.__queue],
                callbacks=[self.__on_message_received],
                auto_declare=True,
            )
        ]

    def __on_message_received(self, body: Any, message: Message) -> None:
        event_name, headers, payload = self.__extract_event_from_message(message)
        if event_name not in self.__subscriptions:
            return
        try:
            headers, payload = self._unmarshal(event_name, headers, payload)
        except Exception:
            raise
        else:
            self.__dispatch(event_name, payload, headers)
        finally:
            message.ack()

    def on_connection_error(self, exc: Exception, interval: str) -> None:
        self.log.error(
            'Broker connection error: %s, trying to reconnect in %s seconds...',
            exc,
            interval,
        )
        if self.should_stop:
            if current_thread() != main_thread():
                raise SystemExit
            self.connection.release()

    def create_connection(self) -> Connection:
        self.connection = self.__connection.clone()
        return self.connection

    @property
    def should_stop(self) -> bool:
        return getattr(self, 'is_stopping', True)

    def on_consume_ready(
        self,
        connection: Connection,
        channel: Any,
        consumers: list[Consumer],
        **kwargs: Any,
    ) -> None:
        if 'ready_flag' in kwargs:
            ready_flag = kwargs.pop('ready_flag')
            ready_flag.set()

    def __thread_run(self, ready_flag: Event, **kwargs: Any) -> None:
        super().run(ready_flag=ready_flag, **self.consumer_args)

    def __thread_stop(self) -> None:
        self.__connection.release()


class PublisherMixin(BaseProtocol):
    '''
    Mixin providing RabbitMQ message publishing capabilities

    Methods:
        * `publisher_connected`:
            Returns whether publisher is connected to RabbitMQ or not
        * `publish`:
            publish an event immediately to the bus
    '''

    publisher_args: ClassVar[dict] = {
        'max_retries': 2,
    }

    def __init__(self, publish: PublishExchangeDict | None = None, **kwargs: Any):
        super().__init__(**kwargs)
        if publish:
            exchange = Exchange(publish['exchange_name'], publish['exchange_type'])
        self.__exchange = exchange if publish else self._default_exchange
        self.__connection = Connection(self.url, transport_options=self.publisher_args)
        self.__lock = Lock()
        self.log.debug('setting publishing exchange as \'%s\'', self.__exchange)

    def publisher_connected(self) -> bool:
        return self.__connection.connected

    @contextmanager
    def Producer(
        self, connection: Connection, **connection_args: Any
    ) -> Iterator[Callable]:
        producer = Producer(connection, exchange=self.__exchange, auto_declare=True)
        yield connection.ensure(
            producer, producer.publish, errback=self.on_publish_error, **connection_args
        )

    def on_publish_error(self, exc: Exception, interval: int | str) -> None:
        self.log.error('Publish error: %s', exc, exc_info=True)
        self.log.info('Retry in %s seconds...', interval)

    def publish(
        self,
        event: EventProtocol,
        headers: dict | None = None,
        routing_key: str | None = None,
        payload: dict | None = None,
    ) -> None:
        headers, payload, routing_key = self._marshal(
            event, headers, payload, routing_key=routing_key
        )
        content_type = getattr(self, 'content_type', None)
        with self.__lock:
            with self.Producer(self.__connection, **self.publisher_args) as publish:
                publish(
                    payload,
                    headers=headers,
                    routing_key=routing_key,
                    content_type=content_type,
                )
        self.log.debug('Published %s', str(event))


class QueuePublisherMixin(PublisherMixin, ThreadableProtocol):
    '''
    Mixin to provide publishing capabilities, including ability to publish
    through a thread

    **Note: Exclusive with PublisherMixin**

    Public methods:
        * `publisher_connected`:
            Returns publisher's connection state to rabbitmq
        * `queue_publisher_connected`:
            Returns threaded publisher's connection state to rabbitmq
        * `publish`:
            Publish an event immediately to the bus without queueing
        * `publish_soon`:
            Queue an event to be processed by the publishing thread
    '''

    queue_publisher_args: ClassVar[dict] = {
        'interval_start': 2,
        'interval_step': 2,
        'interval_max': 32,
    }

    def __init__(self, **kwargs: Any) -> None:
        retry_policy = self.queue_publisher_args
        super().__init__(**kwargs)
        self.__flushing: bool = False
        self.__fifo: Queue = Queue()
        self.__connection = Connection(self.url, transport_options=retry_policy)
        self.__thread: Thread | None = None

        if hasattr(self, '_register_thread'):
            self.__thread = self._register_thread(
                'publisher_queue', self.__thread_run, self.__thread_stop
            )

    def queue_publisher_connected(self) -> bool:
        is_running = self.__thread.is_alive() if self.__thread is not None else True
        return bool(self.__connection.connected and is_running)

    def __thread_run(self, ready_flag: Event, **kwargs: Any) -> None:
        ready_flag.set()
        retry_policy = self.queue_publisher_args

        with self.__connection:
            while not self.is_stopping or self.__flushing:
                try:
                    payload, headers, routing_key = self.__fifo.get()
                except (Empty, TypeError):
                    self.__flushing = False
                    continue
                try:
                    with self.Producer(self.__connection, **retry_policy) as publish:
                        publish(payload, headers=headers, routing_key=routing_key)
                except OperationalError as exc:
                    self.log.error('Publishing queue error: %s', exc, exc_info=True)
                else:
                    self.__fifo.task_done()

    def __thread_stop(self) -> None:
        self.__flushing = True
        self.__fifo.put(None)

    def publish_soon(
        self,
        event: EventProtocol,
        headers: dict | None = None,
        routing_key: str | None = None,
        payload: dict | None = None,
    ) -> None:
        headers, payload, routing_key = self._marshal(
            event, headers, payload, routing_key
        )
        self.__fifo.put((payload, headers, routing_key))


class AccentEventMixin(BaseProtocol):
    '''
    Mixin to handle message formatting for accent events

    Overrides:
        * `_marshal`:
            Serializes the message to be sent to RabbitMQ

        * `_unmarshal`:
            Deserializes the message received from RabbitMQ
    '''

    def __init__(self, service_uuid: str | None = None, **kwargs: Any):
        super().__init__(**kwargs)
        self.service_uuid = service_uuid

    def __generate_payload(
        self, event: EventProtocol, headers: dict, initial_data: dict | None
    ) -> dict:
        payload: dict = {}
        data = initial_data.copy() if initial_data else {}
        try:
            data.update(event.marshal())
        except AttributeError:
            self.log.exception("Received invalid event '%s'", event)
            raise ValueError('Not a valid Accent Event')
        else:
            payload.update(headers, data=data)
            return payload

    def __generate_headers(
        self, event: EventProtocol, extra_headers: dict | None
    ) -> dict:
        headers = {}
        headers.update(extra_headers or {})

        try:
            headers.update(event.headers)
        except AttributeError:
            pass

        if hasattr(event, 'required_access'):
            headers['required_access'] = event.required_access

        # TODO: remove deprecated `required_acl`
        if hasattr(event, 'required_acl'):
            headers['required_acl'] = event.required_acl

        headers.update(
            name=event.name,
            origin_uuid=self.service_uuid,
            timestamp=datetime.now().isoformat(),
        )

        return headers

    def _marshal(
        self,
        event: EventProtocol,
        headers: dict | None,
        payload: dict | None,
        routing_key: str | None = None,
    ) -> tuple[dict, dict, str | None]:
        routing_key = routing_key or getattr(event, 'routing_key', None)
        headers = self.__generate_headers(event, headers)
        payload = self.__generate_payload(event, headers, payload)

        return headers, payload, routing_key

    def _unmarshal(
        self, event_name: str, headers: dict, payload: dict
    ) -> tuple[dict, dict]:
        event_data = payload.pop('data')
        headers = headers or payload
        return headers, event_data


class CollectdMixin:
    content_type: ClassVar[str] = 'text/collectd'

    def __init__(self, service_uuid: str | None = None, **kwargs: Any):
        super().__init__(**kwargs)
        if not service_uuid:
            raise ValueError('service must have an UUID')
        self.service_uuid = service_uuid

    def __generate_payload(self, event: CollectdEvent) -> str:
        if not event.is_valid():
            raise ValueError(event)

        host = self.service_uuid

        plugin = event.plugin
        if event.plugin_instance:
            plugin = f'{event.plugin}-{event.plugin_instance}'

        type_ = f'{event.type_}-{event.type_instance}'
        interval = event.interval
        time = event.time
        values = ':'.join(event.values)

        return f'PUTVAL {host}/{plugin}/{type_} interval={interval} {time}:{values}'

    def _marshal(
        self,
        event: CollectdEvent,
        headers: dict | None,
        payload: dict | None,
        routing_key: str | None = None,
    ) -> tuple[dict | None, str, str | None]:
        routing_key = routing_key or getattr(event, 'routing_key', None)
        collectd_payload: str = self.__generate_payload(event)

        return headers, collectd_payload, routing_key

----------------------------------------

File: accent_bus/publisher.py

from __future__ import annotations

import logging
from typing import Any

from .base import Base
from .mixins import (
    AccentEventMixin,
    PublisherMixin,
    QueuePublisherMixin,
    ThreadableMixin,
)

logger = logging.getLogger(__name__)


class BusPublisher(AccentEventMixin, PublisherMixin, Base):
    def __init__(
        self,
        name: str | None = None,
        service_uuid: str | None = None,
        username: str = 'guest',
        password: str = 'guest',
        host: str = 'localhost',
        port: int = 5672,
        exchange_name: str = '',
        exchange_type: str = '',
        **kwargs: Any,
    ):
        super().__init__(
            name=name,
            service_uuid=service_uuid,
            username=username,
            password=password,
            host=host,
            port=port,
            exchange_name=exchange_name,
            exchange_type=exchange_type,
            **kwargs,
        )


# Deprecated, thread should be avoided to respect WPEP-0004
class BusPublisherWithQueue(
    AccentEventMixin,
    ThreadableMixin,
    QueuePublisherMixin,
    Base,
):
    def __init__(
        self,
        name: str | None = None,
        service_uuid: str | None = None,
        username: str = 'guest',
        password: str = 'guest',
        host: str = 'localhost',
        port: int = 5672,
        exchange_name: str = '',
        exchange_type: str = '',
        **kwargs: Any,
    ):
        super().__init__(
            name=name,
            service_uuid=service_uuid,
            username=username,
            password=password,
            host=host,
            port=port,
            exchange_name=exchange_name,
            exchange_type=exchange_type,
            **kwargs,
        )

----------------------------------------

File: accent_bus/resources/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/access_feature/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/access_feature/event.py

from __future__ import annotations

from ..common.event import ServiceEvent
from .types import AccessFeatureDict


class AccessFeatureCreatedEvent(ServiceEvent):
    service = 'confd'
    name = 'access_feature_created'
    routing_key_fmt = 'config.access_feature.created'

    def __init__(self, access_feature_info: AccessFeatureDict):
        super().__init__(content=access_feature_info)


class AccessFeatureDeletedEvent(ServiceEvent):
    service = 'confd'
    name = 'access_feature_deleted'
    routing_key_fmt = 'config.access_feature.deleted'

    def __init__(self, access_feature_info: AccessFeatureDict):
        super().__init__(content=access_feature_info)


class AccessFeatureEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'access_feature_edited'
    routing_key_fmt = 'config.access_feature.edited'

    def __init__(self, access_feature_info: AccessFeatureDict):
        super().__init__(content=access_feature_info)

----------------------------------------

File: accent_bus/resources/access_feature/types.py

from __future__ import annotations

from typing import TypedDict


class AccessFeatureDict(TypedDict, total=False):
    id: int
    host: str
    feature: str
    enabled: bool

----------------------------------------

File: accent_bus/resources/adhoc_conference/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/adhoc_conference/event.py

from ..common.event import UserEvent
from ..common.types import UUIDStr


class AdhocConferenceCreatedEvent(UserEvent):
    name = 'conference_adhoc_created'
    routing_key_fmt = 'conferences.users.{user_uuid}.adhoc.created'
    service = 'calld'

    def __init__(
        self,
        conference_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'conference_id': conference_id}
        super().__init__(content, tenant_uuid, user_uuid)


class AdhocConferenceDeletedEvent(UserEvent):
    name = 'conference_adhoc_deleted'
    routing_key_fmt = 'conferences.users.{user_uuid}.adhoc.deleted'
    service = 'calld'

    def __init__(
        self,
        conference_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'conference_id': conference_id}
        super().__init__(content, tenant_uuid, user_uuid)


class AdhocConferenceParticipantJoinedEvent(UserEvent):
    name = 'conference_adhoc_participant_joined'
    routing_key_fmt = 'conferences.users.{user_uuid}.adhoc.participants.joined'
    service = 'calld'

    def __init__(
        self,
        conference_id: int,
        call_id: str,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'conference_id': conference_id, 'call_id': call_id}
        super().__init__(content, tenant_uuid, user_uuid)


class AdhocConferenceParticipantLeftEvent(UserEvent):
    name = 'conference_adhoc_participant_left'
    routing_key_fmt = 'conferences.users.{user_uuid}.adhoc.participants.left'
    service = 'calld'

    def __init__(
        self,
        conference_id: int,
        call_id: str,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'conference_id': conference_id, 'call_id': call_id}
        super().__init__(content, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/agent/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/agent/event.py

from __future__ import annotations

from ..common.event import MultiUserEvent, TenantEvent
from ..common.types import UUIDStr


class AgentCreatedEvent(TenantEvent):
    """A new agent has been created"""

    service = 'confd'
    name = 'agent_created'
    routing_key_fmt = 'config.agent.created'

    def __init__(self, agent_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(agent_id)}
        super().__init__(content, tenant_uuid)


class AgentDeletedEvent(TenantEvent):
    """An agent has been deleted"""

    service = 'confd'
    name = 'agent_deleted'
    routing_key_fmt = 'config.agent.deleted'

    def __init__(self, agent_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(agent_id)}
        super().__init__(content, tenant_uuid)


class AgentEditedEvent(TenantEvent):
    """An agent has been edited"""

    service = 'confd'
    name = 'agent_edited'
    routing_key_fmt = 'config.agent.edited'

    def __init__(self, agent_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(agent_id)}
        super().__init__(content, tenant_uuid)


class AgentPausedEvent(MultiUserEvent):
    """An agent was paused"""

    service = 'agentd'
    name = 'agent_paused'
    routing_key_fmt = 'status.agent.pause'
    required_acl_fmt = 'events.statuses.agents'

    def __init__(
        self,
        agent_id: int,
        agent_number: str,
        queue: str,
        reason: str,
        tenant_uuid: UUIDStr,
        user_uuids: list[UUIDStr],
    ):
        content = {
            'agent_id': agent_id,
            'agent_number': agent_number,
            'paused': True,
            'paused_reason': reason or '',
            'queue': queue,
        }
        super().__init__(content, tenant_uuid, user_uuids)


class AgentUnpausedEvent(MultiUserEvent):
    """An agent was unpaused"""

    service = 'agentd'
    name = 'agent_unpaused'
    routing_key_fmt = 'status.agent.unpause'
    required_acl_fmt = 'events.statuses.agents'

    def __init__(
        self,
        agent_id: int,
        agent_number: str,
        queue: str,
        reason: str,
        tenant_uuid: UUIDStr,
        user_uuids: list[UUIDStr],
    ):
        content = {
            'agent_id': agent_id,
            'agent_number': agent_number,
            'paused': False,
            'paused_reason': reason or '',
            'queue': queue,
        }
        super().__init__(content, tenant_uuid, user_uuids)


class AgentStatusUpdatedEvent(MultiUserEvent):
    """An agent status has changed"""

    service = 'calld'
    name = 'agent_status_update'
    routing_key_fmt = 'status.agent'
    required_acl_fmt = 'events.statuses.agents'

    def __init__(
        self,
        agent_id: int,
        status: str,
        tenant_uuid: UUIDStr,
        user_uuids: list[UUIDStr],
    ):
        content = {'agent_id': int(agent_id), 'status': status}
        super().__init__(content, tenant_uuid, user_uuids)

----------------------------------------

File: accent_bus/resources/agent_skill/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/agent_skill/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class AgentSkillAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'agent_skill_associated'
    routing_key_fmt = 'config.agents.skills.updated'

    def __init__(
        self,
        agent_id: int,
        skill_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'agent_id': agent_id,
            'skill_id': skill_id,
        }
        super().__init__(content, tenant_uuid)


class AgentSkillDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'agent_skill_dissociated'
    routing_key_fmt = 'config.agents.skills.deleted'

    def __init__(
        self,
        agent_id: int,
        skill_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'agent_id': agent_id,
            'skill_id': skill_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/ami/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/ami/event.py

from ..common.event import ServiceEvent


class AMIEvent(ServiceEvent):
    service = 'amid'
    name = '{ami_event}'
    routing_key_fmt = 'ami.{name}'

    def __init__(self, ami_event: str, variables: dict[str, str]):
        self.name = type(self).name.format(ami_event=ami_event)
        super().__init__(variables)

----------------------------------------

File: accent_bus/resources/application/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/application/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import ApplicationDict


class ApplicationCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'application_created'
    routing_key_fmt = 'config.applications.created'

    def __init__(
        self,
        application: ApplicationDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(application, tenant_uuid)


class ApplicationDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'application_deleted'
    routing_key_fmt = 'config.applications.deleted'

    def __init__(
        self,
        application: ApplicationDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(application, tenant_uuid)


class ApplicationEditedEvent(TenantEvent):
    service = 'confd'
    name = 'application_edited'
    routing_key_fmt = 'config.applications.edited'

    def __init__(
        self,
        application: ApplicationDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(application, tenant_uuid)

----------------------------------------

File: accent_bus/resources/application/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class ApplicationDict(TypedDict, total=False):
    uuid: UUIDStr
    tenant_uuid: UUIDStr
    name: str
    destination: str | None
    destination_options: dict[str, str]

----------------------------------------

File: accent_bus/resources/auth/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/auth/events.py

from ..common.event import TenantEvent, UserEvent
from ..common.types import UUIDStr
from .types import TenantDict


class TenantCreatedEvent(TenantEvent):
    service = 'auth'
    name = 'auth_tenant_added'
    routing_key_fmt = 'auth.tenants.{tenant_uuid}.created'

    def __init__(self, tenant_data: TenantDict, tenant_uuid: UUIDStr):
        super().__init__(tenant_data, tenant_uuid)


class TenantUpdatedEvent(TenantEvent):
    service = 'auth'
    name = 'auth_tenant_updated'
    routing_key_fmt = 'auth.tenants.{tenant_uuid}.updated'

    def __init__(self, name: str, tenant_uuid: UUIDStr):
        content = {'uuid': tenant_uuid, 'name': name}
        super().__init__(content, tenant_uuid)


class TenantDeletedEvent(TenantEvent):
    service = 'auth'
    name = 'auth_tenant_deleted'
    routing_key_fmt = 'auth.tenants.{tenant_uuid}.deleted'

    def __init__(self, tenant_uuid: UUIDStr):
        content = {'uuid': tenant_uuid}
        super().__init__(content, tenant_uuid)


class UserExternalAuthAddedEvent(UserEvent):
    service = 'auth'
    name = 'auth_user_external_auth_added'
    routing_key_fmt = 'auth.users.{user_uuid}.external.{external_auth_name}.created'

    def __init__(
        self,
        external_auth_name: str,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'user_uuid': user_uuid, 'external_auth_name': external_auth_name}
        super().__init__(content, tenant_uuid, user_uuid)


class UserExternalAuthAuthorizedEvent(UserEvent):
    service = 'auth'
    name = 'auth_user_external_auth_authorized'
    routing_key_fmt = 'auth.users.{user_uuid}.external.{external_auth_name}.authorized'

    def __init__(
        self,
        external_auth_name: str,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'user_uuid': user_uuid, 'external_auth_name': external_auth_name}
        super().__init__(content, tenant_uuid, user_uuid)


class UserExternalAuthDeletedEvent(UserEvent):
    service = 'auth'
    name = 'auth_user_external_auth_deleted'
    routing_key_fmt = 'auth.users.{user_uuid}.external.{external_auth_name}.deleted'

    def __init__(
        self,
        external_auth_name: str,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'user_uuid': user_uuid, 'external_auth_name': external_auth_name}
        super().__init__(content, tenant_uuid, user_uuid)


class RefreshTokenCreatedEvent(UserEvent):
    service = 'auth'
    name = 'auth_refresh_token_created'
    routing_key_fmt = 'auth.users.{user_uuid}.tokens.{client_id}.created'

    def __init__(
        self,
        client_id: str,
        is_mobile: bool,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'client_id': client_id,
            'mobile': bool(is_mobile),
            'user_uuid': user_uuid,
            'tenant_uuid': tenant_uuid,
        }
        super().__init__(content, tenant_uuid, user_uuid)


class RefreshTokenDeletedEvent(UserEvent):
    service = 'auth'
    name = 'auth_refresh_token_deleted'
    routing_key_fmt = 'auth.users.{user_uuid}.tokens.{client_id}.deleted'

    def __init__(
        self,
        client_id: str,
        is_mobile: bool,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'client_id': client_id,
            'mobile': bool(is_mobile),
            'user_uuid': user_uuid,
            'tenant_uuid': tenant_uuid,
        }
        super().__init__(content, tenant_uuid, user_uuid)


class SessionCreatedEvent(UserEvent):
    service = 'auth'
    name = 'auth_session_created'
    routing_key_fmt = 'auth.sessions.{session_uuid}.created'

    def __init__(
        self,
        session_uuid: UUIDStr,
        is_mobile: bool,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'uuid': session_uuid,
            'tenant_uuid': tenant_uuid,
            'user_uuid': user_uuid,
            'mobile': bool(is_mobile),
        }
        super().__init__(content, tenant_uuid, user_uuid)
        self.session_uuid = str(session_uuid)


class SessionDeletedEvent(UserEvent):
    service = 'auth'
    name = 'auth_session_deleted'
    routing_key_fmt = 'auth.sessions.{session_uuid}.deleted'

    def __init__(
        self,
        session_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'uuid': session_uuid,
            'user_uuid': user_uuid,
            'tenant_uuid': tenant_uuid,
        }
        super().__init__(content, tenant_uuid, user_uuid)
        self.session_uuid = str(session_uuid)


class SessionExpireSoonEvent(UserEvent):
    service = 'auth'
    name = 'auth_session_expire_soon'
    routing_key_fmt = 'auth.users.{user_uuid}.sessions.{session_uuid}.expire_soon'

    def __init__(
        self,
        session_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'uuid': session_uuid,
            'user_uuid': user_uuid,
            'tenant_uuid': tenant_uuid,
        }
        super().__init__(content, tenant_uuid, user_uuid)
        self.session_uuid = str(session_uuid)

----------------------------------------

File: accent_bus/resources/auth/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class TenantDict(TypedDict, total=False):
    uuid: UUIDStr
    name: str
    slug: str
    domain_names: list[str]

----------------------------------------

File: accent_bus/resources/call_filter/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/call_filter/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class CallFilterCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'call_filter_created'
    routing_key_fmt = 'config.callfilter.created'

    def __init__(self, call_filter_id: int, tenant_uuid: UUIDStr):
        content = {'id': call_filter_id}
        super().__init__(content, tenant_uuid)


class CallFilterDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'call_filter_deleted'
    routing_key_fmt = 'config.callfilter.deleted'

    def __init__(self, call_filter_id: int, tenant_uuid: UUIDStr):
        content = {'id': call_filter_id}
        super().__init__(content, tenant_uuid)


class CallFilterEditedEvent(TenantEvent):
    service = 'confd'
    name = 'call_filter_edited'
    routing_key_fmt = 'config.callfilter.edited'

    def __init__(self, call_filter_id: int, tenant_uuid: UUIDStr):
        content = {'id': call_filter_id}
        super().__init__(content, tenant_uuid)


class CallFilterFallbackEditedEvent(TenantEvent):
    service = 'confd'
    name = 'call_filter_fallback_edited'
    routing_key_fmt = 'config.callfilters.fallbacks.edited'

    def __init__(self, call_filter_id: int, tenant_uuid: UUIDStr):
        content = {'id': call_filter_id}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/call_filter_user/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/call_filter_user/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class CallFilterRecipientUsersAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'call_filter_recipient_users_associated'
    routing_key_fmt = 'config.callfilters.recipients.users.updated'

    def __init__(
        self,
        call_filter_id: int,
        users: list[str],
        tenant_uuid: UUIDStr,
    ):
        content = {
            'call_filter_id': call_filter_id,
            'user_uuids': users,
        }
        super().__init__(content, tenant_uuid)


class CallFilterSurrogateUsersAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'call_filter_surrogate_users_associated'
    routing_key_fmt = 'config.callfilters.surrogates.users.updated'

    def __init__(
        self,
        call_filter_id: int,
        users: list[str],
        tenant_uuid: UUIDStr,
    ):
        content = {
            'call_filter_id': call_filter_id,
            'user_uuids': users,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/call_logd/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/call_logd/events.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import CallLogExportDataDict


class CallLogExportCreatedEvent(TenantEvent):
    service = 'call_logd'
    name = 'call_logd_export_created'
    routing_key_fmt = 'call_logd.export.created'

    def __init__(
        self,
        export_data: CallLogExportDataDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(export_data, tenant_uuid)


class CallLogExportUpdatedEvent(TenantEvent):
    service = 'call_logd'
    name = 'call_logd_export_updated'
    routing_key_fmt = 'call_logd.export.updated'

    def __init__(
        self,
        export_data: CallLogExportDataDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(export_data, tenant_uuid)


class CallLogRetentionUpdatedEvent(TenantEvent):
    service = 'call_logd'
    name = 'call_logd_retention_updated'
    routing_key_fmt = 'call_logd.retention.updated'

    def __init__(
        self,
        retention_data: CallLogExportDataDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(retention_data, tenant_uuid)

----------------------------------------

File: accent_bus/resources/call_logd/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import DateTimeStr, UUIDStr


class CallLogExportDataDict(TypedDict, total=False):
    uuid: UUIDStr
    tenant_uuid: UUIDStr
    user_uuid: UUIDStr
    requested_at: DateTimeStr
    filename: str
    status: str

----------------------------------------

File: accent_bus/resources/call_logs/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/call_logs/events.py

from ..common.event import TenantEvent, UserEvent
from ..common.types import UUIDStr
from .types import CDRDataDict


class CallLogCreatedEvent(TenantEvent):
    service = 'call_logd'
    name = 'call_log_created'
    routing_key_fmt = 'call_log.created'

    def __init__(self, cdr_data: CDRDataDict, tenant_uuid: UUIDStr):
        super().__init__(cdr_data, tenant_uuid)


class CallLogUserCreatedEvent(UserEvent):
    service = 'call_logd'
    name = 'call_log_user_created'
    routing_key_fmt = 'call_log.user.{user_uuid}.created'

    def __init__(
        self,
        cdr_data: CDRDataDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(cdr_data, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/call_logs/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import DateTimeStr, UUIDStr


class DestinationConferenceDict(TypedDict, total=False):
    conference_id: int


class DestinationMeetingDict(TypedDict, total=False):
    meeting_uuid: UUIDStr
    meeting_name: str


class DestinationUserDict(TypedDict, total=False):
    user_uuid: UUIDStr
    user_name: str


class DestinationUnknownDict(TypedDict, total=False):
    ...


class DestinationDetailsDict(TypedDict, total=False):
    conference: DestinationConferenceDict
    meeting: DestinationMeetingDict
    user: DestinationUserDict
    unknown: DestinationUnknownDict


class RecordingDict(TypedDict, total=False):
    uuid: UUIDStr
    start_time: str
    end_time: str
    deleted: bool
    filename: str


class CDRDataDict(TypedDict, total=False):
    id: int
    tenant_uuid: UUIDStr
    start: DateTimeStr
    end: DateTimeStr
    answered: bool
    duration: float
    call_drection: str
    conversation_id: str
    destination_details: DestinationDetailsDict
    destination_extension: str
    destination_internal_context: str
    destination_internal_extension: str
    destination_line_id: int
    destination_name: str
    destination_user_uuid: UUIDStr
    requested_name: str
    requested_context: str
    requested_extension: str
    requested_internal_context: str
    requested_internal_extension: str
    source_extension: str
    source_internal_context: str
    source_internal_name: str
    source_internal_extension: str
    source_line_id: int
    source_name: str
    source_user_uuid: UUIDStr
    tags: list[str]
    recordings: list[RecordingDict]

----------------------------------------

File: accent_bus/resources/call_permission/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/call_permission/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class CallPermissionCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'call_permission_created'
    routing_key_fmt = 'config.callpermission.created'

    def __init__(self, call_permission_id: int, tenant_uuid: UUIDStr):
        content = {'id': call_permission_id}
        super().__init__(content, tenant_uuid)


class CallPermissionDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'call_permission_deleted'
    routing_key_fmt = 'config.callpermission.deleted'

    def __init__(self, call_permission_id: int, tenant_uuid: UUIDStr):
        content = {'id': call_permission_id}
        super().__init__(content, tenant_uuid)


class CallPermissionEditedEvent(TenantEvent):
    service = 'confd'
    name = 'call_permission_edited'
    routing_key_fmt = 'config.callpermission.edited'

    def __init__(self, call_permission_id: int, tenant_uuid: UUIDStr):
        content = {'id': call_permission_id}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/call_pickup/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/call_pickup/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class CallPickupCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'call_pickup_created'
    routing_key_fmt = 'config.callpickup.created'

    def __init__(self, call_pickup_id: int, tenant_uuid: UUIDStr):
        content = {'id': call_pickup_id}
        super().__init__(content, tenant_uuid)


class CallPickupDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'call_pickup_deleted'
    routing_key_fmt = 'config.callpickup.deleted'

    def __init__(self, call_pickup_id: int, tenant_uuid: UUIDStr):
        content = {'id': call_pickup_id}
        super().__init__(content, tenant_uuid)


class CallPickupEditedEvent(TenantEvent):
    service = 'confd'
    name = 'call_pickup_edited'
    routing_key_fmt = 'config.callpickup.edited'

    def __init__(self, call_pickup_id: int, tenant_uuid: UUIDStr):
        content = {'id': call_pickup_id}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/call_pickup_member/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/call_pickup_member/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class CallPickupInterceptorUsersAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'call_pickup_interceptor_users_associated'
    routing_key_fmt = 'config.callpickups.interceptors.users.updated'

    def __init__(
        self,
        call_pickup_id: int,
        users: list[str],
        tenant_uuid: UUIDStr,
    ):
        content = {
            'call_pickup_id': call_pickup_id,
            'user_uuids': users,
        }
        super().__init__(content, tenant_uuid)


class CallPickupTargetUsersAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'call_pickup_target_users_associated'
    routing_key_fmt = 'config.callpickups.targets.users.updated'

    def __init__(
        self,
        call_pickup_id: int,
        users: list[str],
        tenant_uuid: UUIDStr,
    ):
        content = {
            'call_pickup_id': call_pickup_id,
            'user_uuids': users,
        }
        super().__init__(content, tenant_uuid)


class CallPickupInterceptorGroupsAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'call_pickup_interceptor_groups_associated'
    routing_key_fmt = 'config.callpickups.interceptors.groups.updated'

    def __init__(
        self,
        call_pickup_id: int,
        group_ids: list[int],
        tenant_uuid: UUIDStr,
    ):
        content = {
            'call_pickup_id': call_pickup_id,
            'group_ids': group_ids,
        }
        super().__init__(content, tenant_uuid)


class CallPickupTargetGroupsAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'call_pickup_target_groups_associated'
    routing_key_fmt = 'config.callpickups.targets.groups.updated'

    def __init__(
        self,
        call_pickup_id: int,
        group_ids: list[int],
        tenant_uuid: UUIDStr,
    ):
        content = {
            'call_pickup_id': call_pickup_id,
            'group_ids': group_ids,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/calls/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/calls/application.py

from __future__ import annotations

from typing import Any

from ..common.event import TenantEvent, UserEvent
from ..common.types import UUIDStr
from .types import (
    ApplicationCallDict,
    ApplicationCallPlayDict,
    ApplicationNodeDict,
    ApplicationSnoopDict,
)


class _ApplicationMixin:
    def __init__(
        self,
        content: dict,
        application_uuid: UUIDStr,
        *args: Any,
    ):
        super().__init__(content, *args)  # type: ignore[call-arg]
        if application_uuid is None:
            raise ValueError('application_uuid must have a value')
        self.application_uuid = str(application_uuid)


class ApplicationCallDTMFReceivedEvent(_ApplicationMixin, TenantEvent):
    service = 'calld'
    name = 'application_call_dtmf_received'
    routing_key_fmt = 'applications.{application_uuid}.calls.{call_id}.dtmf.created'

    def __init__(
        self,
        call_id: str,
        conversation_id: str,
        dtmf: str,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'application_uuid': str(application_uuid),
            'call_id': call_id,
            'conversation_id': conversation_id,
            'dtmf': dtmf,
        }
        super().__init__(content, application_uuid, tenant_uuid)


class ApplicationCallEnteredEvent(_ApplicationMixin, UserEvent):
    service = 'calld'
    name = 'application_call_entered'
    routing_key_fmt = 'applications.{application_uuid}.calls.created'

    def __init__(
        self,
        application_call: ApplicationCallDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'call': application_call}
        super().__init__(content, application_uuid, tenant_uuid, user_uuid)


class ApplicationCallInitiatedEvent(_ApplicationMixin, UserEvent):
    service = 'calld'
    name = 'application_call_initiated'
    routing_key_fmt = 'applications.{application_uuid}.calls.created'

    def __init__(
        self,
        application_call: ApplicationCallDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'call': application_call}
        super().__init__(content, application_uuid, tenant_uuid, user_uuid)


class ApplicationCallDeletedEvent(_ApplicationMixin, UserEvent):
    service = 'calld'
    name = 'application_call_deleted'
    routing_key_fmt = 'applications.{application_uuid}.calls.{call[id]}.deleted'

    def __init__(
        self,
        application_call: ApplicationCallDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'call': application_call}
        super().__init__(content, application_uuid, tenant_uuid, user_uuid)


class ApplicationCallUpdatedEvent(_ApplicationMixin, UserEvent):
    service = 'calld'
    name = 'application_call_updated'
    routing_key_fmt = 'applications.{application_uuid}.calls.{call[id]}.updated'

    def __init__(
        self,
        application_call: ApplicationCallDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'call': application_call}
        super().__init__(content, application_uuid, tenant_uuid, user_uuid)


class ApplicationCallAnsweredEvent(_ApplicationMixin, UserEvent):
    service = 'calld'
    name = 'application_call_answered'
    routing_key_fmt = 'applications.{application_uuid}.calls.{call[id]}.answered'

    def __init__(
        self,
        application_call: ApplicationCallDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'call': application_call}
        super().__init__(content, application_uuid, tenant_uuid, user_uuid)


class ApplicationCallProgressStartedEvent(_ApplicationMixin, UserEvent):
    service = 'calld'
    name = 'application_progress_started'
    routing_key_fmt = (
        'applications.{application_uuid}.calls.{call[id]}.progress.started'
    )

    def __init__(
        self,
        application_call: ApplicationCallDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'call': application_call}
        super().__init__(content, application_uuid, tenant_uuid, user_uuid)


class ApplicationCallProgressStoppedEvent(_ApplicationMixin, UserEvent):
    service = 'calld'
    name = 'application_progress_stopped'
    routing_key_fmt = (
        'applications.{application_uuid}.calls.{call[id]}.progress.stopped'
    )

    def __init__(
        self,
        application_call: ApplicationCallDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'call': application_call}
        super().__init__(content, application_uuid, tenant_uuid, user_uuid)


class ApplicationDestinationNodeCreatedEvent(_ApplicationMixin, TenantEvent):
    service = 'calld'
    name = 'application_destination_node_created'
    routing_key_fmt = 'applications.{application_uuid}.nodes.created'

    def __init__(
        self,
        node: ApplicationNodeDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'node': node}
        super().__init__(content, application_uuid, tenant_uuid)


class ApplicationNodeCreatedEvent(_ApplicationMixin, TenantEvent):
    service = 'calld'
    name = 'application_node_created'
    routing_key_fmt = 'applications.{application_uuid}.nodes.created'

    def __init__(
        self,
        node: ApplicationNodeDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'node': node}
        super().__init__(content, application_uuid, tenant_uuid)


class ApplicationNodeUpdatedEvent(_ApplicationMixin, TenantEvent):
    service = 'calld'
    name = 'application_node_updated'
    routing_key_fmt = 'applications.{application_uuid}.nodes.{node[uuid]}.updated'

    def __init__(
        self,
        node: ApplicationNodeDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'node': node}
        super().__init__(content, application_uuid, tenant_uuid)


class ApplicationNodeDeletedEvent(_ApplicationMixin, TenantEvent):
    service = 'calld'
    name = 'application_node_deleted'
    routing_key_fmt = 'applications.{application_uuid}.nodes.{node[uuid]}.deleted'

    def __init__(
        self,
        node: ApplicationNodeDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'node': node}
        super().__init__(content, application_uuid, tenant_uuid)


class ApplicationPlaybackCreatedEvent(_ApplicationMixin, TenantEvent):
    service = 'calld'
    name = 'application_playback_created'
    routing_key_fmt = (
        'applications.{application_uuid}.playbacks.{playback[uuid]}.created'
    )

    def __init__(
        self,
        playback: ApplicationCallPlayDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        call_id: str,
        conversation_id: str,
    ):
        content = {
            'application_uuid': str(application_uuid),
            'call_id': call_id,
            'conversation_id': conversation_id,
            'playback': playback,
        }
        super().__init__(content, application_uuid, tenant_uuid)


class ApplicationPlaybackDeletedEvent(_ApplicationMixin, TenantEvent):
    service = 'calld'
    name = 'application_playback_deleted'
    routing_key_fmt = (
        'applications.{application_uuid}.playbacks.{playback[uuid]}.deleted'
    )

    def __init__(
        self,
        playback: ApplicationCallPlayDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        call_id: str,
        conversation_id: str,
    ):
        content = {
            'application_uuid': str(application_uuid),
            'call_id': call_id,
            'conversation_id': conversation_id,
            'playback': playback,
        }
        super().__init__(content, application_uuid, tenant_uuid)


class ApplicationSnoopCreatedEvent(_ApplicationMixin, TenantEvent):
    service = 'calld'
    name = 'application_snoop_created'
    routing_key_fmt = 'applications.{application_uuid}.snoops.{snoop[uuid]}.created'

    def __init__(
        self,
        snoop: ApplicationSnoopDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'snoop': snoop}
        super().__init__(content, application_uuid, tenant_uuid)


class ApplicationSnoopUpdatedEvent(_ApplicationMixin, TenantEvent):
    service = 'calld'
    name = 'application_snoop_updated'
    routing_key_fmt = 'applications.{application_uuid}.snoops.{snoop[uuid]}.updated'

    def __init__(
        self,
        snoop: ApplicationSnoopDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'snoop': snoop}
        super().__init__(content, application_uuid, tenant_uuid)


class ApplicationSnoopDeletedEvent(_ApplicationMixin, TenantEvent):
    service = 'calld'
    name = 'application_snoop_deleted'
    routing_key_fmt = 'applications.{application_uuid}.snoops.{snoop[uuid]}.deleted'

    def __init__(
        self,
        snoop: ApplicationSnoopDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'snoop': snoop}
        super().__init__(content, application_uuid, tenant_uuid)


class ApplicationUserOutgoingCallCreatedEvent(_ApplicationMixin, UserEvent):
    service = 'calld'
    name = 'application_user_outgoing_call_created'
    routing_key_fmt = (
        'applications.{application_uuid}.user_outgoing_call.{call[id]}.created'
    )

    def __init__(
        self,
        call: ApplicationCallDict,
        application_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {'application_uuid': str(application_uuid), 'call': call}
        super().__init__(content, application_uuid, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/calls/event.py

from ..common.event import UserEvent
from ..common.types import UUIDStr
from .types import CallDict, RelocateDict, TransferDict


class CallCreatedEvent(UserEvent):
    service = 'calld'
    name = 'call_created'
    routing_key_fmt = 'calls.call.created'
    required_acl_fmt = 'events.calls.{user_uuid}'

    def __init__(
        self,
        call: CallDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(call, tenant_uuid, user_uuid)


class CallEndedEvent(UserEvent):
    service = 'calld'
    name = 'call_ended'
    routing_key_fmt = 'calls.call.ended'
    required_acl_fmt = 'events.calls.{user_uuid}'

    def __init__(
        self,
        call: CallDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(call, tenant_uuid, user_uuid)


class CallUpdatedEvent(UserEvent):
    service = 'calld'
    name = 'call_updated'
    routing_key_fmt = 'calls.call.updated'
    required_acl_fmt = 'events.calls.{user_uuid}'

    def __init__(
        self,
        call: CallDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(call, tenant_uuid, user_uuid)


class CallAnsweredEvent(UserEvent):
    service = 'calld'
    name = 'call_answered'
    routing_key_fmt = 'calls.call.answered'
    required_acl_fmt = 'events.calls.{user_uuid}'

    def __init__(
        self,
        call: CallDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(call, tenant_uuid, user_uuid)


class CallDTMFEvent(UserEvent):
    service = 'calld'
    name = 'call_dtmf_created'
    routing_key_fmt = 'calls.dtmf.created'
    required_acl_fmt = 'events.calls.{user_uuid}'

    def __init__(
        self,
        call_id: str,
        digit_number: str,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'call_id': call_id,
            'digit': digit_number,
            'user_uuid': str(user_uuid),
        }
        super().__init__(content, tenant_uuid, user_uuid)


class CallHeldEvent(UserEvent):
    service = 'calld'
    name = 'call_held'
    routing_key_fmt = 'calls.hold.created'
    required_acl_fmt = 'events.calls.{user_uuid}'

    def __init__(
        self,
        call_id: str,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'call_id': call_id,
            'user_uuid': str(user_uuid),
        }
        super().__init__(content, tenant_uuid, user_uuid)


class CallResumedEvent(UserEvent):
    service = 'calld'
    name = 'call_resumed'
    routing_key_fmt = 'calls.hold.deleted'
    required_acl_fmt = 'events.calls.{user_uuid}'

    def __init__(
        self,
        call_id: str,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'call_id': call_id,
            'user_uuid': str(user_uuid),
        }
        super().__init__(content, tenant_uuid, user_uuid)


class MissedCallEvent(UserEvent):
    service = 'calld'
    name = 'user_missed_call'
    routing_key_fmt = 'calls.missed'
    required_acl_fmt = 'events.calls.{user_uuid}'

    def __init__(
        self,
        call: CallDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(call, tenant_uuid, user_uuid)


class CallRelocateInitiatedEvent(UserEvent):
    service = 'calld'
    name = 'relocate_initiated'
    routing_key_fmt = 'calls.relocate.created'
    required_acl_fmt = 'events.relocates.{user_uuid}'

    def __init__(
        self,
        relocate: RelocateDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(relocate, tenant_uuid, user_uuid)


class CallRelocateAnsweredEvent(UserEvent):
    service = 'calld'
    name = 'relocate_answered'
    routing_key_fmt = 'calls.relocate.edited'
    required_acl_fmt = 'events.relocates.{user_uuid}'

    def __init__(
        self,
        relocate: RelocateDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(relocate, tenant_uuid, user_uuid)


class CallRelocateCompletedEvent(UserEvent):
    service = 'calld'
    name = 'relocate_completed'
    routing_key_fmt = 'calls.relocate.edited'
    required_acl_fmt = 'events.relocates.{user_uuid}'

    def __init__(
        self,
        relocate: RelocateDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(relocate, tenant_uuid, user_uuid)


class CallRelocateEndedEvent(UserEvent):
    service = 'calld'
    name = 'relocate_ended'
    routing_key_fmt = 'calls.relocate.deleted'
    required_acl_fmt = 'events.relocates.{user_uuid}'

    def __init__(
        self,
        relocate: RelocateDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(relocate, tenant_uuid, user_uuid)


class CallTransferCreatedEvent(UserEvent):
    service = 'calld'
    name = 'transfer_created'
    routing_key_fmt = 'calls.transfer.created'
    required_acl_fmt = 'events.transfers.{user_uuid}'

    def __init__(
        self,
        transfer: TransferDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(transfer, tenant_uuid, user_uuid)


class CallTransferUpdatedEvent(UserEvent):
    service = 'calld'
    name = 'transfer_updated'
    routing_key_fmt = 'calls.transfer.created'
    required_acl_fmt = 'events.transfers.{user_uuid}'

    def __init__(
        self,
        transfer: TransferDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(transfer, tenant_uuid, user_uuid)


class CallTransferAnsweredEvent(UserEvent):
    service = 'calld'
    name = 'transfer_answered'
    routing_key_fmt = 'calls.transfer.edited'
    required_acl_fmt = 'events.transfers.{user_uuid}'

    def __init__(
        self,
        transfer: TransferDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(transfer, tenant_uuid, user_uuid)


class CallTransferCancelledEvent(UserEvent):
    service = 'calld'
    name = 'transfer_cancelled'
    routing_key_fmt = 'calls.transfer.edited'
    required_acl_fmt = 'events.transfers.{user_uuid}'

    def __init__(
        self,
        transfer: TransferDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(transfer, tenant_uuid, user_uuid)


class CallTransferCompletedEvent(UserEvent):
    service = 'calld'
    name = 'transfer_completed'
    routing_key_fmt = 'calls.transfer.edited'
    required_acl_fmt = 'events.transfers.{user_uuid}'

    def __init__(
        self,
        transfer: TransferDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(transfer, tenant_uuid, user_uuid)


class CallTransferAbandonedEvent(UserEvent):
    service = 'calld'
    name = 'transfer_abandoned'
    routing_key_fmt = 'calls.transfer.edited'
    required_acl_fmt = 'events.transfers.{user_uuid}'

    def __init__(
        self,
        transfer: TransferDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(transfer, tenant_uuid, user_uuid)


class CallTransferEndedEvent(UserEvent):
    service = 'calld'
    name = 'transfer_ended'
    routing_key_fmt = 'calls.transfer.deleted'
    required_acl_fmt = 'events.transfers.{user_uuid}'

    def __init__(
        self,
        transfer: TransferDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(transfer, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/calls/parking.py

from __future__ import annotations

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import ParkedCallDict, ParkedCallTimedOutDict, UnparkedCallDict


class CallParkedEvent(TenantEvent):
    service = 'calld'
    name = 'call_parked'
    routing_key_fmt = 'parkings.{parking_id}.calls.updated'
    required_acl_fmt = 'events.parkings.{parking_id}.calls.updated'

    def __init__(self, parked_call: ParkedCallDict, tenant_uuid: UUIDStr):
        super().__init__(parked_call, tenant_uuid)


class CallUnparkedEvent(TenantEvent):
    service = 'calld'
    name = 'call_unparked'
    routing_key_fmt = 'parkings.{parking_id}.calls.updated'
    required_acl_fmt = 'events.parkings.{parking_id}.calls.updated'

    def __init__(self, unparked_call: UnparkedCallDict, tenant_uuid: str):
        super().__init__(unparked_call, tenant_uuid)


class ParkedCallHungupEvent(TenantEvent):
    service = 'calld'
    name = 'parked_call_hungup'
    routing_key_fmt = 'parkings.{parking_id}.calls.updated'
    required_acl_fmt = 'events.parkings.{parking_id}.calls.updated'

    def __init__(self, parked_call: ParkedCallDict, tenant_uuid: str):
        super().__init__(parked_call, tenant_uuid)


class ParkedCallTimedOutEvent(TenantEvent):
    service = 'calld'
    name = 'parked_call_timed_out'
    routing_key_fmt = 'parkings.{parking_id}.calls.updated'
    required_acl_fmt = 'events.parkings.{parking_id}.calls.updated'

    def __init__(self, parked_call: ParkedCallTimedOutDict, tenant_uuid: str):
        super().__init__(parked_call, tenant_uuid)

----------------------------------------

File: accent_bus/resources/calls/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import DateTimeStr, UUIDStr


class ApplicationCallDict(TypedDict, total=False):
    id: str
    caller_id_name: str
    caller_id_number: str
    conversation_id: str
    creation_time: DateTimeStr
    status: str
    on_hold: bool
    is_caller: bool
    dialed_extension: str
    variables: dict[str, str]
    node_uuid: UUIDStr
    moh_uuid: UUIDStr
    muted: bool
    snoops: dict[str, str]
    user_uuid: UUIDStr
    tenant_uuid: UUIDStr


class ApplicationCallPlayDict(TypedDict, total=False):
    uuid: UUIDStr
    uri: str
    language: str


class ApplicationNodeCallDict(TypedDict, total=False):
    id: str


class ApplicationNodeDict(TypedDict, total=False):
    uuid: UUIDStr
    calls: list[ApplicationNodeCallDict]


class ApplicationSnoopDict(TypedDict, total=False):
    uuid: UUIDStr
    snooped_call_id: str
    snooping_call_id: str


class CallDict(TypedDict, total=False):
    bridges: list[str]
    call_id: str
    caller_id_name: str
    caller_id_number: str
    conversation_id: str
    peer_caller_id_name: str
    peer_caller_id_number: str
    creation_time: str
    status: str
    on_hold: bool
    muted: bool
    record_state: str
    talking_to: dict[str, str]
    user_uuid: UUIDStr
    is_caller: bool
    is_video: bool
    dialed_extension: str
    line_id: int
    answer_time: str
    hangup_time: str
    direction: str


class ParkedCallDict(TypedDict, total=False):
    parking_id: int
    call_id: str
    conversation_id: str
    caller_id_name: str
    caller_id_num: str
    parker_caller_id_name: str
    parker_caller_id_num: str
    slot: str
    parked_at: DateTimeStr
    timeout_at: DateTimeStr | None


class UnparkedCallDict(ParkedCallDict, total=False):
    retriever_call_id: str
    retriever_caller_id_name: str
    retriever_caller_id_num: str


class ParkedCallTimedOutDict(ParkedCallDict, total=False):
    dialed_extension: str


class RelocateDict(TypedDict, total=False):
    uuid: UUIDStr
    relocated_call: str
    initiator_call: str
    recipient_call: str
    completions: list[str]
    initiator: str
    timeout: int
    auto_answer: bool


class TransferDict(TypedDict, total=False):
    id: str
    initiator_uuid: UUIDStr
    initiator_tenant_uuid: UUIDStr
    transferred_call: str
    initiator_call: str
    recipient_call: str
    status: str
    flow: str

----------------------------------------

File: accent_bus/resources/chatd/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/chatd/events.py

from __future__ import annotations

from ..common.event import TenantEvent, UserEvent
from ..common.types import UUIDStr
from .types import MessageDict, RoomDict, UserPresenceDict


class PresenceUpdatedEvent(TenantEvent):
    service = 'chatd'
    name = 'chatd_presence_updated'
    routing_key_fmt = 'chatd.users.{uuid}.presences.updated'

    def __init__(
        self,
        user_presence_data: UserPresenceDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(user_presence_data, tenant_uuid)


class UserRoomCreatedEvent(UserEvent):
    service = 'chatd'
    name = 'chatd_user_room_created'
    routing_key_fmt = 'chatd.users.{user_uuid}.rooms.created'

    def __init__(
        self,
        room_data: RoomDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(room_data, tenant_uuid, user_uuid)


class UserRoomMessageCreatedEvent(UserEvent):
    service = 'chatd'
    name = 'chatd_user_room_message_created'
    routing_key_fmt = 'chatd.users.{user_uuid}.rooms.{room_uuid}.messages.created'

    def __init__(
        self,
        message_data: MessageDict,
        room_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(message_data, tenant_uuid, user_uuid)
        if room_uuid is None:
            raise ValueError('room_uuid must have a value')
        self.room_uuid = str(room_uuid)

----------------------------------------

File: accent_bus/resources/chatd/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class LinePresenceDict(TypedDict, total=False):
    id: int
    state: str


class MessageDict(TypedDict, total=False):
    uuid: UUIDStr
    content: str
    alias: str
    user_uuid: UUIDStr
    tenant_uuid: UUIDStr
    accent_uuid: UUIDStr
    created_at: str
    room: RoomDict


class RoomDict(TypedDict, total=False):
    uuid: UUIDStr
    tenant_uuid: UUIDStr
    name: str
    users: list[RoomUserDict]


class RoomUserDict(TypedDict, total=False):
    uuid: UUIDStr
    tenant_uuid: UUIDStr
    accent_uuid: UUIDStr


class UserPresenceDict(TypedDict, total=False):
    uuid: UUIDStr
    tenant_uuid: UUIDStr
    state: str
    status: str
    last_activity: str
    line_state: str
    mobile: bool
    do_not_disturb: bool
    connected: bool
    lines: list[LinePresenceDict]

----------------------------------------

File: accent_bus/resources/common/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/common/abstract.py

from __future__ import annotations

from abc import ABCMeta, abstractmethod
from collections.abc import Mapping
from typing import Any, Protocol

from .acl import escape as escape_acl
from .routing_key import escape as escape_key


class EventProtocol(Protocol):
    __slots__ = ('content',)
    content: Mapping

    def __init__(self, content: Mapping | None = None):
        self.content = content or {}

    def __eq__(self, other: Any) -> bool:
        return (
            self.__class__ == other.__class__
            and self.content == other.content
            and vars(self) == vars(other)
        )

    def __ne__(self, other: Any) -> bool:
        return not self == other

    def __repr__(self) -> str:
        return self.__str__()

    def __str__(self) -> str:
        return '<Event: {} (headers: {}, content: {})>'.format(
            self.name,
            self.headers,
            self.content,
        )

    @property
    @abstractmethod
    def name(self) -> str:
        ...

    @property
    @abstractmethod
    def routing_key_fmt(self) -> str:
        ...

    @property
    def routing_key(self) -> str:
        variables = dict(**self.content)
        variables.update(vars(self), name=self.name)
        variables = {
            key: escape_key(value) if isinstance(value, str) else value
            for key, value in variables.items()
        }
        return self.routing_key_fmt.format(**variables)

    @property
    def required_acl(self) -> str:
        """
        Deprecated, use required_access instead
        """
        if hasattr(self, 'required_acl_fmt'):
            variables = dict(**self.content)
            variables.update(vars(self), name=self.name)
            variables = {
                key: escape_acl(value) if isinstance(value, str) else value
                for key, value in variables.items()
            }
            return self.required_acl_fmt.format(**variables)
        return f'events.{self.routing_key}'

    @property
    def required_access(self) -> str:
        return f'event.{self.name}'

    @property
    def headers(self) -> dict:
        headers = dict(vars(self))
        headers.update(name=self.name)
        return headers

    def marshal(self) -> dict:
        return dict(self.content)

#  NOTE: Deprecated, use EventProtocol instead
class AbstractEvent(EventProtocol, metaclass=ABCMeta):
    def __init__(self, content: dict | None = None):
        self.content = content or {}

----------------------------------------

File: accent_bus/resources/common/acl.py


def escape(acl_part: str) -> str:
    return (
        acl_part.replace('.', '__DOT__')
        .replace('#', '__HASH__')
        .replace('*', '__STAR__')
    )

----------------------------------------

File: accent_bus/resources/common/event.py

from __future__ import annotations

from collections.abc import Mapping

from .abstract import EventProtocol
from .types import UUIDStr


class ServiceEvent(EventProtocol):
    '''
    ### Service-level event base class

    These events are intended for internal use by services and will never
    make it through the websocket.
    '''

    def __init__(self, content: Mapping | None = None):
        self.content = content or {}


class TenantEvent(ServiceEvent):
    '''
    ### Tenant-level event base class

    These events are intended for *all* users of the specified tenant.  They will be
    dispatched to all it's connected users by setting `user_uuid:*` in the headers.

    #### Required property:
        - tenant_uuid
    '''

    def __init__(self, content: Mapping | None, tenant_uuid: UUIDStr):
        super().__init__(content)
        if tenant_uuid is None:
            raise ValueError('tenant_uuid must have a value')
        self.tenant_uuid = str(tenant_uuid)
        setattr(self, 'user_uuid:*', True)


class UserEvent(TenantEvent):
    '''
    ### User-level event base class

    These events are intended for a single user from a specific tenant.  They will be
    dispatched through the websocket to the user by setting `user_uuid:{uuid}`
    in the headers.

    #### Required properties:
        - tenant_uuid
        - user_uuid
    '''

    def __init__(
        self,
        content: Mapping | None,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr | None,
    ):
        super().__init__(content, tenant_uuid)
        delattr(self, 'user_uuid:*')
        self.user_uuid = str(user_uuid) if user_uuid else None

    @property
    def headers(self) -> dict:
        headers = super().headers
        uuid = headers.pop('user_uuid')
        if uuid:
            headers[f'user_uuid:{uuid}'] = True
        return headers


class MultiUserEvent(TenantEvent):
    '''
    ### User-level event base class (targetting multiple users)

    These events are intended for multiple users from a specific tenant.
    They will be dispatched through the websocket by setting `user_uuid:{uuid} = True`
    in the headers for all intended users.

    #### Required properties:
        - tenant_uuid
        - list of user_uuids
    '''

    __slots__ = ('user_uuids',)

    def __init__(
        self,
        content: Mapping | None,
        tenant_uuid: UUIDStr,
        user_uuids: list[UUIDStr],
    ):
        super().__init__(content, tenant_uuid)
        delattr(self, 'user_uuid:*')
        if not isinstance(user_uuids, list):
            raise ValueError('user_uuids must be a list of uuids')
        self.user_uuids = [str(user_uuid) for user_uuid in user_uuids]

    @property
    def headers(self) -> dict:
        headers = super().headers
        for user_uuid in self.user_uuids:
            headers[f'user_uuid:{user_uuid}'] = True
        return headers

----------------------------------------

File: accent_bus/resources/common/routing_key.py


def escape(routing_key_part: str) -> str:
    return (
        routing_key_part.replace('.', '__DOT__')
        .replace('#', '__HASH__')
        .replace('*', '__STAR__')
    )

----------------------------------------

File: accent_bus/resources/common/types.py

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Annotated, Literal

_string_formats = Literal['date', 'date-time', 'uuid']


@dataclass(frozen=True)
class Format:
    format: _string_formats | None = field(default=None)


# Type aliases
UUIDStr = Annotated[str, Format('uuid')]
DateTimeStr = Annotated[str, Format('date-time')]
DateStr = Annotated[str, Format('date')]

----------------------------------------

File: accent_bus/resources/confbridge/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/confbridge/event.py

from ..common.event import ServiceEvent


class ConfBridgeAccentDefaultBridgeEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'confbridge_accent_default_bridge_edited'
    routing_key_fmt = 'config.confbridge_accent_default_bridge.edited'

    def __init__(self) -> None:
        super().__init__()


class ConfBridgeAccentDefaultUserEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'confbridge_accent_default_user_edited'
    routing_key_fmt = 'config.confbridge_accent_default_user.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/conference/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/conference/event.py

from __future__ import annotations

from collections.abc import Mapping
from typing import Any

from ..common.event import MultiUserEvent, TenantEvent, UserEvent
from ..common.types import UUIDStr
from .types import ParticipantDict


class _ConferenceMixin:
    def __init__(self, content: Mapping, conference_id: int, *args: Any):
        super().__init__(content, *args)  # type: ignore[call-arg]
        if not conference_id:
            raise ValueError('conference_id must have a value')
        self.conference_id = conference_id


class ConferenceCreatedEvent(_ConferenceMixin, TenantEvent):
    service = 'confd'
    name = 'conference_created'
    routing_key_fmt = 'config.conferences.created'

    def __init__(self, conference_id: int, tenant_uuid: UUIDStr):
        content = {'id': conference_id}
        super().__init__(content, conference_id, tenant_uuid)


class ConferenceDeletedEvent(_ConferenceMixin, TenantEvent):
    service = 'confd'
    name = 'conference_deleted'
    routing_key_fmt = 'config.conferences.deleted'

    def __init__(self, conference_id: int, tenant_uuid: UUIDStr):
        content = {'id': conference_id}
        super().__init__(content, conference_id, tenant_uuid)


class ConferenceEditedEvent(_ConferenceMixin, TenantEvent):
    service = 'confd'
    name = 'conference_edited'
    routing_key_fmt = 'config.conferences.edited'

    def __init__(self, conference_id: int, tenant_uuid: UUIDStr):
        content = {'id': conference_id}
        super().__init__(content, conference_id, tenant_uuid)


class ConferenceRecordStartedEvent(_ConferenceMixin, TenantEvent):
    service = 'calld'
    name = 'conference_record_started'
    routing_key_fmt = 'conferences.{id}.record'

    def __init__(self, conference_id: int, tenant_uuid: UUIDStr):
        content = {'id': conference_id}
        super().__init__(content, conference_id, tenant_uuid)


class ConferenceRecordStoppedEvent(_ConferenceMixin, TenantEvent):
    service = 'calld'
    name = 'conference_record_stopped'
    routing_key_fmt = 'conferences.{id}.record'

    def __init__(self, conference_id: int, tenant_uuid: UUIDStr):
        content = {'id': conference_id}
        super().__init__(content, conference_id, tenant_uuid)


class ConferenceParticipantJoinedEvent(_ConferenceMixin, MultiUserEvent):
    service = 'calld'
    name = 'conference_participant_joined'
    routing_key_fmt = 'conferences.{conference_id}.participants.joined'

    def __init__(
        self,
        conference_id: int,
        participant: ParticipantDict,
        tenant_uuid: UUIDStr,
        user_uuids: list[str],
    ):
        content = dict(participant, conference_id=conference_id)
        super().__init__(content, conference_id, tenant_uuid, user_uuids)


class ConferenceParticipantLeftEvent(_ConferenceMixin, MultiUserEvent):
    service = 'calld'
    name = 'conference_participant_left'
    routing_key_fmt = 'conferences.{conference_id}.participants.left'

    def __init__(
        self,
        conference_id: int,
        participant: ParticipantDict,
        tenant_uuid: UUIDStr,
        user_uuids: list[str],
    ):
        content = dict(participant, conference_id=conference_id)
        super().__init__(content, conference_id, tenant_uuid, user_uuids)


class ConferenceParticipantMutedEvent(_ConferenceMixin, TenantEvent):
    service = 'calld'
    name = 'conference_participant_muted'
    routing_key_fmt = 'conferences.{conference_id}.participants.mute'

    def __init__(
        self,
        conference_id: int,
        participant: ParticipantDict,
        tenant_uuid: UUIDStr,
    ):
        content = dict(participant, conference_id=conference_id)
        super().__init__(content, conference_id, tenant_uuid)


class ConferenceParticipantUnmutedEvent(_ConferenceMixin, TenantEvent):
    service = 'calld'
    name = 'conference_participant_unmuted'
    routing_key_fmt = 'conferences.{conference_id}.particpants.mute'

    def __init__(
        self,
        conference_id: int,
        participant: ParticipantDict,
        tenant_uuid: UUIDStr,
    ):
        content = dict(participant, conference_id=conference_id)
        super().__init__(content, conference_id, tenant_uuid)


class ConferenceParticipantTalkStartedEvent(_ConferenceMixin, MultiUserEvent):
    service = 'calld'
    name = 'conference_participant_talk_started'
    routing_key_fmt = 'conferences.{conference_id}.participants.talk'

    def __init__(
        self,
        conference_id: int,
        participant: ParticipantDict,
        tenant_uuid: UUIDStr,
        user_uuids: list[str],
    ):
        content = dict(participant, conference_id=conference_id)
        super().__init__(content, conference_id, tenant_uuid, user_uuids)


class ConferenceParticipantTalkStoppedEvent(_ConferenceMixin, MultiUserEvent):
    service = 'calld'
    name = 'conference_participant_talk_stopped'
    routing_key_fmt = 'conferences.{conference_id}.participants.talk'

    def __init__(
        self,
        conference_id: int,
        participant: ParticipantDict,
        tenant_uuid: UUIDStr,
        user_uuids: list[str],
    ):
        content = dict(participant, conference_id=conference_id)
        super().__init__(content, conference_id, tenant_uuid, user_uuids)


class ConferenceUserParticipantJoinedEvent(_ConferenceMixin, UserEvent):
    service = 'calld'
    name = 'conference_user_participant_joined'
    routing_key_fmt = 'conferences.users.{user_uuid}.participants.joined'

    def __init__(
        self,
        conference_id: int,
        participant: ParticipantDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = dict(participant, conference_id=conference_id)
        super().__init__(content, conference_id, tenant_uuid, user_uuid)


class ConferenceUserParticipantLeftEvent(_ConferenceMixin, UserEvent):
    service = 'calld'
    name = 'conference_user_participant_left'
    routing_key_fmt = 'conferences.users.{user_uuid}.participants.left'

    def __init__(
        self,
        conference_id: int,
        participant: ParticipantDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = dict(participant, conference_id=conference_id)
        super().__init__(content, conference_id, tenant_uuid, user_uuid)


class ConferenceUserParticipantTalkStartedEvent(_ConferenceMixin, UserEvent):
    service = 'calld'
    name = 'conference_user_participant_talk_started'
    routing_key_fmt = 'conferences.users.{user_uuid}.participants.talk'

    def __init__(
        self,
        conference_id: int,
        participant: ParticipantDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = dict(participant, conference_id=conference_id)
        super().__init__(content, conference_id, tenant_uuid, user_uuid)


class ConferenceUserParticipantTalkStoppedEvent(_ConferenceMixin, UserEvent):
    service = 'calld'
    name = 'conference_user_participant_talk_stopped'
    routing_key_fmt = 'conferences.users.{user_uuid}.participants.talk'

    def __init__(
        self,
        conference_id: int,
        participant: ParticipantDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = dict(participant, conference_id=conference_id)
        super().__init__(content, conference_id, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/conference/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class ParticipantDict(TypedDict, total=False):
    id: str
    caller_id_name: str
    caller_id_number: str
    muted: bool
    join_time: int
    admin: bool
    language: str
    call_id: str
    user_uuid: UUIDStr

----------------------------------------

File: accent_bus/resources/conference_extension/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/conference_extension/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class ConferenceExtensionAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'conference_extension_associated'
    routing_key_fmt = 'config.conferences.extensions.updated'

    def __init__(
        self,
        conference_id: int,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'conference_id': conference_id,
            'extension_id': extension_id,
        }
        super().__init__(content, tenant_uuid)


class ConferenceExtensionDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'conference_extension_dissociated'
    routing_key_fmt = 'config.conferences.extensions.deleted'

    def __init__(
        self,
        conference_id: int,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'conference_id': conference_id,
            'extension_id': extension_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/configuration/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/configuration/event.py

from ..common.event import ServiceEvent


class LiveReloadEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'live_reload_edited'
    routing_key_fmt = 'config.live_reload.edited'

    def __init__(self, live_reload_enabled: bool):
        content = {'live_reload_enabled': live_reload_enabled}
        super().__init__(content)

----------------------------------------

File: accent_bus/resources/context/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/context/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import ContextDict


class ContextCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'context_created'
    routing_key_fmt = 'config.contexts.created'

    def __init__(self, context_data: ContextDict, tenant_uuid: UUIDStr):
        super().__init__(context_data, tenant_uuid)


class ContextDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'context_deleted'
    routing_key_fmt = 'config.contexts.deleted'

    def __init__(self, context_data: ContextDict, tenant_uuid: UUIDStr):
        super().__init__(context_data, tenant_uuid)


class ContextEditedEvent(TenantEvent):
    service = 'confd'
    name = 'context_edited'
    routing_key_fmt = 'config.contexts.edited'

    def __init__(self, context_data: ContextDict, tenant_uuid: UUIDStr):
        super().__init__(context_data, tenant_uuid)

----------------------------------------

File: accent_bus/resources/context/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class ContextDict(TypedDict, total=False):
    id: int
    name: str
    type: str
    tenant_uuid: UUIDStr

----------------------------------------

File: accent_bus/resources/context_context/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/context_context/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class ContextContextsAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'contexts_associated'
    routing_key_fmt = 'config.contexts.contexts.updated'

    def __init__(
        self,
        context_id: int,
        context_ids: list[int],
        tenant_uuid: UUIDStr,
    ):
        content = {
            'context_id': context_id,
            'context_ids': context_ids,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/device/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/device/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class DeviceCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'device_created'
    routing_key_fmt = 'config.device.created'

    def __init__(self, device_id: str, tenant_uuid: UUIDStr):
        content = {'id': device_id}
        super().__init__(content, tenant_uuid)


class DeviceDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'device_deleted'
    routing_key_fmt = 'config.device.deleted'

    def __init__(self, device_id: str, tenant_uuid: UUIDStr):
        content = {'id': device_id}
        super().__init__(content, tenant_uuid)


class DeviceEditedEvent(TenantEvent):
    service = 'confd'
    name = 'device_edited'
    routing_key_fmt = 'config.device.edited'

    def __init__(self, device_id: str, tenant_uuid: UUIDStr):
        content = {'id': device_id}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/dhcp/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/dhcp/event.py

from ..common.event import ServiceEvent


class DHCPEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'dhcp_edited'
    routing_key_fmt = 'config.dhcp.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/directory/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/directory/event.py

from ..common.event import UserEvent
from ..common.types import UUIDStr


class FavoriteAddedEvent(UserEvent):
    service = 'dird'
    name = 'favorite_added'
    routing_key_fmt = 'directory.{user_uuid}.favorite.created'

    def __init__(
        self,
        source_name: str,
        entry_id: str,
        accent_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'accent_uuid': str(accent_uuid),
            'user_uuid': str(user_uuid),
            'source': source_name,
            'source_entry_id': entry_id,
        }
        super().__init__(content, tenant_uuid, user_uuid)


class FavoriteDeletedEvent(UserEvent):
    service = 'dird'
    name = 'favorite_deleted'
    routing_key_fmt = 'directory.{user_uuid}.favorite.deleted'

    def __init__(
        self,
        source_name: str,
        entry_id: str,
        accent_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'accent_uuid': str(accent_uuid),
            'user_uuid': str(user_uuid),
            'source': source_name,
            'source_entry_id': entry_id,
        }
        super().__init__(content, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/email/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/email/event.py

from ..common.event import ServiceEvent


class EmailConfigUpdatedEvent(ServiceEvent):
    service = 'confd'
    name = 'email_config_updated'
    routing_key_fmt = 'config.email.updated'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/endpoint_custom/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/endpoint_custom/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import EndpointCustomDict


class CustomEndpointCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'custom_endpoint_created'
    routing_key_fmt = 'config.custom_endpoint.created'

    def __init__(
        self,
        endpoint: EndpointCustomDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(endpoint, tenant_uuid)


class CustomEndpointDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'custom_endpoint_deleted'
    routing_key_fmt = 'config.custom_endpoint.deleted'

    def __init__(
        self,
        endpoint: EndpointCustomDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(endpoint, tenant_uuid)


class CustomEndpointEditedEvent(TenantEvent):
    service = 'confd'
    name = 'custom_endpoint_edited'
    routing_key_fmt = 'config.custom_endpoint.edited'

    def __init__(
        self,
        endpoint: EndpointCustomDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(endpoint, tenant_uuid)

----------------------------------------

File: accent_bus/resources/endpoint_custom/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class EndpointCustomLineDict(TypedDict, total=False):
    id: int


class EndpointCustomTrunkDict(TypedDict, total=False):
    id: int


class EndpointCustomDict(TypedDict, total=False):
    id: int
    tenant_uuid: UUIDStr
    interface: str
    trunk: EndpointCustomTrunkDict
    line: EndpointCustomLineDict

----------------------------------------

File: accent_bus/resources/endpoint_iax/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/endpoint_iax/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import EndpointIAXDict


class IAXEndpointCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'iax_endpoint_created'
    routing_key_fmt = 'config.iax_endpoint.created'

    def __init__(self, endpoint: EndpointIAXDict, tenant_uuid: UUIDStr):
        super().__init__(endpoint, tenant_uuid)


class IAXEndpointDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'iax_endpoint_deleted'
    routing_key_fmt = 'config.iax_endpoint.deleted'

    def __init__(self, endpoint: EndpointIAXDict, tenant_uuid: UUIDStr):
        super().__init__(endpoint, tenant_uuid)


class IAXEndpointEditedEvent(TenantEvent):
    service = 'confd'
    name = 'iax_endpoint_edited'
    routing_key_fmt = 'config.iax_endpoint.edited'

    def __init__(self, endpoint: EndpointIAXDict, tenant_uuid: UUIDStr):
        super().__init__(endpoint, tenant_uuid)

----------------------------------------

File: accent_bus/resources/endpoint_iax/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class EndpointIAXTrunkDict(TypedDict, total=False):
    id: int


class EndpointIAXDict(TypedDict, total=False):
    id: int
    tenant_uuid: UUIDStr
    trunk: EndpointIAXTrunkDict

----------------------------------------

File: accent_bus/resources/endpoint_sccp/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/endpoint_sccp/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import EndpointSCCPDict


class SCCPEndpointCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'sccp_endpoint_created'
    routing_key_fmt = 'config.sccp_endpoint.created'

    def __init__(
        self,
        endpoint: EndpointSCCPDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(endpoint, tenant_uuid)


class SCCPEndpointDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'sccp_endpoint_deleted'
    routing_key_fmt = 'config.sccp_endpoint.deleted'

    def __init__(
        self,
        endpoint: EndpointSCCPDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(endpoint, tenant_uuid)


class SCCPEndpointEditedEvent(TenantEvent):
    service = 'confd'
    name = 'sccp_endpoint_edited'
    routing_key_fmt = 'config.sccp_endpoint.edited'

    def __init__(
        self,
        endpoint: EndpointSCCPDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(endpoint, tenant_uuid)

----------------------------------------

File: accent_bus/resources/endpoint_sccp/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class EndpointSCCPLineDict(TypedDict, total=False):
    id: int


class EndpointSCCPDict(TypedDict, total=False):
    id: int
    tenant_uuid: UUIDStr
    line: EndpointSCCPLineDict

----------------------------------------

File: accent_bus/resources/endpoint_sip/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/endpoint_sip/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import EndpointSIPDict


class SIPEndpointCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'sip_endpoint_created'
    routing_key_fmt = 'config.sip_endpoint.created'

    def __init__(self, endpoint: EndpointSIPDict, tenant_uuid: UUIDStr):
        super().__init__(endpoint, tenant_uuid)


class SIPEndpointDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'sip_endpoint_deleted'
    routing_key_fmt = 'config.sip_endpoint.deleted'

    def __init__(self, endpoint: EndpointSIPDict, tenant_uuid: UUIDStr):
        super().__init__(endpoint, tenant_uuid)


class SIPEndpointEditedEvent(TenantEvent):
    service = 'confd'
    name = 'sip_endpoint_edited'
    routing_key_fmt = 'config.sip_endpoint.edited'

    def __init__(self, endpoint: EndpointSIPDict, tenant_uuid: UUIDStr):
        super().__init__(endpoint, tenant_uuid)


class SIPEndpointTemplateCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'sip_endpoint_template_created'
    routing_key_fmt = 'config.sip_endpoint_template.created'

    def __init__(self, endpoint: EndpointSIPDict, tenant_uuid: UUIDStr):
        super().__init__(endpoint, tenant_uuid)


class SIPEndpointTemplateDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'sip_endpoint_template_deleted'
    routing_key_fmt = 'config.sip_endpoint_template.deleted'

    def __init__(self, endpoint: EndpointSIPDict, tenant_uuid: UUIDStr):
        super().__init__(endpoint, tenant_uuid)


class SIPEndpointTemplateEditedEvent(TenantEvent):
    service = 'confd'
    name = 'sip_endpoint_template_edited'
    routing_key_fmt = 'config.sip_endpoint_template.edited'

    def __init__(self, endpoint: EndpointSIPDict, tenant_uuid: UUIDStr):
        super().__init__(endpoint, tenant_uuid)

----------------------------------------

File: accent_bus/resources/endpoint_sip/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class EndpointSIPAuthSectionOptionsDict(TypedDict, total=False):
    username: str


class EndpointSIPLineDict(TypedDict, total=False):
    id: int


class EndpointSIPTrunkDict(TypedDict, total=False):
    id: int


class EndpointSIPRegistrationSectionOptionsDict(TypedDict, total=False):
    client_uri: str


class EndpointSIPDict(TypedDict, total=False):
    uuid: UUIDStr
    tenant_uuid: UUIDStr
    name: str
    label: str
    auth_section_options: EndpointSIPAuthSectionOptionsDict
    regsitration_section_options: EndpointSIPRegistrationSectionOptionsDict
    trunk: EndpointSIPTrunkDict
    line: EndpointSIPLineDict

----------------------------------------

File: accent_bus/resources/extension/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/extension/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class ExtensionCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'extension_created'
    routing_key_fmt = 'config.extensions.created'

    def __init__(
        self,
        extension_id: int,
        exten: str,
        context: str,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'id': int(extension_id),
            'exten': exten,
            'context': context,
        }
        super().__init__(content, tenant_uuid)


class ExtensionDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'extension_deleted'
    routing_key_fmt = 'config.extensions.deleted'

    def __init__(
        self,
        extension_id: int,
        exten: str,
        context: str,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'id': int(extension_id),
            'exten': exten,
            'context': context,
        }
        super().__init__(content, tenant_uuid)


class ExtensionEditedEvent(TenantEvent):
    service = 'confd'
    name = 'extension_edited'
    routing_key_fmt = 'config.extensions.edited'

    def __init__(
        self,
        extension_id: int,
        exten: str,
        context: str,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'id': int(extension_id),
            'exten': exten,
            'context': context,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/extension_feature/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/extension_feature/event.py

from ..common.event import ServiceEvent
from ..common.types import UUIDStr


class ExtensionFeatureEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'extension_feature_edited'
    routing_key_fmt = 'config.extension_feature.edited'

    def __init__(self, feature_extension_uuid: UUIDStr):
        content = {'uuid': feature_extension_uuid}
        super().__init__(content)

----------------------------------------

File: accent_bus/resources/external_app/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/external_app/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import ExternalAppDict


class ExternalAppCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'external_app_created'
    routing_key_fmt = 'config.external_apps.created'

    def __init__(self, app: ExternalAppDict, tenant_uuid: UUIDStr):
        super().__init__(app, tenant_uuid)


class ExternalAppDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'external_app_deleted'
    routing_key_fmt = 'config.external_apps.deleted'

    def __init__(self, app: ExternalAppDict, tenant_uuid: UUIDStr):
        super().__init__(app, tenant_uuid)


class ExternalAppEditedEvent(TenantEvent):
    service = 'confd'
    name = 'external_app_edited'
    routing_key_fmt = 'config.external_apps.edited'

    def __init__(self, app: ExternalAppDict, tenant_uuid: UUIDStr):
        super().__init__(app, tenant_uuid)

----------------------------------------

File: accent_bus/resources/external_app/types.py

from __future__ import annotations

from typing import TypedDict


class ExternalAppDict(TypedDict, total=False):
    name: str

----------------------------------------

File: accent_bus/resources/faxes/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/faxes/event.py

from ..common.event import TenantEvent, UserEvent
from ..common.types import UUIDStr
from .types import FaxDict


class FaxOutboundCreatedEvent(TenantEvent):
    service = 'calld'
    name = 'fax_outbound_created'
    routing_key_fmt = 'faxes.outbound.created'

    def __init__(self, fax: FaxDict, tenant_uuid: UUIDStr):
        super().__init__(fax, tenant_uuid)


class FaxOutboundSucceededEvent(TenantEvent):
    service = 'calld'
    name = 'fax_outbound_succeeded'
    routing_key_fmt = 'faxes.outbound.{id}.succeeded'

    def __init__(self, fax: FaxDict, tenant_uuid: UUIDStr):
        super().__init__(fax, tenant_uuid)


class FaxOutboundFailedEvent(TenantEvent):
    service = 'calld'
    name = 'fax_outbound_failed'
    routing_key_fmt = 'faxes.outbound.{id}.failed'

    def __init__(self, fax: FaxDict, tenant_uuid: UUIDStr):
        super().__init__(fax, tenant_uuid)


class FaxOutboundUserCreatedEvent(UserEvent):
    service = 'calld'
    name = 'fax_outbound_user_created'
    routing_key_fmt = 'faxes.outbound.users.{user_uuid}.created'

    def __init__(
        self,
        fax: FaxDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(fax, tenant_uuid, user_uuid)


class FaxOutboundUserSucceededEvent(UserEvent):
    service = 'calld'
    name = 'fax_outbound_user_succeeded'
    routing_key_fmt = 'faxes.outbound.users.{user_uuid}.succeeded'

    def __init__(
        self,
        fax: FaxDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(fax, tenant_uuid, user_uuid)


class FaxOutboundUserFailedEvent(UserEvent):
    service = 'calld'
    name = 'fax_outbound_user_failed'
    routing_key_fmt = 'faxes.outbound.users.{user_uuid}.failed'

    def __init__(
        self,
        fax: FaxDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(fax, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/faxes/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class FaxDict(TypedDict, total=False):
    id: str
    call_id: str
    extension: str
    context: str
    caller_id: str
    ivr_extension: str
    wait_time: int
    user_uuid: UUIDStr
    tenant_uuid: UUIDStr

----------------------------------------

File: accent_bus/resources/features/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/features/event.py

from ..common.event import ServiceEvent


class FeaturesApplicationmapEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'features_applicationmap_edited'
    routing_key_fmt = 'config.features_applicationmap.edited'

    def __init__(self) -> None:
        super().__init__()


class FeaturesFeaturemapEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'features_featuremap_edited'
    routing_key_fmt = 'config.features_featuremap.edited'

    def __init__(self) -> None:
        super().__init__()


class FeaturesGeneralEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'features_general_edited'
    routing_key_fmt = 'config.features_general.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/func_key/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/func_key/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class FuncKeyTemplateCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'func_key_template_created'
    routing_key_fmt = 'config.funckey.template.created'

    def __init__(self, template_id: int, tenant_uuid: UUIDStr):
        content = {'id': template_id}
        super().__init__(content, tenant_uuid)


class FuncKeyTemplateDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'func_key_template_deleted'
    routing_key_fmt = 'config.funckey.template.deleted'

    def __init__(self, template_id: int, tenant_uuid: UUIDStr):
        content = {'id': template_id}
        super().__init__(content, tenant_uuid)


class FuncKeyTemplateEditedEvent(TenantEvent):
    service = 'confd'
    name = 'func_key_template_edited'
    routing_key_fmt = 'config.funckey.template.edited'

    def __init__(self, template_id: int, tenant_uuid: UUIDStr):
        content = {'id': template_id}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/group/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/group/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import GroupDict


class GroupCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'group_created'
    routing_key_fmt = 'config.groups.created'

    def __init__(self, group: GroupDict, tenant_uuid: UUIDStr):
        super().__init__(group, tenant_uuid)


class GroupDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'group_deleted'
    routing_key_fmt = 'config.groups.deleted'

    def __init__(self, group: GroupDict, tenant_uuid: UUIDStr):
        super().__init__(group, tenant_uuid)


class GroupEditedEvent(TenantEvent):
    service = 'confd'
    name = 'group_edited'
    routing_key_fmt = 'config.groups.edited'

    def __init__(self, group: GroupDict, tenant_uuid: UUIDStr):
        super().__init__(group, tenant_uuid)


class GroupFallbackEditedEvent(TenantEvent):
    service = 'confd'
    name = 'group_fallback_edited'
    routing_key_fmt = 'config.groups.fallbacks.edited'

    def __init__(
        self,
        group_id: int,
        group_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'id': group_id,
            'uuid': str(group_uuid),
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/group/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class GroupDict(TypedDict, total=False):
    id: int
    uuid: UUIDStr

----------------------------------------

File: accent_bus/resources/group_call_permission/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/group_call_permission/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class GroupCallPermissionAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'group_call_permission_associated'
    routing_key_fmt = 'config.groups.{group_uuid}.callpermissions.updated'

    def __init__(
        self,
        group_id: int,
        group_uuid: UUIDStr,
        call_permission_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'group_id': group_id,
            'group_uuid': str(group_uuid),
            'call_permission_id': call_permission_id,
        }
        super().__init__(content, tenant_uuid)


class GroupCallPermissionDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'group_call_permission_dissociated'
    routing_key_fmt = 'config.groups.{group_uuid}.callpermissions.deleted'

    def __init__(
        self,
        group_id: int,
        group_uuid: UUIDStr,
        call_permission_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'group_id': group_id,
            'group_uuid': str(group_uuid),
            'call_permission_id': call_permission_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/group_extension/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/group_extension/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class GroupExtensionAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'group_extension_associated'
    routing_key_fmt = 'config.groups.extensions.updated'

    def __init__(
        self,
        group_id: int,
        group_uuid: UUIDStr,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'group_id': group_id,
            'group_uuid': str(group_uuid),
            'extension_id': extension_id,
        }
        super().__init__(content, tenant_uuid)


class GroupExtensionDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'group_extension_dissociated'
    routing_key_fmt = 'config.groups.extensions.deleted'

    def __init__(
        self,
        group_id: int,
        group_uuid: UUIDStr,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'group_id': group_id,
            'group_uuid': str(group_uuid),
            'extension_id': extension_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/group_member/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/group_member/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import GroupExtensionDict


class GroupMemberUsersAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'group_member_users_associated'
    routing_key_fmt = 'config.groups.members.users.updated'

    def __init__(
        self,
        group_id: int,
        group_uuid: UUIDStr,
        users: list[str],
        tenant_uuid: UUIDStr,
    ):
        content = {
            'group_id': group_id,
            'group_uuid': str(group_uuid),
            'user_uuids': users,
        }
        super().__init__(content, tenant_uuid)


class GroupMemberExtensionsAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'group_member_extensions_associated'
    routing_key_fmt = 'config.groups.members.extensions.updated'

    def __init__(
        self,
        group_id: int,
        group_uuid: UUIDStr,
        extensions: list[GroupExtensionDict],
        tenant_uuid: UUIDStr,
    ):
        content = {
            'group_id': group_id,
            'group_uuid': str(group_uuid),
            'extensions': extensions,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/group_member/types.py

from __future__ import annotations

from typing import TypedDict


class GroupExtensionDict(TypedDict, total=False):
    exten: str
    context: str

----------------------------------------

File: accent_bus/resources/group_schedule/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/group_schedule/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class GroupScheduleAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'group_schedule_associated'
    routing_key_fmt = 'config.groups.schedules.updated'

    def __init__(
        self,
        group_id: int,
        group_uuid: UUIDStr,
        schedule_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'group_id': group_id,
            'group_uuid': str(group_uuid),
            'schedule_id': schedule_id,
        }
        super().__init__(content, tenant_uuid)


class GroupScheduleDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'group_schedule_dissociated'
    routing_key_fmt = 'config.groups.schedules.deleted'

    def __init__(
        self,
        group_id: int,
        group_uuid: UUIDStr,
        schedule_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'group_id': group_id,
            'group_uuid': str(group_uuid),
            'schedule_id': schedule_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/ha/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/ha/event.py

from ..common.event import ServiceEvent


class HAEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'ha_edited'
    routing_key_fmt = 'config.ha.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/hep/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/hep/event.py

from ..common.event import ServiceEvent


class HEPGeneralEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'hep_general_edited'
    routing_key_fmt = 'config.hep_general.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/iax_callnumberlimits/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/iax_callnumberlimits/event.py

from ..common.event import ServiceEvent


class IAXCallNumberLimitsEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'iax_callnumberlimits_edited'
    routing_key_fmt = 'config.iax_callnumberlimits.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/iax_general/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/iax_general/event.py

from ..common.event import ServiceEvent


class IAXGeneralEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'iax_general_edited'
    routing_key_fmt = 'config.iax_general.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/incall/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/incall/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class IncallCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'incall_created'
    routing_key_fmt = 'config.incalls.created'

    def __init__(self, incall_id: int, tenant_uuid: UUIDStr):
        content = {'id': incall_id}
        super().__init__(content, tenant_uuid)


class IncallDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'incall_deleted'
    routing_key_fmt = 'config.incalls.deleted'

    def __init__(self, incall_id: int, tenant_uuid: UUIDStr):
        content = {'id': incall_id}
        super().__init__(content, tenant_uuid)


class IncallEditedEvent(TenantEvent):
    service = 'confd'
    name = 'incall_edited'
    routing_key_fmt = 'config.incalls.edited'

    def __init__(self, incall_id: int, tenant_uuid: UUIDStr):
        content = {'id': incall_id}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/incall_extension/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/incall_extension/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class IncallExtensionAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'incall_extension_associated'
    routing_key_fmt = 'config.incalls.extensions.updated'

    def __init__(
        self,
        incall_id: int,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'incall_id': incall_id,
            'extension_id': extension_id,
        }
        super().__init__(content, tenant_uuid)


class IncallExtensionDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'incall_extension_dissociated'
    routing_key_fmt = 'config.incalls.extensions.deleted'

    def __init__(
        self,
        incall_id: int,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'incall_id': incall_id,
            'extension_id': extension_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/incall_schedule/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/incall_schedule/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class IncallScheduleAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'incall_schedule_associated'
    routing_key_fmt = 'config.incalls.schedules.updated'

    def __init__(
        self,
        incall_id: int,
        schedule_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'incall_id': incall_id,
            'schedule_id': schedule_id,
        }
        super().__init__(content, tenant_uuid)


class IncallScheduleDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'incall_schedule_dissociated'
    routing_key_fmt = 'config.incalls.schedules.deleted'

    def __init__(
        self,
        incall_id: int,
        schedule_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'incall_id': incall_id,
            'schedule_id': schedule_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/ingress_http/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/ingress_http/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import IngressHTTPDict


class IngressHTTPCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'ingress_http_created'
    routing_key_fmt = 'config.ingresses.http.created'

    def __init__(
        self,
        ingress_http: IngressHTTPDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(ingress_http, tenant_uuid)


class IngressHTTPDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'ingress_http_deleted'
    routing_key_fmt = 'config.ingresses.http.deleted'

    def __init__(
        self,
        ingress_http: IngressHTTPDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(ingress_http, tenant_uuid)


class IngressHTTPEditedEvent(TenantEvent):
    service = 'confd'
    name = 'ingress_http_edited'
    routing_key_fmt = 'config.ingresses.http.edited'

    def __init__(
        self,
        ingress_http: IngressHTTPDict,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(ingress_http, tenant_uuid)

----------------------------------------

File: accent_bus/resources/ingress_http/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class IngressHTTPDict(TypedDict, total=False):
    uuid: UUIDStr
    tenant_uuid: UUIDStr
    uri: str

----------------------------------------

File: accent_bus/resources/ivr/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/ivr/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class IVRCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'ivr_created'
    routing_key_fmt = 'config.ivr.created'

    def __init__(self, ivr_id: int, tenant_uuid: UUIDStr):
        content = {'id': ivr_id}
        super().__init__(content, tenant_uuid)


class IVRDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'ivr_deleted'
    routing_key_fmt = 'config.ivr.deleted'

    def __init__(self, ivr_id: int, tenant_uuid: UUIDStr):
        content = {'id': ivr_id}
        super().__init__(content, tenant_uuid)


class IVREditedEvent(TenantEvent):
    service = 'confd'
    name = 'ivr_edited'
    routing_key_fmt = 'config.ivr.edited'

    def __init__(self, ivr_id: int, tenant_uuid: UUIDStr):
        content = {'id': ivr_id}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/line/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/line/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import LineDict


class LineCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_created'
    routing_key_fmt = 'config.line.created'

    def __init__(self, line: LineDict, tenant_uuid: UUIDStr):
        super().__init__(line, tenant_uuid)


class LineDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'line_deleted'
    routing_key_fmt = 'config.line.deleted'

    def __init__(self, line: LineDict, tenant_uuid: UUIDStr):
        super().__init__(line, tenant_uuid)


class LineEditedEvent(TenantEvent):
    service = 'confd'
    name = 'line_edited'
    routing_key_fmt = 'config.line.edited'

    def __init__(self, line: LineDict, tenant_uuid: UUIDStr):
        super().__init__(line, tenant_uuid)


class LineStatusUpdatedEvent(TenantEvent):
    service = 'calld'
    name = 'line_status_updated'
    routing_key_fmt = 'lines.{id}.status.updated'

    def __init__(
        self,
        line_id: int,
        technology: str,
        endpoint_name: str,
        endpoint_registered: bool,
        endpoint_current_call_count: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'id': line_id,
            'technology': technology,
            'name': endpoint_name,
            'registered': endpoint_registered,
            'current_call_count': endpoint_current_call_count,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/line/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class LineDict(TypedDict, total=False):
    id: int
    protocol: str
    name: str
    tenant_uuid: UUIDStr

----------------------------------------

File: accent_bus/resources/line_application/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/line_application/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import ApplicationDict, LineDict


class LineApplicationAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_application_associated'
    routing_key_fmt = 'config.lines.{line[id]}.applications.{application[uuid]}.updated'

    def __init__(
        self,
        line: LineDict,
        application: ApplicationDict,
        tenant_uuid: UUIDStr,
    ):
        content = {'line': line, 'application': application}
        super().__init__(content, tenant_uuid)


class LineApplicationDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_application_dissociated'
    routing_key_fmt = 'config.lines.{line[id]}.applications.{application[uuid]}.deleted'

    def __init__(
        self,
        line: LineDict,
        application: ApplicationDict,
        tenant_uuid: UUIDStr,
    ):
        content = {'line': line, 'application': application}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/line_application/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class ApplicationDict(TypedDict, total=False):
    uuid: UUIDStr


class LineEndpointSIPDict(TypedDict, total=False):
    uuid: UUIDStr


class LineEndpointSCCPDict(TypedDict, total=False):
    id: int


class LineEndpointCustomDict(TypedDict, total=False):
    id: int


class LineDict(TypedDict, total=False):
    id: int
    name: str
    endpoint_sip: LineEndpointSIPDict
    endpoint_sccp: LineEndpointSCCPDict
    endpoint_custom: LineEndpointCustomDict

----------------------------------------

File: accent_bus/resources/line_device/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/line_device/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import DeviceDict, LineDict


class LineDeviceAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_device_associated'
    routing_key_fmt = 'config.lines.{line[id]}.devices.{device[id]}.updated'

    def __init__(
        self,
        line: LineDict,
        device: DeviceDict,
        tenant_uuid: UUIDStr,
    ):
        content = {'line': line, 'device': device}
        super().__init__(content, tenant_uuid)


class LineDeviceDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_device_dissociated'
    routing_key_fmt = 'config.lines.{line[id]}.devices.{device[id]}.deleted'

    def __init__(
        self,
        line: LineDict,
        device: DeviceDict,
        tenant_uuid: UUIDStr,
    ):
        content = {'line': line, 'device': device}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/line_device/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class DeviceDict(TypedDict, total=False):
    id: str


class LineEndpointSIPDict(TypedDict, total=False):
    uuid: UUIDStr


class LineEndpointSCCPDict(TypedDict, total=False):
    id: int


class LineEndpointCustomDict(TypedDict, total=False):
    id: int


class LineDict(TypedDict, total=False):
    id: int
    name: str
    endpoint_sip: LineEndpointSIPDict
    endpoint_sccp: LineEndpointSCCPDict
    endpoint_custom: LineEndpointCustomDict

----------------------------------------

File: accent_bus/resources/line_endpoint/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/line_endpoint/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import (
    LineDict,
    LineEndpointCustomDict,
    LineEndpointSCCPDict,
    LineEndpointSIPDict,
)


class LineEndpointSIPAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_endpoint_sip_associated'
    routing_key_fmt = (
        'config.lines.{line[id]}.endpoints.sip.{endpoint_sip[uuid]}.updated'
    )

    def __init__(
        self,
        line: LineDict,
        sip: LineEndpointSIPDict,
        tenant_uuid: UUIDStr,
    ):
        content = {'line': line, 'endpoint_sip': sip}
        super().__init__(content, tenant_uuid)


class LineEndpointSIPDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_endpoint_sip_dissociated'
    routing_key_fmt = (
        'config.lines.{line[id]}.endpoints.sip.{endpoint_sip[uuid]}.deleted'
    )

    def __init__(
        self,
        line: LineDict,
        sip: LineEndpointSIPDict,
        tenant_uuid: UUIDStr,
    ):
        content = {'line': line, 'endpoint_sip': sip}
        super().__init__(content, tenant_uuid)


class LineEndpointSCCPAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_endpoint_sccp_associated'
    routing_key_fmt = (
        'config.lines.{line[id]}.endpoints.sccp.{endpoint_sccp[id]}.updated'
    )

    def __init__(
        self,
        line: LineDict,
        sccp: LineEndpointSCCPDict,
        tenant_uuid: UUIDStr,
    ):
        content = {'line': line, 'endpoint_sccp': sccp}
        super().__init__(content, tenant_uuid)


class LineEndpointSCCPDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_endpoint_sccp_dissociated'
    routing_key_fmt = (
        'config.lines.{line[id]}.endpoints.sccp.{endpoint_sccp[id]}.deleted'
    )

    def __init__(
        self,
        line: LineDict,
        sccp: LineEndpointSCCPDict,
        tenant_uuid: UUIDStr,
    ):
        content = {'line': line, 'endpoint_sccp': sccp}
        super().__init__(content, tenant_uuid)


class LineEndpointCustomAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_endpoint_custom_associated'
    routing_key_fmt = (
        'config.lines.{line[id]}.endpoints.custom.{endpoint_custom[id]}.updated'
    )

    def __init__(
        self,
        line: LineDict,
        custom: LineEndpointCustomDict,
        tenant_uuid: UUIDStr,
    ):
        content = {'line': line, 'endpoint_custom': custom}
        super().__init__(content, tenant_uuid)


class LineEndpointCustomDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_endpoint_custom_dissociated'
    routing_key_fmt = (
        'config.lines.{line[id]}.endpoints.custom.{endpoint_custom[id]}.deleted'
    )

    def __init__(
        self,
        line: LineDict,
        custom: LineEndpointCustomDict,
        tenant_uuid: UUIDStr,
    ):
        content = {'line': line, 'endpoint_custom': custom}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/line_endpoint/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class EndpointSIPAuthSectionOptionsDict(TypedDict, total=False):
    username: str


class LineEndpointSIPDict(TypedDict, total=False):
    uuid: UUIDStr
    tenant_uuid: UUIDStr
    label: str
    name: str
    auth_section_options: EndpointSIPAuthSectionOptionsDict


class LineEndpointSCCPDict(TypedDict, total=False):
    id: int
    tenant_uuid: UUIDStr


class LineEndpointCustomDict(TypedDict, total=False):
    id: int
    tenant_uuid: UUIDStr
    interface: str


class LineDict(TypedDict, total=False):
    id: int
    tenant_uuid: UUIDStr
    name: str

----------------------------------------

File: accent_bus/resources/line_extension/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/line_extension/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class LineExtensionAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_extension_associated'
    routing_key_fmt = 'config.line_extension_associated.updated'

    def __init__(
        self,
        line_id: int,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {'line_id': line_id, 'extension_id': extension_id}
        super().__init__(content, tenant_uuid)


class LineExtensionDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'line_extension_dissociated'
    routing_key_fmt = 'config.line_extension_associated.deleted'

    def __init__(
        self,
        line_id: int,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {'line_id': line_id, 'extension_id': extension_id}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/localization/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/localization/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import LocalizationDict


class LocalizationEditedEvent(TenantEvent):
    service = 'confd'
    name = 'localization_edited'
    routing_key_fmt = 'config.localization.edited'

    def __init__(self, localization: LocalizationDict, tenant_uuid: UUIDStr) -> None:
        super().__init__(localization, tenant_uuid)

----------------------------------------

File: accent_bus/resources/localization/types.py

from __future__ import annotations

from typing import TypedDict


class LocalizationDict(TypedDict):
    country: str

----------------------------------------

File: accent_bus/resources/meeting/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/meeting/event.py

from __future__ import annotations

from collections.abc import Mapping
from typing import Any

from ..common.event import TenantEvent, UserEvent
from ..common.types import UUIDStr
from .types import MeetingAuthorizationDict, MeetingDict, MeetingParticipantDict


class _MeetingMixin:
    def __init__(
        self,
        content: Mapping,
        meeting_uuid: UUIDStr,
        *args: Any,
    ):
        super().__init__(content, *args)  # type: ignore[call-arg]
        if meeting_uuid is None:
            raise ValueError('meeting_uuid must have a value')
        self.meeting_uuid = str(meeting_uuid)


class MeetingCreatedEvent(_MeetingMixin, TenantEvent):
    service = 'confd'
    name = 'meeting_created'
    routing_key_fmt = 'config.meetings.created'

    def __init__(self, meeting: MeetingDict, tenant_uuid: UUIDStr):
        super().__init__(meeting, meeting['uuid'], tenant_uuid)


class MeetingDeletedEvent(_MeetingMixin, TenantEvent):
    service = 'confd'
    name = 'meeting_deleted'
    routing_key_fmt = 'config.meetings.deleted'

    def __init__(self, meeting: MeetingDict, tenant_uuid: UUIDStr):
        super().__init__(meeting, meeting['uuid'], tenant_uuid)


class MeetingEditedEvent(_MeetingMixin, TenantEvent):
    service = 'confd'
    name = 'meeting_updated'
    routing_key_fmt = 'config.meetings.updated'

    def __init__(self, meeting: MeetingDict, tenant_uuid: UUIDStr):
        super().__init__(meeting, meeting['uuid'], tenant_uuid)


class MeetingProgressEvent(_MeetingMixin, TenantEvent):
    service = 'confd'
    name = 'meeting_progress'
    routing_key_fmt = 'config.meetings.progress'

    def __init__(
        self,
        meeting: MeetingDict,
        status: str,
        tenant_uuid: UUIDStr,
    ):
        content = dict(meeting)
        content['status'] = status
        super().__init__(content, meeting['uuid'], tenant_uuid)


class MeetingUserProgressEvent(_MeetingMixin, UserEvent):
    service = 'confd'
    name = 'meeting_user_progress'
    routing_key_fmt = 'config.users.{user_uuid}.meetings.progress'

    def __init__(
        self,
        meeting: MeetingDict,
        status: str,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = dict(meeting)
        content['status'] = status
        content['user_uuid'] = user_uuid
        super().__init__(content, meeting['uuid'], tenant_uuid, user_uuid)


class MeetingParticipantJoinedEvent(_MeetingMixin, TenantEvent):
    service = 'calld'
    name = 'meeting_participant_joined'
    routing_key_fmt = 'meetings.{meeting_uuid}.participants.joined'

    def __init__(
        self,
        participant: MeetingParticipantDict,
        meeting_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = dict(participant, meeting_uuid=meeting_uuid)
        super().__init__(content, meeting_uuid, tenant_uuid)


class MeetingParticipantLeftEvent(_MeetingMixin, TenantEvent):
    service = 'calld'
    name = 'meeting_participant_left'
    routing_key_fmt = 'meetings.{meeting_uuid}.participants.left'

    def __init__(
        self,
        participant: MeetingParticipantDict,
        meeting_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = dict(participant, meeting_uuid=meeting_uuid)
        super().__init__(content, meeting_uuid, tenant_uuid)


class MeetingUserParticipantJoinedEvent(_MeetingMixin, UserEvent):
    service = 'calld'
    name = 'meeting_user_participant_joined'
    routing_key_fmt = 'meetings.users.{user_uuid}.participants.joined'
    required_acl_fmt = 'events.users.{user_uuid}.meetings.participants.joined'

    def __init__(
        self,
        participant: MeetingParticipantDict,
        meeting_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = dict(participant, meeting_uuid=meeting_uuid)
        super().__init__(content, meeting_uuid, tenant_uuid, user_uuid)


class MeetingUserParticipantLeftEvent(_MeetingMixin, UserEvent):
    service = 'calld'
    name = 'meeting_user_participant_left'
    routing_key_fmt = 'meetings.users.{user_uuid}.participants.left'
    required_acl_fmt = 'events.users.{user_uuid}.meetings.participants.left'

    def __init__(
        self,
        participant: MeetingParticipantDict,
        meeting_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = dict(participant, meeting_uuid=meeting_uuid)
        super().__init__(content, meeting_uuid, tenant_uuid, user_uuid)


class MeetingAuthorizationCreatedEvent(_MeetingMixin, TenantEvent):
    service = 'confd'
    name = 'meeting_guest_authorization_created'
    routing_key_fmt = 'config.meeting_guest_authorizations.created'

    def __init__(
        self,
        meeting_authorization: MeetingAuthorizationDict,
        meeting_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(meeting_authorization, meeting_uuid, tenant_uuid)


class MeetingAuthorizationDeletedEvent(_MeetingMixin, TenantEvent):
    service = 'confd'
    name = 'meeting_guest_authorization_deleted'
    routing_key_fmt = 'config.meeting_guest_authorizations.deleted'

    def __init__(
        self,
        meeting_authorization: MeetingAuthorizationDict,
        meeting_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(meeting_authorization, meeting_uuid, tenant_uuid)


class MeetingAuthorizationEditedEvent(_MeetingMixin, TenantEvent):
    service = 'confd'
    name = 'meeting_guest_authorization_updated'
    routing_key_fmt = 'config.meeting_guest_authorizations.updated'

    def __init__(
        self,
        meeting_authorization: MeetingAuthorizationDict,
        meeting_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(meeting_authorization, meeting_uuid, tenant_uuid)


class MeetingUserAuthorizationCreatedEvent(_MeetingMixin, UserEvent):
    service = 'confd'
    name = 'meeting_user_guest_authorization_created'
    routing_key_fmt = 'config.users.{user_uuid}.meeting_guest_authorizations.created'
    required_acl_fmt = 'events.users.{user_uuid}.meeting_guest_authorizations.created'

    def __init__(
        self,
        meeting_authorization: MeetingAuthorizationDict,
        meeting_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = dict(meeting_authorization, user_uuid=user_uuid)
        super().__init__(content, meeting_uuid, tenant_uuid, user_uuid)


class MeetingUserAuthorizationDeletedEvent(_MeetingMixin, UserEvent):
    service = 'confd'
    name = 'meeting_user_guest_authorization_deleted'
    routing_key_fmt = 'config.users.{user_uuid}.meeting_guest_authorizations.deleted'
    required_acl_fmt = 'events.users.{user_uuid}.meeting_guest_authorizations.deleted'

    def __init__(
        self,
        meeting_authorization: MeetingAuthorizationDict,
        meeting_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = dict(meeting_authorization, user_uuid=user_uuid)
        super().__init__(content, meeting_uuid, tenant_uuid, user_uuid)


class MeetingUserAuthorizationEditedEvent(_MeetingMixin, UserEvent):
    service = 'confd'
    name = 'meeting_user_guest_authorization_updated'
    routing_key_fmt = 'config.users.{user_uuid}.meeting_guest_authorizations.updated'
    required_acl_fmt = 'events.users.{user_uuid}.meeting_guest_authorizations.updated'

    def __init__(
        self,
        meeting_authorization: MeetingAuthorizationDict,
        meeting_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = dict(meeting_authorization, user_uuid=user_uuid)
        super().__init__(content, meeting_uuid, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/meeting/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class MeetingDict(TypedDict, total=False):
    uuid: UUIDStr
    name: str
    owner_uuids: list[UUIDStr]
    ingress_http_uri: str
    guest_sip_authorization: str | None  # b64 encoded


class MeetingAuthorizationDict(TypedDict, total=False):
    uuid: UUIDStr
    meeting_uuid: UUIDStr
    guest_uuid: UUIDStr
    guest_name: str
    status: str
    creation_time: str


class MeetingParticipantDict(TypedDict, total=False):
    id: str
    caller_id_name: str
    caller_id_number: str
    call_id: str
    user_uuid: UUIDStr | None

----------------------------------------

File: accent_bus/resources/moh/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/moh/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import MOHDict


class MOHCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'moh_created'
    routing_key_fmt = 'config.moh.created'

    def __init__(self, moh: MOHDict, tenant_uuid: UUIDStr):
        super().__init__(moh, tenant_uuid)


class MOHDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'moh_deleted'
    routing_key_fmt = 'config.moh.deleted'

    def __init__(self, moh: MOHDict, tenant_uuid: UUIDStr):
        super().__init__(moh, tenant_uuid)


class MOHEditedEvent(TenantEvent):
    service = 'confd'
    name = 'moh_edited'
    routing_key_fmt = 'config.moh.edited'

    def __init__(self, moh: MOHDict, tenant_uuid: UUIDStr):
        super().__init__(moh, tenant_uuid)

----------------------------------------

File: accent_bus/resources/moh/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class MOHDict(TypedDict, total=False):
    uuid: UUIDStr
    tenant_uuid: UUIDStr
    name: str

----------------------------------------

File: accent_bus/resources/outcall/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/outcall/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class OutcallCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'outcall_created'
    routing_key_fmt = 'config.outcalls.created'

    def __init__(self, outcall_id: int, tenant_uuid: UUIDStr):
        content = {'id': outcall_id}
        super().__init__(content, tenant_uuid)


class OutcallDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'outcall_deleted'
    routing_key_fmt = 'config.outcalls.deleted'

    def __init__(self, outcall_id: int, tenant_uuid: UUIDStr):
        content = {'id': outcall_id}
        super().__init__(content, tenant_uuid)


class OutcallEditedEvent(TenantEvent):
    service = 'confd'
    name = 'outcall_edited'
    routing_key_fmt = 'config.outcalls.edited'

    def __init__(self, outcall_id: int, tenant_uuid: UUIDStr):
        content = {'id': outcall_id}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/outcall_call_permission/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/outcall_call_permission/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class OutcallCallPermissionAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'outcall_call_permission_associated'
    routing_key_fmt = 'config.outcalls.{outcall_id}.callpermissions.updated'

    def __init__(
        self,
        outcall_id: int,
        call_permission_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'outcall_id': outcall_id,
            'call_permission_id': call_permission_id,
        }
        super().__init__(content, tenant_uuid)


class OutcallCallPermissionDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'outcall_call_permission_dissociated'
    routing_key_fmt = 'config.outcalls.{outcall_id}.callpermissions.deleted'

    def __init__(
        self,
        outcall_id: int,
        call_permission_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'outcall_id': outcall_id,
            'call_permission_id': call_permission_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/outcall_extension/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/outcall_extension/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class OutcallExtensionAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'outcall_extension_associated'
    routing_key_fmt = 'config.outcalls.extensions.updated'

    def __init__(
        self,
        outcall_id: int,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'outcall_id': outcall_id,
            'extension_id': extension_id,
        }
        super().__init__(content, tenant_uuid)


class OutcallExtensionDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'outcall_extension_dissociated'
    routing_key_fmt = 'config.outcalls.extensions.deleted'

    def __init__(
        self,
        outcall_id: int,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'outcall_id': outcall_id,
            'extension_id': extension_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/outcall_schedule/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/outcall_schedule/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class OutcallScheduleAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'outcall_schedule_associated'
    routing_key_fmt = 'config.outcalls.schedules.updated'

    def __init__(
        self,
        outcall_id: int,
        schedule_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'outcall_id': outcall_id,
            'schedule_id': schedule_id,
        }
        super().__init__(content, tenant_uuid)


class OutcallScheduleDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'outcall_schedule_dissociated'
    routing_key_fmt = 'config.outcalls.schedules.deleted'

    def __init__(
        self,
        outcall_id: int,
        schedule_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'outcall_id': outcall_id,
            'schedule_id': schedule_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/outcall_trunk/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/outcall_trunk/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class OutcallTrunksAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'outcall_trunks_associated'
    routing_key_fmt = 'config.outcalls.trunks.updated'

    def __init__(
        self,
        outcall_id: int,
        trunk_ids: list[int],
        tenant_uuid: UUIDStr,
    ):
        content = {
            'outcall_id': outcall_id,
            'trunk_ids': trunk_ids,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/paging/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/paging/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class PagingCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'paging_created'
    routing_key_fmt = 'config.pagings.created'

    def __init__(self, paging_id: int, tenant_uuid: UUIDStr):
        content = {'id': paging_id}
        super().__init__(content, tenant_uuid)


class PagingDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'paging_deleted'
    routing_key_fmt = 'config.pagings.deleted'

    def __init__(self, paging_id: int, tenant_uuid: UUIDStr):
        content = {'id': paging_id}
        super().__init__(content, tenant_uuid)


class PagingEditedEvent(TenantEvent):
    service = 'confd'
    name = 'paging_edited'
    routing_key_fmt = 'config.pagings.edited'

    def __init__(self, paging_id: int, tenant_uuid: UUIDStr):
        content = {'id': paging_id}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/paging_user/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/paging_user/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class PagingCallerUsersAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'paging_caller_users_associated'
    routing_key_fmt = 'config.pagings.callers.users.updated'

    def __init__(
        self,
        paging_id: int,
        users: list[str],
        tenant_uuid: UUIDStr,
    ):
        content = {
            'paging_id': paging_id,
            'user_uuids': users,
        }
        super().__init__(content, tenant_uuid)


class PagingMemberUsersAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'paging_member_users_associated'
    routing_key_fmt = 'config.pagings.members.users.updated'

    def __init__(
        self,
        paging_id: int,
        users: list[str],
        tenant_uuid: UUIDStr,
    ):
        content = {
            'paging_id': paging_id,
            'user_uuids': users,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/parking_lot/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/parking_lot/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class ParkingLotCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'parking_lot_created'
    routing_key_fmt = 'config.parkinglots.created'

    def __init__(self, parking_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(parking_id)}
        super().__init__(content, tenant_uuid)


class ParkingLotDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'parking_lot_deleted'
    routing_key_fmt = 'config.parkinglots.deleted'

    def __init__(self, parking_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(parking_id)}
        super().__init__(content, tenant_uuid)


class ParkingLotEditedEvent(TenantEvent):
    service = 'confd'
    name = 'parking_lot_edited'
    routing_key_fmt = 'config.parkinglots.edited'

    def __init__(self, parking_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(parking_id)}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/parking_lot_extension/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/parking_lot_extension/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class ParkingLotExtensionAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'parking_lot_extension_associated'
    routing_key_fmt = 'config.parkinglots.extensions.updated'

    def __init__(
        self,
        parking_id: int,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'parking_lot_id': parking_id,
            'extension_id': extension_id,
        }
        super().__init__(content, tenant_uuid)


class ParkingLotExtensionDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'parking_lot_extension_dissociated'
    routing_key_fmt = 'config.parkinglots.extensions.deleted'

    def __init__(
        self,
        parking_id: int,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'parking_lot_id': parking_id,
            'extension_id': extension_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/phone_number/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/phone_number/event.py
from __future__ import annotations

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import PhoneNumberDict


class PhoneNumberCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'phone_number_created'
    routing_key_fmt = 'config.phone_number.created'

    def __init__(self, phone_number: PhoneNumberDict, tenant_uuid: UUIDStr):
        super().__init__(phone_number, tenant_uuid)


class PhoneNumberDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'phone_number_deleted'
    routing_key_fmt = 'config.phone_number.deleted'

    def __init__(self, phone_number: PhoneNumberDict, tenant_uuid: UUIDStr):
        super().__init__(phone_number, tenant_uuid)


class PhoneNumberEditedEvent(TenantEvent):
    service = 'confd'
    name = 'phone_number_edited'
    routing_key_fmt = 'config.phone_number.edited'

    def __init__(self, phone_number: PhoneNumberDict, tenant_uuid: UUIDStr):
        super().__init__(phone_number, tenant_uuid)


class PhoneNumberMainUpdatedEvent(TenantEvent):
    service = 'confd'
    name = 'phone_number_main_updated'
    routing_key_fmt = 'config.phone_number.main.updated'

    def __init__(
        self,
        current_main_uuid: str | None,
        new_main_uuid: str | None,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(
            {'current_main_uuid': current_main_uuid, 'new_main_uuid': new_main_uuid},
            tenant_uuid,
        )

----------------------------------------

File: accent_bus/resources/phone_number/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class PhoneNumberDict(TypedDict, total=False):
    uuid: UUIDStr
    tenant_uuid: UUIDStr
    number: str
    caller_id_name: str | None
    main: bool
    shareable: bool

----------------------------------------

File: accent_bus/resources/pjsip/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/pjsip/event.py

from ..common.event import ServiceEvent
from .types import PJSIPTransportDict


class PJSIPGlobalUpdatedEvent(ServiceEvent):
    service = 'confd'
    name = 'pjsip_global_updated'
    routing_key_fmt = 'config.pjsip_global.updated'

    def __init__(self) -> None:
        super().__init__()


class PJSIPSystemUpdatedEvent(ServiceEvent):
    service = 'confd'
    name = 'pjsip_system_updated'
    routing_key_fmt = 'config.pjsip_system.updated'

    def __init__(self) -> None:
        super().__init__()


class SIPTransportCreatedEvent(ServiceEvent):
    service = 'confd'
    name = 'sip_transport_created'
    routing_key_fmt = 'config.sip.transports.created'

    def __init__(self, transport: PJSIPTransportDict):
        super().__init__(transport)


class SIPTransportDeletedEvent(ServiceEvent):
    service = 'confd'
    name = 'sip_transport_deleted'
    routing_key_fmt = 'config.sip.transports.deleted'

    def __init__(self, transport: PJSIPTransportDict):
        super().__init__(transport)


class SIPTransportEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'sip_transport_edited'
    routing_key_fmt = 'config.sip.transports.edited'

    def __init__(self, transport: PJSIPTransportDict):
        super().__init__(transport)

----------------------------------------

File: accent_bus/resources/pjsip/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class PJSIPTransportDict(TypedDict, total=False):
    uuid: UUIDStr
    name: str
    options: list[str]

----------------------------------------

File: accent_bus/resources/plugins/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/plugins/events.py

from __future__ import annotations

from ..common.event import ServiceEvent
from ..common.types import UUIDStr
from .types import PluginErrorDict


class PluginInstallProgressEvent(ServiceEvent):
    service = 'plugind'
    name = 'plugin_install_progress'
    routing_key_fmt = 'plugin.install.{uuid}.{status}'

    def __init__(
        self,
        plugin_uuid: UUIDStr,
        status: str,
        errors: PluginErrorDict | None = None,
    ):
        content = {'uuid': plugin_uuid, 'status': status}
        if errors:
            content.update(errors=errors)  # type: ignore[call-overload]
        super().__init__(content)


class PluginUninstallProgressEvent(ServiceEvent):
    service = 'plugind'
    name = 'plugin_uninstall_progress'
    routing_key_fmt = 'plugin.uninstall.{uuid}.{status}'

    def __init__(
        self,
        plugin_uuid: UUIDStr,
        status: str,
        errors: PluginErrorDict | None = None,
    ):
        content = {'uuid': plugin_uuid, 'status': status}
        if errors:
            content.update(errors=errors)  # type: ignore[call-overload]
        super().__init__(content)

----------------------------------------

File: accent_bus/resources/plugins/types.py

from __future__ import annotations

from typing import Literal, TypedDict


class PluginErrorDict(TypedDict, total=False):
    error_id: str
    message: str
    resource: Literal['plugins']
    details: dict

----------------------------------------

File: accent_bus/resources/provisioning_networking/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/provisioning_networking/event.py

from ..common.event import ServiceEvent


class ProvisioningNetworkingEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'provisioning_networking_edited'
    routing_key_fmt = 'config.provisioning.networking.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/push_notification/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/push_notification/types.py

from __future__ import annotations

from typing import TypedDict


class PushMobileDict(TypedDict, total=False):
    peer_caller_id_number: str
    peer_caller_id_name: str
    call_id: str
    video: bool
    ring_timeout: int
    sip_call_id: str
    mobile_wakeup_timestamp: str  # iso-formatted timestamp

----------------------------------------

File: accent_bus/resources/push_notification/events.py

from ..common.event import UserEvent
from ..common.types import UUIDStr
from .types import PushMobileDict


class CallPushNotificationEvent(UserEvent):
    service = 'calld'
    name = 'call_push_notification'
    routing_key_fmt = 'calls.call.push_notification'
    required_acl_fmt = 'events.calls.{user_uuid}'

    def __init__(
        self,
        push: PushMobileDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(push, tenant_uuid, user_uuid)


class CallCancelPushNotificationEvent(UserEvent):
    service = 'calld'
    name = 'call_cancel_push_notification'
    routing_key_fmt = 'calls.call.cancel_push_notification'
    required_acl_fmt = 'events.calls.{user_uuid}'

    def __init__(
        self,
        push: PushMobileDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        super().__init__(push, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/queue/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/queue/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class QueueCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'queue_created'
    routing_key_fmt = 'config.queues.created'

    def __init__(self, queue_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(queue_id)}
        super().__init__(content, tenant_uuid)


class QueueDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'queue_deleted'
    routing_key_fmt = 'config.queues.deleted'

    def __init__(self, queue_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(queue_id)}
        super().__init__(content, tenant_uuid)


class QueueEditedEvent(TenantEvent):
    service = 'confd'
    name = 'queue_edited'
    routing_key_fmt = 'config.queues.edited'

    def __init__(self, queue_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(queue_id)}
        super().__init__(content, tenant_uuid)


class QueueFallbackEditedEvent(TenantEvent):
    service = 'confd'
    name = 'queue_fallback_edited'
    routing_key_fmt = 'config.queues.fallbacks.edited'

    def __init__(self, queue_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(queue_id)}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/queue_extension/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/queue_extension/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class QueueExtensionAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'queue_extension_associated'
    routing_key_fmt = 'config.queues.extensions.updated'

    def __init__(
        self,
        queue_id: int,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'queue_id': queue_id,
            'extension_id': extension_id,
        }
        super().__init__(content, tenant_uuid)


class QueueExtensionDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'queue_extension_dissociated'
    routing_key_fmt = 'config.queues.extensions.deleted'

    def __init__(
        self,
        queue_id: int,
        extension_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'queue_id': queue_id,
            'extension_id': extension_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/queue_general/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/queue_general/event.py

from ..common.event import ServiceEvent


class QueueGeneralEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'queue_general_edited'
    routing_key_fmt = 'config.queue_general.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/queue_member/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/queue_member/event.py

from ..common.event import TenantEvent, UserEvent
from ..common.types import UUIDStr


class QueueMemberAgentAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'queue_member_agent_associated'
    routing_key_fmt = 'config.queues.agents.updated'

    def __init__(
        self,
        queue_id: int,
        agent_id: int,
        penalty: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'queue_id': queue_id,
            'agent_id': agent_id,
            'penalty': penalty,
        }
        super().__init__(content, tenant_uuid)


class QueueMemberAgentDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'queue_member_agent_dissociated'
    routing_key_fmt = 'config.queues.agents.deleted'

    def __init__(
        self,
        queue_id: int,
        agent_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'queue_id': queue_id,
            'agent_id': agent_id,
        }
        super().__init__(content, tenant_uuid)


class QueueMemberUserAssociatedEvent(UserEvent):
    service = 'confd'
    name = 'queue_member_user_associated'
    routing_key_fmt = 'config.queues.users.updated'

    def __init__(
        self,
        queue_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'queue_id': queue_id,
            'user_uuid': str(user_uuid),
        }
        super().__init__(content, tenant_uuid, user_uuid)


class QueueMemberUserDissociatedEvent(UserEvent):
    service = 'confd'
    name = 'queue_member_user_dissociated'
    routing_key_fmt = 'config.queues.users.deleted'

    def __init__(
        self,
        queue_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'queue_id': queue_id,
            'user_uuid': str(user_uuid),
        }
        super().__init__(content, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/queue_schedule/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/queue_schedule/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class QueueScheduleAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'queue_schedule_associated'
    routing_key_fmt = 'config.queues.schedules.updated'

    def __init__(
        self,
        queue_id: int,
        schedule_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'queue_id': queue_id,
            'schedule_id': schedule_id,
        }
        super().__init__(content, tenant_uuid)


class QueueScheduleDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'queue_schedule_dissociated'
    routing_key_fmt = 'config.queues.schedules.deleted'

    def __init__(
        self,
        queue_id: int,
        schedule_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'queue_id': queue_id,
            'schedule_id': schedule_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/register/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/register/event.py

from ..common.event import ServiceEvent


class RegisterSIPCreated(ServiceEvent):
    service = 'confd'
    name = 'register_sip_created'
    routing_key_fmt = 'config.register.sip.created'

    def __init__(self, register_id: int):
        content = {'id': int(register_id)}
        super().__init__(content)


class RegisterSIPDeleted(ServiceEvent):
    service = 'confd'
    name = 'register_sip_deleted'
    routing_key_fmt = 'config.register.sip.deleted'

    def __init__(self, register_id: int):
        content = {'id': int(register_id)}
        super().__init__(content)


class RegisterSIPEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'register_sip_edited'
    routing_key_fmt = 'config.register.sip.edited'

    def __init__(self, register_id: int):
        content = {'id': int(register_id)}
        super().__init__(content)


class RegisterIAXCreatedEvent(ServiceEvent):
    service = 'confd'
    name = 'register_iax_created'
    routing_key_fmt = 'config.register.iax.created'

    def __init__(self, register_id: int):
        content = {'id': int(register_id)}
        super().__init__(content)


class RegisterIAXDeletedEvent(ServiceEvent):
    service = 'confd'
    name = 'register_iax_deleted'
    routing_key_fmt = 'config.register.iax.deleted'

    def __init__(self, register_id: int):
        content = {'id': int(register_id)}
        super().__init__(content)


class RegisterIAXEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'register_iax_edited'
    routing_key_fmt = 'config.register.iax.edited'

    def __init__(self, register_id: int):
        content = {'id': int(register_id)}
        super().__init__(content)

----------------------------------------

File: accent_bus/resources/registrar/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/registrar/event.py

from ..common.event import ServiceEvent
from .types import RegistrarDict


class RegistrarCreatedEvent(ServiceEvent):
    service = 'confd'
    name = 'registrar_created'
    routing_key_fmt = 'config.registrar.created'

    def __init__(self, registrar: RegistrarDict):
        super().__init__(registrar)


class RegistrarDeletedEvent(ServiceEvent):
    service = 'confd'
    name = 'registrar_deleted'
    routing_key_fmt = 'config.registrar.deleted'

    def __init__(self, registrar: RegistrarDict):
        super().__init__(registrar)


class RegistrarEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'registrar_edited'
    routing_key_fmt = 'config.registrar.edited'

    def __init__(self, registrar: RegistrarDict):
        super().__init__(registrar)

----------------------------------------

File: accent_bus/resources/registrar/types.py

from __future__ import annotations

from typing import TypedDict


class RegistrarDict(TypedDict, total=False):
    id: str
    deletable: bool
    name: str
    main_host: str
    main_port: int
    backup_host: str
    backup_port: int
    proxy_main_host: str
    proxy_main_port: int
    proxy_backup_host: str
    proxy_backup_port: int
    outbound_proxy_host: str
    outbound_proxy_port: int

----------------------------------------

File: accent_bus/resources/rtp/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/rtp/event.py

from ..common.event import ServiceEvent


class RTPGeneralEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'rtp_general_edited'
    routing_key_fmt = 'config.rtp_general.edited'

    def __init__(self) -> None:
        super().__init__()


class RTPIceHostCandidatesEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'rtp_ice_host_candidates_edited'
    routing_key_fmt = 'config.rtp_ice_host_candidates.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/sccp_general/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/sccp_general/event.py

from ..common.event import ServiceEvent


class SCCPGeneralEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'sccp_general_edited'
    routing_key_fmt = 'config.sccp_general.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/schedule/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/schedule/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class ScheduleCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'schedule_created'
    routing_key_fmt = 'config.schedules.created'

    def __init__(self, schedule_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(schedule_id)}
        super().__init__(content, tenant_uuid)


class ScheduleDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'schedule_deleted'
    routing_key_fmt = 'config.schedules.deleted'

    def __init__(self, schedule_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(schedule_id)}
        super().__init__(content, tenant_uuid)


class ScheduleEditedEvent(TenantEvent):
    service = 'confd'
    name = 'schedule_edited'
    routing_key_fmt = 'config.schedules.edited'

    def __init__(self, schedule_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(schedule_id)}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/services/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/services/event.py

from ..common.event import ServiceEvent


class ServiceRegisteredEvent(ServiceEvent):
    name = 'service_registered'
    routing_key_fmt = 'service.registered.{service_name}'

    def __init__(
        self,
        service_name: str,
        service_id: str,
        advertise_address: str,
        advertise_port: int,
        tags: list[str],
    ):
        content = {
            'service_name': service_name,
            'service_id': service_id,
            'address': advertise_address,
            'port': advertise_port,
            'tags': tags,
        }
        super().__init__(content)


class ServiceDeregisteredEvent(ServiceEvent):
    name = 'service_deregistered'
    routing_key_fmt = 'service.registered.{service_name}'

    def __init__(self, service_name: str, service_id: str, tags: list[str]):
        content = {
            'service_name': service_name,
            'service_id': service_id,
            'tags': tags,
        }
        super().__init__(content)

----------------------------------------

File: accent_bus/resources/sip_general/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/sip_general/event.py

from ..common.event import ServiceEvent


class SIPGeneralEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'sip_general_edited'
    routing_key_fmt = 'config.sip_general.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/skill/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/skill/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class SkillCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'skill_created'
    routing_key_fmt = 'config.agents.skills.created'

    def __init__(self, skill_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(skill_id)}
        super().__init__(content, tenant_uuid)


class SkillDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'skill_deleted'
    routing_key_fmt = 'config.agents.skills.deleted'

    def __init__(self, skill_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(skill_id)}
        super().__init__(content, tenant_uuid)


class SkillEditedEvent(TenantEvent):
    service = 'confd'
    name = 'skill_edited'
    routing_key_fmt = 'config.agents.skills.edited'

    def __init__(self, skill_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(skill_id)}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/skill_rule/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/skill_rule/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class SkillRuleCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'skill_rule_created'
    routing_key_fmt = 'config.queues.skillrules.created'

    def __init__(self, skill_rule_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(skill_rule_id)}
        super().__init__(content, tenant_uuid)


class SkillRuleDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'skill_rule_deleted'
    routing_key_fmt = 'config.queues.skillrules.deleted'

    def __init__(self, skill_rule_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(skill_rule_id)}
        super().__init__(content, tenant_uuid)


class SkillRuleEditedEvent(TenantEvent):
    service = 'confd'
    name = 'skill_rule_edited'
    routing_key_fmt = 'config.queues.skillrules.edited'

    def __init__(self, skill_rule_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(skill_rule_id)}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/sound/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/sound/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class SoundCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'sound_created'
    routing_key_fmt = 'config.sounds.created'

    def __init__(self, sound_name: str, tenant_uuid: UUIDStr):
        content = {'name': sound_name}
        super().__init__(content, tenant_uuid)


class SoundDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'sound_deleted'
    routing_key_fmt = 'config.sounds.deleted'

    def __init__(self, sound_name: str, tenant_uuid: UUIDStr):
        content = {'name': sound_name}
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/switchboard/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/switchboard/event.py

from __future__ import annotations

from collections.abc import Mapping
from typing import Any

from ..common.event import MultiUserEvent, TenantEvent
from ..common.types import UUIDStr
from .types import (
    HeldCallDict,
    QueuedCallDict,
    SwitchboardDict,
    SwitchboardFallbackDict,
)


class _SwitchboardMixin:
    def __init__(
        self,
        content: Mapping,
        switchboard_uuid: UUIDStr,
        *args: Any,
    ):
        super().__init__(content, *args)  # type: ignore[call-arg]
        if switchboard_uuid is None:
            raise ValueError('switchboard_uuid must have a value')
        self.switchboard_uuid = str(switchboard_uuid)


class SwitchboardCreatedEvent(_SwitchboardMixin, TenantEvent):
    service = 'confd'
    name = 'switchboard_created'
    routing_key_fmt = 'config.switchboards.{switchboard_uuid}.created'
    required_acl_fmt = 'switchboards.{switchboard_uuid}.created'

    def __init__(
        self,
        switchboard: SwitchboardDict,
        switchboard_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(switchboard, switchboard_uuid, tenant_uuid)


class SwitchboardDeletedEvent(_SwitchboardMixin, TenantEvent):
    service = 'confd'
    name = 'switchboard_deleted'
    routing_key_fmt = 'config.switchboards.{switchboard_uuid}.deleted'
    required_acl_fmt = 'switchboards.{switchboard_uuid}.deleted'

    def __init__(
        self,
        switchboard: SwitchboardDict,
        switchboard_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(switchboard, switchboard_uuid, tenant_uuid)


class SwitchboardEditedEvent(_SwitchboardMixin, TenantEvent):
    service = 'confd'
    name = 'switchboard_edited'
    routing_key_fmt = 'config.switchboards.{switchboard_uuid}.edited'
    required_acl_fmt = 'switchboards.{switchboard_uuid}.edited'

    def __init__(
        self,
        switchboard: SwitchboardDict,
        switchboard_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(switchboard, switchboard_uuid, tenant_uuid)


class SwitchboardFallbackEditedEvent(_SwitchboardMixin, TenantEvent):
    service = 'confd'
    name = 'switchboard_fallback_edited'
    routing_key_fmt = 'config.switchboards.fallbacks.edited'
    required_acl_fmt = 'switchboards.fallbacks.edited'

    def __init__(
        self,
        fallback: SwitchboardFallbackDict,
        switchboard_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        super().__init__(fallback, switchboard_uuid, tenant_uuid)


class SwitchboardMemberUserAssociatedEvent(_SwitchboardMixin, MultiUserEvent):
    service = 'confd'
    name = 'switchboard_member_user_associated'
    routing_key_fmt = 'config.switchboards.{switchboard_uuid}.members.users.updated'
    required_acl_fmt = 'switchboards.{switchboard_uuid}.members.users.updated'

    def __init__(
        self,
        switchboard_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
        user_uuids: list[str],
    ):
        content = {
            'switchboard_uuid': str(switchboard_uuid),
            'users': [{'uuid': str(uuid)} for uuid in user_uuids],
        }
        super().__init__(content, switchboard_uuid, tenant_uuid, user_uuids)


class SwitchboardQueuedCallsUpdatedEvent(_SwitchboardMixin, TenantEvent):
    service = 'calld'
    name = 'switchboard_queued_calls_updated'
    routing_key_fmt = 'switchboards.{switchboard_uuid}.calls.queued.updated'
    required_acl_fmt = 'events.switchboards.{switchboard_uuid}.calls.queued.updated'

    def __init__(
        self,
        items: list[QueuedCallDict],
        switchboard_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'switchboard_uuid': str(switchboard_uuid),
            'items': items,
        }
        super().__init__(content, switchboard_uuid, tenant_uuid)


class SwitchboardQueuedCallAnsweredEvent(_SwitchboardMixin, TenantEvent):
    service = 'calld'
    name = 'switchboard_queued_call_answered'
    routing_key_fmt = (
        'switchboards.{switchboard_uuid}.calls.queued.{queued_call_id}.answer.updated'
    )
    required_acl_fmt = 'events.switchboards.{switchboard_uuid}.calls.queued.{queued_call_id}.answer.updated'

    def __init__(
        self,
        operator_call_id: str,
        queued_call_id: str,
        switchboard_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'switchboard_uuid': str(switchboard_uuid),
            'operator_call_id': operator_call_id,
            'queued_call_id': queued_call_id,
        }
        super().__init__(content, switchboard_uuid, tenant_uuid)


class SwitchboardHeldCallsUpdatedEvent(_SwitchboardMixin, TenantEvent):
    service = 'calld'
    name = 'switchboard_held_calls_updated'
    routing_key_fmt = 'switchboards.{switchboard_uuid}.calls.held.updated'
    required_acl_fmt = 'events.switchboards.{switchboard_uuid}.calls.held.updated'

    def __init__(
        self,
        items: list[HeldCallDict],
        switchboard_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'switchboard_uuid': str(switchboard_uuid),
            'items': items,
        }
        super().__init__(content, switchboard_uuid, tenant_uuid)


class SwitchboardHeldCallAnsweredEvent(_SwitchboardMixin, TenantEvent):
    service = 'calld'
    name = 'switchboard_held_call_answered'
    routing_key_fmt = (
        'switchboards.{switchboard_uuid}.calls.held.{held_call_id}.answer.updated'
    )
    required_acl_fmt = 'events.switchboards.{switchboard_uuid}.calls.held.{held_call_id}.answer.updated'

    def __init__(
        self,
        operator_call_id: str,
        held_call_id: str,
        switchboard_uuid: UUIDStr,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'switchboard_uuid': str(switchboard_uuid),
            'operator_call_id': operator_call_id,
            'held_call_id': held_call_id,
        }
        super().__init__(content, switchboard_uuid, tenant_uuid)

----------------------------------------

File: accent_bus/resources/switchboard/types.py

from __future__ import annotations

from typing import Any, TypedDict

from ..common.types import UUIDStr


class ExtensionDict(TypedDict, total=False):
    id: int
    exten: str
    context: str


class IncallDict(TypedDict, total=False):
    id: int
    extensions: list[ExtensionDict]


class HeldCallDict(TypedDict, total=False):
    id: str
    caller_id_name: str
    caller_id_number: str


class QueuedCallDict(TypedDict, total=False):
    id: str
    caller_id_name: str
    caller_id_number: str


class SwitchboardDict(TypedDict, total=False):
    uuid: UUIDStr
    tenant_uuid: UUIDStr
    name: str
    timeout: int
    queue_music_on_hold: str
    waiting_room_music_on_hold: str
    extensions: ExtensionDict
    incalls: list[IncallDict]
    user_members: list[UserDict]
    fallbacks: list[SwitchboardFallbackDict]


class SwitchboardFallbackDict(TypedDict, total=False):
    noanswer_destination: Any


class UserDict(TypedDict, total=False):
    uuid: UUIDStr
    firstname: str
    lastname: str

----------------------------------------

File: accent_bus/resources/sysconfd/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/sysconfd/event.py

from __future__ import annotations

from ..common.event import ServiceEvent
from ..common.types import UUIDStr


class RequestHandlersProgressEvent(ServiceEvent):
    service = 'sysconfd'
    name = 'request_handlers_progress'
    routing_key_fmt = 'sysconfd.request_handlers.{uuid}.{status}'

    def __init__(
        self,
        request_uuid: UUIDStr,
        request_context: dict | None,
        status: str,
    ):
        content = {
            'uuid': str(request_uuid),
            'status': status,
            'context': request_context,
        }
        super().__init__(content)


class AsteriskReloadProgressEvent(ServiceEvent):
    service = 'sysconfd'
    name = 'asterisk_reload_progress'
    routing_key_fmt = 'sysconfd.asterisk.reload.{uuid}.{status}'

    def __init__(
        self,
        uuid: UUIDStr,
        status: str,
        command: str,
        request_uuids: list[UUIDStr],
    ):
        content = {
            'uuid': str(uuid),
            'status': status,
            'command': command,
            'request_uuids': request_uuids,
        }
        super().__init__(content)

----------------------------------------

File: accent_bus/resources/trunk/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/trunk/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class TrunkCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'trunk_created'
    routing_key_fmt = 'config.trunk.created'

    def __init__(self, trunk_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(trunk_id)}
        super().__init__(content, tenant_uuid)


class TrunkDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'trunk_deleted'
    routing_key_fmt = 'config.trunk.deleted'

    def __init__(self, trunk_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(trunk_id)}
        super().__init__(content, tenant_uuid)


class TrunkEditedEvent(TenantEvent):
    service = 'confd'
    name = 'trunk_edited'
    routing_key_fmt = 'config.trunk.edited'

    def __init__(self, trunk_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(trunk_id)}
        super().__init__(content, tenant_uuid)


class TrunkStatusUpdatedEvent(TenantEvent):
    service = 'calld'
    name = 'trunk_status_updated'
    routing_key_fmt = 'trunks.{id}.status.updated'

    def __init__(
        self,
        trunk_id: int,
        technology: str,
        endpoint_name: str,
        endpoint_registered: bool,
        endpoint_current_call_count: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'id': trunk_id,
            'technology': technology,
            'name': endpoint_name,
            'registered': endpoint_registered,
            'current_call_count': endpoint_current_call_count,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/trunk_endpoint/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/trunk_endpoint/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import EndpointCustomDict, EndpointIAXDict, EndpointSIPDict, TrunkDict


class TrunkEndpointSIPAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'trunk_endpoint_sip_associated'
    routing_key_fmt = (
        'config.trunks.{trunk[id]}.endpoints.sip.{endpoint_sip[uuid]}.updated'
    )

    def __init__(
        self,
        trunk: TrunkDict,
        sip: EndpointSIPDict,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'trunk': trunk,
            'endpoint_sip': sip,
        }
        super().__init__(content, tenant_uuid)


class TrunkEndpointSIPDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'trunk_endpoint_sip_dissociated'
    routing_key_fmt = (
        'config.trunks.{trunk[id]}.endpoints.sip.{endpoint_sip[uuid]}.deleted'
    )

    def __init__(
        self,
        trunk: TrunkDict,
        sip: EndpointSIPDict,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'trunk': trunk,
            'endpoint_sip': sip,
        }
        super().__init__(content, tenant_uuid)


class TrunkEndpointIAXAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'trunk_endpoint_iax_associated'
    routing_key_fmt = (
        'config.trunks.{trunk[id]}.endpoints.iax.{endpoint_iax[id]}.updated'
    )

    def __init__(
        self,
        trunk: TrunkDict,
        iax: EndpointIAXDict,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'trunk': trunk,
            'endpoint_iax': iax,
        }
        super().__init__(content, tenant_uuid)


class TrunkEndpointIAXDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'trunk_endpoint_iax_dissociated'
    routing_key_fmt = (
        'config.trunks.{trunk[id]}.endpoints.iax.{endpoint_iax[id]}.deleted'
    )

    def __init__(
        self,
        trunk: TrunkDict,
        iax: EndpointIAXDict,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'trunk': trunk,
            'endpoint_iax': iax,
        }
        super().__init__(content, tenant_uuid)


class TrunkEndpointCustomAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'trunk_endpoint_custom_associated'
    routing_key_fmt = (
        'config.trunks.{trunk[id]}.endpoints.custom.{endpoint_custom[id]}.updated'
    )

    def __init__(
        self,
        trunk: TrunkDict,
        custom: EndpointCustomDict,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'trunk': trunk,
            'endpoint_custom': custom,
        }
        super().__init__(content, tenant_uuid)


class TrunkEndpointCustomDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'trunk_endpoint_custom_dissociated'
    routing_key_fmt = (
        'config.trunks.{trunk[id]}.endpoints.custom.{endpoint_custom[id]}.deleted'
    )

    def __init__(
        self,
        trunk: TrunkDict,
        custom: EndpointCustomDict,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'trunk': trunk,
            'endpoint_custom': custom,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/trunk_endpoint/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class EndpointSIPDict(TypedDict, total=False):
    uuid: UUIDStr
    tenant_uuid: UUIDStr
    name: str
    auth_section_options: EndpointSIPAuthSectionOptionsDict
    registration_section_options: EndpointSIPRegistrationSectionOptionsDict


class EndpointSIPAuthSectionOptionsDict(TypedDict, total=False):
    username: str


class EndpointSIPRegistrationSectionOptionsDict(TypedDict, total=False):
    client_uri: str


class EndpointIAXDict(TypedDict, total=False):
    id: int
    tenant_uuid: UUIDStr
    name: str


class EndpointCustomDict(TypedDict, total=False):
    id: int
    tenant_uuid: UUIDStr
    interface: str


class TrunkDict(TypedDict, total=False):
    id: int
    tenant_uuid: UUIDStr

----------------------------------------

File: accent_bus/resources/trunk_register/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/trunk_register/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr


class TrunkRegisterIAXAssociatedEvent(TenantEvent):
    service = 'confd'
    name = 'trunk_register_iax_associated'
    routing_key_fmt = 'config.trunks.registers.iax.updated'

    def __init__(
        self,
        trunk_id: int,
        register_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {'trunk_id': trunk_id, 'register_id': register_id}
        super().__init__(content, tenant_uuid)


class TrunkRegisterIAXDissociatedEvent(TenantEvent):
    service = 'confd'
    name = 'trunk_register_iax_dissociated'
    routing_key_fmt = 'config.trunks.registers.iax.deleted'

    def __init__(
        self,
        trunk_id: int,
        register_id: int,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'trunk_id': trunk_id,
            'register_id': register_id,
        }
        super().__init__(content, tenant_uuid)

----------------------------------------

File: accent_bus/resources/user/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/user/event.py

from __future__ import annotations

from ..common.event import TenantEvent, UserEvent
from ..common.types import UUIDStr


class _BaseUserEvent(TenantEvent):
    def __init__(
        self,
        user_id: int,
        user_uuid: UUIDStr,
        subscription_type: str,
        created_at: str | None,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'id': int(user_id),
            'uuid': str(user_uuid),
            'subscription_type': subscription_type,
            'created_at': str(created_at) if created_at is not None else None,
            'tenant_uuid': str(tenant_uuid),
        }
        super().__init__(content, tenant_uuid)


class UserCreatedEvent(_BaseUserEvent):
    service = 'confd'
    name = 'user_created'
    routing_key_fmt = 'config.user.created'


class UserDeletedEvent(_BaseUserEvent):
    service = 'confd'
    name = 'user_deleted'
    routing_key_fmt = 'config.user.deleted'


class UserEditedEvent(_BaseUserEvent):
    service = 'confd'
    name = 'user_edited'
    routing_key_fmt = 'config.user.edited'


class UserFallbackEditedEvent(UserEvent):
    service = 'confd'
    name = 'user_fallback_edited'
    routing_key_fmt = 'config.users.fallbacks.edited'

    def __init__(
        self,
        user_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'id': int(user_id),
            'uuid': str(user_uuid),
            'subscription_type': None,
            'created_at': None,
            'tenant_uuid': str(tenant_uuid),
        }
        super().__init__(content, tenant_uuid, user_uuid)


class UserServiceEditedEvent(UserEvent):
    service = 'confd'
    name = 'users_services_{service_name}_updated'
    routing_key_fmt = 'config.users.{user_uuid}.services.{service_name}.updated'

    def __init__(
        self,
        user_id: int,
        service_name: str,
        service_enabled: bool,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        self.name = type(self).name.format(service_name=service_name)
        content = {
            'user_id': int(user_id),
            'user_uuid': str(user_uuid),
            'tenant_uuid': str(tenant_uuid),
            'enabled': service_enabled,
        }
        super().__init__(content, tenant_uuid, user_uuid)
        self.service_name = service_name


class UserForwardEditedEvent(UserEvent):
    service = 'confd'
    name = 'users_forwards_{forward_name}_updated'
    routing_key_fmt = 'config.users.{user_uuid}.forwards.{forward_name}.updated'

    def __init__(
        self,
        user_id: int,
        forward_name: str,
        forward_enabled: bool,
        forward_dest: str,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        self.name = type(self).name.format(forward_name=forward_name)
        content = {
            'user_id': int(user_id),
            'user_uuid': str(user_uuid),
            'tenant_uuid': str(tenant_uuid),
            'enabled': forward_enabled,
            'destination': forward_dest,
        }
        super().__init__(content, tenant_uuid, user_uuid)
        self.forward_name = forward_name

----------------------------------------

File: accent_bus/resources/user_agent/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/user_agent/event.py

from ..common.event import UserEvent
from ..common.types import UUIDStr


class UserAgentAssociatedEvent(UserEvent):
    service = 'confd'
    name = 'user_agent_associated'
    routing_key_fmt = 'config.users.{user_uuid}.agents.updated'

    def __init__(
        self,
        agent_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': str(user_uuid),
            'agent_id': agent_id,
        }
        super().__init__(content, tenant_uuid, user_uuid)


class UserAgentDissociatedEvent(UserEvent):
    service = 'confd'
    name = 'user_agent_dissociated'
    routing_key_fmt = 'config.users.{user_uuid}.agents.deleted'

    def __init__(
        self,
        agent_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': str(user_uuid),
            'agent_id': agent_id,
        }
        super().__init__(content, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/user_call_permission/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/user_call_permission/event.py

from ..common.event import UserEvent
from ..common.types import UUIDStr


class UserCallPermissionAssociatedEvent(UserEvent):
    service = 'confd'
    name = 'user_call_permission_associated'
    routing_key_fmt = 'config.users.{user_uuid}.callpermissions.updated'

    def __init__(
        self,
        call_permission_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': str(user_uuid),
            'call_permission_id': call_permission_id,
        }
        super().__init__(content, tenant_uuid, user_uuid)


class UserCallPermissionDissociatedEvent(UserEvent):
    service = 'confd'
    name = 'user_call_permission_dissociated'
    routing_key_fmt = 'config.users.{user_uuid}.callpermissions.deleted'

    def __init__(
        self,
        call_permission_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': str(user_uuid),
            'call_permission_id': call_permission_id,
        }
        super().__init__(content, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/user_external_app/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/user_external_app/event.py

from ..common.event import TenantEvent
from ..common.types import UUIDStr
from .types import ExternalAppDict


class UserExternalAppCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'user_external_app_created'
    routing_key_fmt = 'config.user_external_apps.created'

    def __init__(self, app: ExternalAppDict, tenant_uuid: UUIDStr):
        super().__init__(app, tenant_uuid)


class UserExternalAppDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'user_external_app_deleted'
    routing_key_fmt = 'config.user_external_apps.deleted'

    def __init__(self, app: ExternalAppDict, tenant_uuid: UUIDStr):
        super().__init__(app, tenant_uuid)


class UserExternalAppEditedEvent(TenantEvent):
    service = 'confd'
    name = 'user_external_app_edited'
    routing_key_fmt = 'config.user_external_apps.edited'

    def __init__(self, app: ExternalAppDict, tenant_uuid: UUIDStr):
        super().__init__(app, tenant_uuid)

----------------------------------------

File: accent_bus/resources/user_external_app/types.py

from __future__ import annotations

from typing import TypedDict


class ExternalAppDict(TypedDict, total=False):
    name: str

----------------------------------------

File: accent_bus/resources/user_group/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/user_group/event.py

from ..common.event import UserEvent
from ..common.types import UUIDStr


class UserGroupsAssociatedEvent(UserEvent):
    service = 'confd'
    name = 'user_groups_associated'
    routing_key_fmt = 'config.users.groups.updated'

    def __init__(
        self,
        group_ids: list[int],
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': str(user_uuid),
            'group_ids': group_ids,
        }
        super().__init__(content, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/user_line/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/user_line/event.py

from ..common.event import UserEvent
from ..common.types import UUIDStr
from .types import LineDict, UserDict


class UserLineAssociatedEvent(UserEvent):
    service = 'confd'
    name = 'user_line_associated'
    routing_key_fmt = 'config.users.{user_uuid}.lines.{line[id]}.updated'

    def __init__(
        self,
        user: UserDict,
        line: LineDict,
        main_user: bool,
        main_line: bool,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'line': line,
            'main_line': main_line,
            'main_user': main_user,
            'user': user,
        }
        super().__init__(content, tenant_uuid, user['uuid'])


class UserLineDissociatedEvent(UserEvent):
    service = 'confd'
    name = 'user_line_dissociated'
    routing_key_fmt = 'config.users.{user_uuid}.lines.{line[id]}.deleted'

    def __init__(
        self,
        user: UserDict,
        line: LineDict,
        main_user: bool,
        main_line: bool,
        tenant_uuid: UUIDStr,
    ):
        content = {
            'line': line,
            'main_line': main_line,
            'main_user': main_user,
            'user': user,
        }
        super().__init__(content, tenant_uuid, user['uuid'])

----------------------------------------

File: accent_bus/resources/user_line/types.py

from __future__ import annotations

from typing import TypedDict

from ..common.types import UUIDStr


class EndpointCustomDict(TypedDict, total=False):
    id: int


class EndpointSCCPDict(TypedDict, total=False):
    id: int


class EndpointSIPDict(TypedDict, total=False):
    uuid: UUIDStr


class LineDict(TypedDict, total=False):
    id: int
    name: str
    endpoint_sip: EndpointSIPDict
    endpoint_sccp: EndpointSCCPDict
    endpoint_custom: EndpointCustomDict


class UserDict(TypedDict, total=False):
    id: int
    uuid: UUIDStr
    tenant_uuid: UUIDStr

----------------------------------------

File: accent_bus/resources/user_line_extension/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/user_line_extension/event.py

from ..common.event import UserEvent
from ..common.types import UUIDStr


class _BaseUserLineExtensionEvent(UserEvent):
    def __init__(
        self,
        user_line_extension_id: int,
        user_id: int,
        line_id: int,
        extension_id: int,
        main_user: bool,
        main_line: bool,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'id': int(user_line_extension_id),
            'user_id': int(user_id),
            'line_id': int(line_id),
            'extension_id': int(extension_id),
            'main_user': bool(main_user),
            'main_line': bool(main_line),
        }
        super().__init__(content, tenant_uuid, user_uuid)


class UserLineExtensionCreatedEvent(_BaseUserLineExtensionEvent):
    service = 'confd'
    name = 'user_line_extension_created'
    routing_key_fmt = 'config.users.lines.extensions.created'


class UserLineExtensionDeletedEvent(_BaseUserLineExtensionEvent):
    service = 'confd'
    name = 'user_line_extension_deleted'
    routing_key_fmt = 'config.users.lines.extensions.deleted'


class UserLineExtensionEditedEvent(_BaseUserLineExtensionEvent):
    service = 'confd'
    name = 'user_line_extension_edited'
    routing_key_fmt = 'config.users.lines.extensions.edited'

----------------------------------------

File: accent_bus/resources/user_schedule/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/user_schedule/event.py

from ..common.event import UserEvent
from ..common.types import UUIDStr


class UserScheduleAssociatedEvent(UserEvent):
    service = 'confd'
    name = 'user_schedule_associated'
    routing_key_fmt = 'config.users.schedules.updated'

    def __init__(
        self,
        schedule_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': str(user_uuid),
            'schedule_id': schedule_id,
        }
        super().__init__(content, tenant_uuid, user_uuid)


class UserScheduleDissociatedEvent(UserEvent):
    service = 'confd'
    name = 'user_schedule_dissociated'
    routing_key_fmt = 'config.users.schedules.deleted'

    def __init__(
        self,
        schedule_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': str(user_uuid),
            'schedule_id': schedule_id,
        }
        super().__init__(content, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/user_voicemail/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/user_voicemail/event.py

from ..common.event import UserEvent
from ..common.types import UUIDStr


class UserVoicemailAssociatedEvent(UserEvent):
    service = 'confd'
    name = 'user_voicemail_associated'
    routing_key_fmt = 'config.users.{user_uuid}.voicemails.updated'

    def __init__(
        self,
        voicemail_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': str(user_uuid),
            'voicemail_id': int(voicemail_id),
        }
        super().__init__(content, tenant_uuid, user_uuid)


class UserVoicemailDissociatedEvent(UserEvent):
    service = 'confd'
    name = 'user_voicemail_dissociated'
    routing_key_fmt = 'config.users.{user_uuid}.voicemails.deleted'

    def __init__(
        self,
        voicemail_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': user_uuid,
            'voicemail_id': int(voicemail_id),
        }
        super().__init__(content, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/voicemail/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/voicemail/event.py

from ..common.event import TenantEvent, UserEvent
from ..common.types import UUIDStr
from .types import VoicemailMessageDict


class VoicemailCreatedEvent(TenantEvent):
    service = 'confd'
    name = 'voicemail_created'
    routing_key_fmt = 'config.voicemail.created'

    def __init__(self, voicemail_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(voicemail_id)}
        super().__init__(content, tenant_uuid)


class VoicemailDeletedEvent(TenantEvent):
    service = 'confd'
    name = 'voicemail_deleted'
    routing_key_fmt = 'config.voicemail.deleted'

    def __init__(self, voicemail_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(voicemail_id)}
        super().__init__(content, tenant_uuid)


class VoicemailEditedEvent(TenantEvent):
    service = 'confd'
    name = 'voicemail_edited'
    routing_key_fmt = 'config.voicemail.edited'

    def __init__(self, voicemail_id: int, tenant_uuid: UUIDStr):
        content = {'id': int(voicemail_id)}
        super().__init__(content, tenant_uuid)


class UserVoicemailEditedEvent(UserEvent):
    service = 'confd'
    name = 'user_voicemail_edited'
    routing_key_fmt = 'config.users.{user_uuid}.voicemails.edited'

    def __init__(
        self,
        voicemail_id: int,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': str(user_uuid),
            'voicemail_id': voicemail_id,
        }
        super().__init__(content, tenant_uuid, user_uuid)


class UserVoicemailMessageCreatedEvent(UserEvent):
    service = 'calld'
    name = 'user_voicemail_message_created'
    routing_key_fmt = 'voicemails.messages.created'
    required_acl_fmt = 'events.users.{user_uuid}.voicemails'

    def __init__(
        self,
        message_id: str,
        voicemail_id: int,
        message: VoicemailMessageDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': str(user_uuid),
            'voicemail_id': voicemail_id,
            'message_id': message_id,
            'message': message,
        }
        super().__init__(content, tenant_uuid, user_uuid)


class UserVoicemailMessageUpdatedEvent(UserEvent):
    service = 'calld'
    name = 'user_voicemail_message_updated'
    routing_key_fmt = 'voicemails.messages.updated'
    required_acl_fmt = 'events.users.{user_uuid}.voicemails'

    def __init__(
        self,
        message_id: str,
        voicemail_id: int,
        message: VoicemailMessageDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': str(user_uuid),
            'voicemail_id': voicemail_id,
            'message_id': message_id,
            'message': message,
        }
        super().__init__(content, tenant_uuid, user_uuid)


class UserVoicemailMessageDeletedEvent(UserEvent):
    service = 'calld'
    name = 'user_voicemail_message_deleted'
    routing_key_fmt = 'voicemails.messages.deleted'
    required_acl_fmt = 'events.users.{user_uuid}.voicemails'

    def __init__(
        self,
        message_id: str,
        voicemail_id: int,
        message: VoicemailMessageDict,
        tenant_uuid: UUIDStr,
        user_uuid: UUIDStr,
    ):
        content = {
            'user_uuid': str(user_uuid),
            'voicemail_id': voicemail_id,
            'message_id': message_id,
            'message': message,
        }
        super().__init__(content, tenant_uuid, user_uuid)

----------------------------------------

File: accent_bus/resources/voicemail/types.py

from __future__ import annotations

from typing import TypedDict


class VoicemailFolderDict(TypedDict, total=False):
    id: int
    name: str
    type: str


class VoicemailMessageDict(TypedDict, total=False):
    id: str
    caller_id_name: str
    caller_id_num: str
    duration: int
    tiemstamp: int
    folder: VoicemailFolderDict

----------------------------------------

File: accent_bus/resources/voicemail_general/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/voicemail_general/event.py

from ..common.event import ServiceEvent


class VoicemailGeneralEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'voicemail_general_edited'
    routing_key_fmt = 'config.voicemail_general.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/voicemail_zonemessages/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/voicemail_zonemessages/event.py

from ..common.event import ServiceEvent


class VoicemailZoneMessagesEditedEvent(ServiceEvent):
    service = 'confd'
    name = 'voicemail_zonemessages_edited'
    routing_key_fmt = 'config.voicemail_zonemessages.edited'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: accent_bus/resources/wizard/__init__.py
Please review for update


----------------------------------------

File: accent_bus/resources/wizard/event.py

from ..common.event import ServiceEvent


class WizardCreatedEvent(ServiceEvent):
    service = 'confd'
    name = 'wizard_created'
    routing_key_fmt = 'config.wizard.created'

    def __init__(self) -> None:
        super().__init__()

----------------------------------------

File: contribs/documentation.py

from __future__ import annotations

import argparse
import importlib
import inspect
import logging
import os
import re
import sys
from collections import defaultdict
from collections.abc import Callable
from concurrent.futures import ThreadPoolExecutor
from copy import deepcopy
from itertools import chain
from pathlib import Path
from time import time
from types import NoneType, UnionType
from typing import (
    Annotated,
    Any,
    Literal,
    TypeAlias,
    TypedDict,
    Union,
    Unpack,
    get_args,
    get_origin,
    get_type_hints,
    is_typeddict,
)

import yaml

PACKAGE_NAME = 'accent_bus'
logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
logger = logging.getLogger(__name__)


class AsyncAPIOptions(TypedDict, total=False):
    nullable: bool
    const: str
    enum: list


class AsyncAPITypes:
    @classmethod
    def _process_options(
        cls,
        content: dict,
        **options: Unpack[AsyncAPIOptions],
    ) -> dict:
        if 'nullable' in options:
            content['nullable'] = options.get('nullable', False)

        if 'const' in options:
            content['const'] = options['const']

        if 'enum' in options:
            content['enum'] = options['enum']

        return content

    @classmethod
    def array(cls, format: dict[str, str]) -> dict:
        return {'type': 'array', 'items': format}

    @classmethod
    def boolean(cls, *metadata: Any, **options: Unpack[AsyncAPIOptions]) -> dict:
        content = {'type': 'boolean'}
        return cls._process_options(content, **options)

    @classmethod
    def float_(cls, *metadata: Any, **options: Unpack[AsyncAPIOptions]) -> dict:
        content = {'type': 'number', 'format': 'float'}
        return cls._process_options(content, **options)

    @classmethod
    def integer(cls, *metadata: Any, **options: Unpack[AsyncAPIOptions]) -> dict:
        content = {'type': 'integer'}
        return cls._process_options(content, **options)

    @classmethod
    def object_(
        cls,
        content: dict | None = None,
        *metadata: Any,
        **options: Unpack[AsyncAPIOptions],
    ) -> dict:
        content = {'type': 'object', 'properties': content or {}}
        return cls._process_options(content, **options)

    @classmethod
    def string(cls, *metadata: Any, **options: Unpack[AsyncAPIOptions]) -> dict:
        content = {'type': 'string'}

        for obj in metadata:
            if hasattr(obj, 'format'):
                content['format'] = obj.format

        return cls._process_options(content, **options)


class Converter:
    _type_factories: dict[type | Any, Callable[..., dict]] = {
        Any: AsyncAPITypes.object_,
        bool: AsyncAPITypes.boolean,
        dict: AsyncAPITypes.object_,
        float: AsyncAPITypes.float_,
        int: AsyncAPITypes.integer,
        str: AsyncAPITypes.string,
    }

    @classmethod
    def _scan_hint(cls, hint: type) -> dict[str, Any]:
        def recurse(
            type_: type, *metadata: Any, **options: Unpack[AsyncAPIOptions]
        ) -> dict:
            # Check if has a subtype i.e: type[subtype, ...]
            if origin_type := get_origin(type_):
                subtype, *args = get_args(type_)

                if origin_type is Annotated:
                    return recurse(subtype, *args, **options)

                elif origin_type is Literal:
                    if len(args) > 0:
                        return recurse(type(subtype), enum=[subtype, *args])
                    return recurse(type(subtype), const=subtype)

                # i.e: Union[X, Y] or X | Y
                # Note: we currently do not support multiple type in the API,
                #       other types will be omitted from the spec
                elif origin_type in (UnionType, Union):
                    nullable = any([item is NoneType for item in args])
                    return recurse(subtype, nullable=nullable)

                elif origin_type in (list, set, tuple):
                    if len(args) > 0:
                        raise TypeError('arrays cannot have multiple types')
                    return AsyncAPITypes.array(recurse(subtype, **options))

                elif origin_type is dict:
                    return AsyncAPITypes.object_(**options)

            elif is_typeddict(type_):
                content = {
                    name: recurse(subtype)
                    for name, subtype in get_type_hints(
                        type_, include_extras=True
                    ).items()
                }
                return AsyncAPITypes.object_(content, **options)

            # Standard types: bool, float, int, string, any...
            elif type_ in cls._type_factories.keys():
                factory = cls._type_factories[type_]
                return factory(*metadata, **options)

            raise TypeError(f'unhandled type: {type_}')

        return recurse(hint)

    @classmethod
    def from_init(cls, class_: type, *, ignore_keys: set[str] | None = None) -> dict:
        ignore_keys = ignore_keys or set()
        init_fn = getattr(class_, '__init__')

        hints: dict[str, type] = {
            param: type_
            for param, type_ in get_type_hints(init_fn, include_extras=True).items()
            if param not in ignore_keys
        }

        payload = {param: cls._scan_hint(hint) for param, hint in hints.items()}

        # If there's only 1 key, flatten the dict
        if len(payload.keys()) == 1:
            key, value = payload.popitem()
            if value['type'] == 'object':
                return AsyncAPITypes.object_(value['properties'])
            return AsyncAPITypes.object_({key: value})
        return AsyncAPITypes.object_(payload)


class EventProxy:
    _DEFAULT_PAYLOAD_IGNORE_KEYS = {
        'self',
        'return',
        'tenant_uuid',
        'user_uuid',
        'user_uuids',
    }

    def __init__(self, class_: type):
        self.class_ = class_
        sig = inspect.signature(getattr(class_, '__init__'))
        self._parameters = sig.parameters
        self._keys = sig.parameters.keys()

    def __getattr__(self, attr: str) -> Any:
        return getattr(self.class_, attr)

    def __lt__(self, other: TypeAlias) -> bool:
        return self.name < other.name

    @staticmethod
    def is_event(class_: type) -> bool:
        if not inspect.isclass(class_):
            return False

        if not all(
            hasattr(class_, attr) for attr in ('name', 'routing_key_fmt', 'content')
        ):
            return False

        if inspect.isabstract(class_):
            return False

        return True

    def __repr__(self) -> str:
        return f'<Event \'{self.name}\'>'

    @property
    def service(self) -> str:
        return getattr(self.class_, 'service', 'undefined')

    def generate_tag(self) -> list[dict]:
        return [{'name': self.service}]

    def generate_headers(self) -> dict:
        headers = {
            'name': {
                'type': 'string',
                'const': self.name,
                'description': 'Name of the event (used for routing the message)',
            },
            'required_access': {
                'type': 'string',
                'const': f'event.{self.name}',
                'description': 'Necessary user access required to read this event',
            },
            'origin_uuid': {'$ref': '#/components/schemas/origin_uuid'},
            'timestamp': {'$ref': '#/components/schemas/timestamp'},
        }
        required = ['name', 'required_access', 'origin_uuid', 'timestamp']

        if 'tenant_uuid' in self._keys:
            headers['tenant_uuid'] = {'$ref': '#/components/schemas/tenant_uuid'}
            required.append('tenant_uuid')

        if any([key in self._keys for key in ('user_uuid', 'user_uuids')]):
            headers['user_uuid:{uuid}'] = {
                '$ref': '#/components/schemas/user_uuid:{uuid}'
            }
            required.append('user_uuid:{uuid}')

        return {'type': 'object', 'properties': headers, 'required': required}

    def generate_payload(self) -> dict:
        return Converter.from_init(
            self.class_, ignore_keys=self._DEFAULT_PAYLOAD_IGNORE_KEYS
        )

    def generate_parameters(self) -> dict:
        parameters = {}
        matches = re.search(r'\{(.*?)\}', self.name)
        if matches:
            for param in matches.groups() or []:
                parameters[param] = {
                    'description': '',
                    'schema': {
                        'type': 'string',
                    },
                }
        return parameters

    def generate_specification(self) -> dict:
        message_name = '-'.join([self.name.replace('_', '-'), 'payload'])
        doc = yaml.safe_load(self.class_.__doc__ or '')

        spec = {
            'subscribe': {
                'summary': doc or '',
                'tags': self.generate_tag(),
                'message': {
                    'name': message_name,
                    'payload': self.generate_payload(),
                    'headers': self.generate_headers(),
                },
            }
        }

        parameters = self.generate_parameters()
        if parameters:
            spec['parameters'] = parameters

        return {self.name: spec}


class EventSpecificationBuilder:
    def __init__(self, input_schema: str, version: str):
        self.platform_version = str(version)
        self.base_path = self.get_package_path(PACKAGE_NAME)
        resource_dir = self.base_path.joinpath('resources')
        self.paths = [path for path in resource_dir.iterdir() if path.is_dir()]

        with open(input_schema) as file:
            self.input_schema = yaml.safe_load(file)

    @staticmethod
    def get_package_path(package_name: str) -> Path:
        module = importlib.import_module(package_name)
        entrypoint = inspect.getfile(module)
        return Path(os.path.dirname(entrypoint))

    def get_resource_events(self, resource_path: Path) -> list[EventProxy]:
        events: list[EventProxy] = []
        file_paths = sorted(resource_path.glob('*.py'))

        for path in file_paths:
            name = os.path.splitext(path.relative_to(self.base_path))[0]
            import_name = '.'.join([PACKAGE_NAME, name.replace('/', '.')])

            try:
                module = importlib.import_module(import_name)
            except ModuleNotFoundError as e:
                print(f'skipping {name}: {e}')
                continue

            events.extend(
                EventProxy(cls)
                for _, cls in inspect.getmembers(module, EventProxy.is_event)
            )

        return events

    def generate_specifications(self, events: list[EventProxy]) -> dict:
        failures: set[tuple[str, Exception]] = set()
        specifications: defaultdict[str, dict] = defaultdict(dict)

        print(
            f'generating AsyncAPI specifications for `{self.platform_version}` '
            f'({len(events)} events)'
        )

        for event in events:
            service = event.service
            try:
                event_spec = event.generate_specification()
            except Exception as e:
                print('F', end='')
                failures.add((event.name, e))
            else:
                print('.', end='')
                specifications[service].update(event_spec)
        print('\n')

        if failures:
            for event_name, error in failures:
                print(f'Failed to generate specification for {event_name}: {error}')
            raise RuntimeError('Failed to generate AsyncAPI specifications')

        return specifications

    def write_specifications(
        self, specifications: dict, output_dir: str, *, dry_run: bool = False
    ) -> None:
        def write(service: str) -> str:
            service_name = (
                '-'.join(['accent', service]) if service != 'undefined' else service
            )
            path = Path(output_dir).joinpath(f'{service_name}.yml').resolve()
            schema = deepcopy(self.input_schema)
            schema['info']['title'] = f'{service_name} events'
            schema['info']['version'] = self.platform_version
            schema['channels'] = specifications[service]

            if dry_run:
                return f'would write \'{path}\''

            with open(path, 'w') as file:
                yaml.dump(schema, file, sort_keys=False)
            size = path.stat().st_size / 1024
            return f'wrote \'{path}\' ({size:.2f} KB)'

        with ThreadPoolExecutor() as executor:
            futs = [
                executor.submit(write, service) for service in specifications.keys()
            ]
        [print(fut.result()) for fut in futs]

    def run(self, output_dir: str = 'asyncapi', *, dry_run: bool = False) -> None:
        start_time = time()
        if dry_run:
            print('[DRY RUN]')

        with ThreadPoolExecutor() as executor:
            results = executor.map(self.get_resource_events, self.paths)

        events = sorted(chain(*results))
        specifications = self.generate_specifications(events)

        self.write_specifications(specifications, output_dir, dry_run=dry_run)
        exec_time = time() - start_time
        print(f'(execution took \'{exec_time:.3f}\' seconds)')


def generate_documentation(
    template_file: str, output_dir: str, version: str, *, dry_run: bool = False
) -> None:
    builder = EventSpecificationBuilder(template_file, version)
    try:
        builder.run(output_dir, dry_run=dry_run)
    except RuntimeError:
        print(flush=True)
        sys.exit('Error while generating AsyncAPI specifications, exiting...')


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Extract AsyncAPI specification for service\'s events'
    )

    parser.add_argument('-o', type=str, dest='output_dir', required=True)
    parser.add_argument('-p', type=str, dest='platform_version', required=True)
    parser.add_argument(
        '-t', type=str, dest='template_file', default='asyncapi-template.yml'
    )
    parser.add_argument(
        '--dry', action='store_true', dest='dry_run', help='don\'t write files'
    )

    parsed = parser.parse_args()
    generate_documentation(
        parsed.template_file,
        parsed.output_dir,
        parsed.platform_version,
        dry_run=parsed.dry_run,
    )

----------------------------------------

