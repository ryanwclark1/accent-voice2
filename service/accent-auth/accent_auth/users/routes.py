# accent_auth/users/routes.py

import logging

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from accent_auth.db.engine import AsyncSessionLocal
from accent_auth.services.user import UserService
from accent_auth.services.group import GroupService
from accent_auth.services.policy import PolicyService
from accent_auth.services.email import EmailService
from accent_auth.services.session import SessionService
from .dependencies import valid_user_id, valid_email_id, Permissions
from . import schemas  # Import schemas from the same module
from accent_auth import exceptions
from accent_auth.db import DAO
from accent_auth.dependencies import get_db


logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/users",
    tags=["users"],
)

@router.post("/", response_model=schemas.UserResult, status_code=status.HTTP_201_CREATED)
async def create_user(
    user: schemas.UserCreate,
    user_service: UserService = Depends(UserService),
    db: AsyncSession = Depends(get_db)
):
    """Creates a new user."""
    try:
        return await user_service.create(db=db, **user.model_dump())
    except exceptions.DuplicateUserException as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except Exception as e:
        logger.exception("Failed to create user: %s", e)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create user",
        )

@router.post("/register", response_model=schemas.UserResult, status_code=status.HTTP_201_CREATED)  # No specific permission for now
async def register_user(
    user_data: schemas.UserRegister,
    db: AsyncSession = Depends(get_db),
    user_service: UserService = Depends(UserService),
    tenant_service: TenantService = Depends(TenantService),
    email_service: EmailService = Depends(EmailService),
):
    """Registers a new user."""
    try:
        # Create a tenant for the user first
        tenant = await tenant_service.create(name=user_data.username, db=db) #Removed slug, now autogenerated
        # Create the user, associating it with the new tenant
        new_user = await user_service.create(
            tenant_uuid=tenant["uuid"], db=db, **user_data.model_dump()
        )

        # Send confirmation email (assuming you have this functionality)
        # await email_service.send_confirmation_email(...)
        # Removed as this send to be handled by the service, to be updated later.
        return new_user

    except exceptions.DuplicateUserException as e:  # Example custom exception
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except Exception as e:
        logger.exception("Failed to register user: %s", e)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to register user",
        )

@router.get("/{user_uuid}", response_model=schemas.UserResult, dependencies=[Depends(Permissions.USER_READ)])
async def get_user(
    user_uuid: str = Depends(valid_user_id),  # Use dependency for validation
    user_service: UserService = Depends(UserService),
    db: AsyncSession = Depends(get_db)
):
    """Retrieves the details of a user."""
    user = await user_service.get_user(user_uuid, db=db)  # No need to check for None
    return user


@router.put("/{user_uuid}", response_model=schemas.UserResult, dependencies=[Depends(Permissions.USER_UPDATE)])
async def update_user(
    user_uuid: str = Depends(valid_user_id), # Use dependency
    user_update: schemas.UserUpdate,
    user_service: UserService = Depends(UserService),
    db: AsyncSession = Depends(get_db)
):
    """Updates an existing user."""
    try:
        updated_user = await user_service.update(user_uuid, db=db, **user_update.model_dump())
        return updated_user
    except exceptions.DuplicateUserException as e:
         raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except Exception as e:
        logger.exception(f"Failed to update user {user_uuid}: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, detail=str(e)
        )


@router.delete("/{user_uuid}", status_code=status.HTTP_204_NO_CONTENT, dependencies=[Depends(Permissions.USER_DELETE)])
async def delete_user(
    user_uuid: str = Depends(valid_user_id), # Use dependency
    user_service: UserService = Depends(UserService),
    db: AsyncSession = Depends(get_db)
):
    """Deletes a user."""
    await user_service.delete_user(user_uuid, db=db)
    return  # 204 No Content

@router.put("/{user_uuid}/password", status_code=status.HTTP_204_NO_CONTENT, dependencies=[Depends(Permissions.USER_PW_UPDATE)])
async def change_password(
    user_uuid: str = Depends(valid_user_id),
    password_change: schemas.PasswordChange,
    user_service: UserService = Depends(UserService),
    db: AsyncSession = Depends(get_db),
):
    """Changes the user's password."""
    try:
        await user_service.change_password(
            user_uuid,
            password_change.old_password,
            password_change.new_password,
            db=db,
        )
        return  # 204 No Content
    except exceptions.AuthenticationFailedException:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials"
        )

@router.get("/users", response_model=schemas.UserList)
async def list_users(
    user_service: UserService = Depends(UserService),
    db: AsyncSession = Depends(get_db),
    offset: int = 0,
    limit: int = 100,
):
    """Lists users with pagination."""
    try:
        users = await user_service.list_users(db=db, offset=offset, limit=limit)
        total = await user_service.count_users(db=db)  # You'll need a count method
        filtered = total  # Adjust if you have filtering
        return {"items": users, "total": total, "filtered": filtered}
    except Exception as e:
        logger.exception("Failed to list users: %s", e)
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

@router.put("/{user_uuid}/emails", response_model=list[schemas.Email]) # Assuming you have an Email schema
async def update_user_emails(
    user_uuid: str,
    emails: list[schemas.EmailUpdate],
    user_service: UserService = Depends(UserService),
    db: AsyncSession = Depends(get_db)
    ):
    """Update a user's email addresses."""
    try:
        updated_emails = await user_service.update_emails(user_uuid, emails, db=db)
        return updated_emails
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))

@router.get("/{user_uuid}/emails/{email_uuid}/confirm")
async def confirm_email(
    user_uuid: str = Depends(valid_user_id),
    email_uuid: str = Depends(valid_email_id),
    email_service: EmailService = Depends(EmailService),
    db: AsyncSession = Depends(get_db)
):
    """Confirms a user's email address."""
    try:
        await email_service.confirm(email_uuid, db=db)
        body = email_service._get_body # Need to update services
        return Response(content=body, media_type='text/html') #Using a default media type
    except exceptions.UnknownEmailException:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Email not found")
    except Exception as e:
        logger.exception(f"Failed to confirm email {email_uuid}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)
        )
    
@router.get("/{user_uuid}/groups", response_model=list[Group], dependencies=[Depends(Permissions.USER_READ)])
async def list_user_groups(
    user_uuid: str = Depends(valid_user_id),
    group_service: GroupService = Depends(GroupService),
    db: AsyncSession = Depends(get_db)
):
    """Lists the groups a user belongs to."""
    try:
        groups = await group_service.list_groups(user_uuid, db=db)
        return groups
    except Exception as e:
        logger.exception("Failed to list groups for user %s: %s", user_uuid, e)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to list groups",
        )

# --- User Sessions ---
@router.get("/{user_uuid}/sessions", response_model=schemas.UserSessionList)
async def list_user_sessions(
    user_uuid: str = Depends(valid_user_id),
    session_service: SessionService = Depends(SessionService),
    db: AsyncSession = Depends(get_db),
    offset: int = 0,
    limit: int = 100,
):
    """Retrieves the list of sessions for a user."""
    try:
        sessions = await session_service.list_(user_uuid=user_uuid, db=db, offset=offset, limit=limit)
        total = await session_service.count(user_uuid=user_uuid, db=db)
        filtered = total  # Modify if you add filtering
        return {"items": sessions, "total": total, "filtered": filtered}
    except Exception as e:
        logger.exception("Failed to list user sessions for user %s: %s", user_uuid, e)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to list user sessions",
        )

@router.delete("/{user_uuid}/sessions/{session_uuid}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user_session(
    user_uuid: str = Depends(valid_user_id),
    session_uuid: str = Depends(valid_session_id),
    session_service: SessionService = Depends(SessionService),
    db: AsyncSession = Depends(get_db)
):
    """Deletes a specific session for a user."""
    try:
        await session_service.delete(session_uuid, user_uuid, db=db)  # Adapt to your service method
    except Exception as e:
        logger.exception(
            "Failed to delete session %s for user %s: %s",
            session_uuid,
            user_uuid,
            e,
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete user session",
        )
    return