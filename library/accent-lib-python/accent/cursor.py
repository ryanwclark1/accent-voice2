from __future__ import annotations

import datetime as dt
from collections.abc import Callable, Iterable
from types import TracebackType
from typing import Any, Literal, Protocol


class CursorProtocol(Protocol):
    # Attributes
    arraysize: int
    binary_types: Any | None  # Replace `Any` with the actual type if known
    connection: Any  # Replace with `_Connection` if explicitly defined
    itersize: int
    row_factory: Any | None  # Replace `Any` with the actual type if known
    scrollable: bool | None
    string_types: Any | None  # Replace `Any` with the actual type if known
    tzinfo_factory: Callable[..., dt.tzinfo]
    withhold: bool

    # Properties
    @property
    def closed(self) -> bool: ...
    @property
    def lastrowid(self) -> int: ...
    @property
    def name(self) -> Any | None: ...  # Replace `Any` with the actual type if known
    @property
    def query(self) -> bytes | None: ...
    @property
    def description(self) -> tuple[Any, ...] | None: ...
    @property
    def rowcount(self) -> int: ...
    @property
    def rownumber(self) -> int: ...
    @property
    def typecaster(self) -> Any | None: ...  # Replace with the actual type if known
    @property
    def statusmessage(self) -> str | None: ...
    @property
    def pgresult_ptr(self) -> int | None: ...

    # Methods
    def callproc(self, procname: str | bytes, parameters: Any | None = ...) -> None: ...
    def cast(self, oid: int, s: str | bytes) -> Any: ...
    def close(self) -> None: ...
    def copy_expert(
        self, sql: str | bytes | Any, file: Any, size: int = 8192
    ) -> None: ...
    def copy_from(
        self,
        file: Any,
        table: str,
        sep: str = "\t",
        null: str = "\\N",
        size: int = 8192,
        columns: Iterable[str] | None = None,
    ) -> None: ...
    def copy_to(
        self,
        file: Any,
        table: str,
        sep: str = "\t",
        null: str = "\\N",
        columns: Iterable[str] | None = None,
    ) -> None: ...
    def execute(self, query: str | bytes | Any, vars: Any | None = None) -> None: ...
    def executemany(
        self, query: str | bytes | Any, vars_list: Iterable[Any]
    ) -> None: ...
    def fetchall(self) -> list[tuple[Any, ...]]: ...
    def fetchmany(self, size: int | None = None) -> list[tuple[Any, ...]]: ...
    def fetchone(self) -> tuple[Any, ...] | None: ...
    def mogrify(self, query: str | bytes | Any, vars: Any | None = None) -> bytes: ...
    def nextset(self) -> None: ...
    def scroll(
        self, value: int, mode: Literal["absolute", "relative"] = "relative"
    ) -> None: ...
    def setinputsizes(self, sizes: Any) -> None: ...
    def setoutputsize(self, size: int, column: int = ..., /) -> None: ...
    def __enter__(self) -> CursorProtocol: ...
    def __exit__(
        self,
        type: type[BaseException] | None,
        value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None: ...
    def __iter__(self) -> CursorProtocol: ...
    def __next__(self) -> tuple[Any, ...]: ...
